<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="utf-8">
<title>AI VTuber - Idle Animations</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<style>
    body {
        margin: 0;
        padding: 0;
        overflow: hidden; 
        /* äº®é‡‘è‰²æ¼¸å±¤èƒŒæ™¯ */
        background: linear-gradient(135deg, #fff8e1 0%, #ffecb3 50%, #ffe0b2 100%);
        font-family: "Noto Sans TC", sans-serif;
        overscroll-behavior: none; 
        width: 100vw;
        height: 100vh;
        height: -webkit-fill-available;
    }
    
    /* è®€å–ç•«é¢ */
    #loading-screen {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(255, 255, 255, 0.95);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 999;
        transition: opacity 0.5s ease;
    }
    
    .loader {
        border: 4px solid #fff3e0;
        border-top: 4px solid #d32f2f;
        border-radius: 50%;
        width: 40px; height: 40px;
        animation: spin 1s linear infinite;
        margin-bottom: 15px;
    }

    .loading-text { color: #d32f2f; font-size: 1rem; font-weight: bold; margin-bottom: 20px; }

    #start-btn {
        padding: 12px 30px;
        font-size: 1.1rem;
        background: linear-gradient(to right, #d32f2f, #f44336);
        color: #ffd700;
        border: 2px solid #ffd700;
        border-radius: 50px;
        cursor: pointer;
        display: none;
        box-shadow: 0 4px 15px rgba(211, 47, 47, 0.3);
        transition: transform 0.2s, background 0.2s;
        font-weight: bold;
        text-shadow: 0 1px 2px rgba(0,0,0,0.2);
    }
    #start-btn:active { transform: scale(0.95); background: #b71c1c; }

    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    /* API ç‹€æ…‹ (å³ä¸Šè§’) */
    #api-status {
        position: absolute;
        top: 15px; right: 15px;
        padding: 6px 12px;
        background: rgba(255, 255, 255, 0.8);
        backdrop-filter: blur(4px);
        border-radius: 20px;
        font-size: 12px;
        font-weight: bold;
        color: #bf360c;
        display: flex; align-items: center;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        z-index: 100;
        transition: all 0.3s;
        border: 1px solid #ffcc80;
    }
    .status-dot { width: 8px; height: 8px; border-radius: 50%; background-color: #ccc; margin-right: 6px; }
    .status-connected { background-color: #2ecc71; box-shadow: 0 0 5px #2ecc71; }
    .status-error { background-color: #e74c3c; box-shadow: 0 0 5px #e74c3c; }
    .status-preview { background-color: #f39c12; box-shadow: 0 0 5px #f39c12; }

    /* æª”æ¡ˆè®€å–ç‹€æ…‹é¢æ¿ */
    #file-status {
        position: absolute;
        top: 15px; left: 15px;
        padding: 10px;
        background: rgba(255, 255, 255, 0.8);
        backdrop-filter: blur(4px);
        border-radius: 12px;
        font-size: 12px;
        color: #5d4037;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        z-index: 100;
        max-width: 180px;
        transition: opacity 0.5s;
        pointer-events: none;
        border: 1px solid #ffcc80;
    }
    .file-status-item { 
        margin-bottom: 4px; 
        display: flex; 
        align-items: center; 
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    .file-status-item:last-child { margin-bottom: 0; }
    .icon-ok { color: #2e7d32; margin-right: 6px; font-weight: bold; }
    .icon-fail { color: #c62828; margin-right: 6px; font-weight: bold; }
    .icon-loading { color: #ef6c00; margin-right: 6px; animation: pulse 1s infinite; }
    
    /* å°è©±ä»‹é¢ */
    #chat-container {
        position: absolute; 
        bottom: 20px; 
        left: 50%; 
        transform: translateX(-50%);
        width: 90%; 
        max-width: 600px;
        display: flex; 
        flex-direction: column; 
        gap: 8px;
        z-index: 100;
        transition: bottom 0.3s;
    }

    @media (max-width: 600px) {
        #chat-container {
            width: 95%; 
            bottom: 30px; 
        }
        #file-status, #api-status {
            top: 10px;
            transform: scale(0.9); 
            transform-origin: top;
        }
        #file-status { left: 10px; }
        #api-status { right: 10px; }
    }

    #chat-display {
        background: rgba(255, 255, 255, 0.4); 
        padding: 12px; 
        border-radius: 16px;
        height: 140px; 
        overflow-y: auto;
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 215, 0, 0.6);
        display: flex;
        flex-direction: column;
        gap: 8px;
        scrollbar-width: none; 
        -ms-overflow-style: none;
    }
    #chat-display::-webkit-scrollbar { display: none; }

    .message {
        padding: 8px 12px;
        border-radius: 12px;
        max-width: 85%;
        word-wrap: break-word;
        font-size: 14px;
        line-height: 1.5;
        color: white;
        text-shadow: 0 1px 1px rgba(0,0,0,0.1);
    }

    .message-user { 
        align-self: flex-end; 
        background-color: rgba(211, 47, 47, 0.9); 
        border-bottom-right-radius: 2px; 
        color: #fff;
    }
    .message-ai { 
        align-self: flex-start; 
        background-color: rgba(255, 255, 255, 0.9); 
        border-bottom-left-radius: 2px; 
        color: #333; 
        text-shadow: none;
        border: 1px solid #ffd700;
    }
    .message-system { align-self: center; background: transparent; color: #e65100; font-size: 12px; font-style: italic; text-shadow: none; text-align: center;}

    .message a { color: #1e88e5; text-decoration: none; border-bottom: 1px dotted #1e88e5; }
    .message-user a { color: #ffe0b2; }

    #input-area { display: flex; gap: 8px; align-items: center; }
    
    #user-input {
        flex: 1; 
        padding: 12px 16px; 
        border-radius: 25px; 
        border: 1px solid rgba(255, 215, 0, 0.6);
        outline: none;
        background: rgba(255, 255, 255, 0.95); 
        font-size: 16px; 
        box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        color: #5d4037;
    }
    #user-input::placeholder { color: #999; }

    #send-btn {
        padding: 0 20px; 
        height: 44px; 
        border-radius: 22px; border: none;
        background: linear-gradient(to right, #d32f2f, #c62828);
        color: #ffd700; font-weight: bold; cursor: pointer;
        transition: background 0.2s;
        box-shadow: 0 4px 10px rgba(198, 40, 40, 0.3);
        flex-shrink: 0;
        border: 1px solid #ffd700;
    }
    #send-btn:active { transform: scale(0.95); }
    #send-btn:disabled { background: #bdbdbd; box-shadow: none; cursor: not-allowed; border: none; color: #fff;}

    #mute-btn {
        width: 44px; height: 44px; border-radius: 50%; border: none;
        background: rgba(255, 255, 255, 0.95); font-size: 20px; cursor: pointer;
        display: flex; justify-content: center; align-items: center;
        box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        flex-shrink: 0;
        border: 1px solid #ffd700;
        color: #d32f2f;
    }
    #mute-btn.muted { background: #e74c3c; color: white; border: none; }
    
    #emotion-debug {
        position: absolute; top: 60px; right: 15px;
        font-size: 10px; color: #5d4037;
        background: rgba(255,255,255,0.7);
        padding: 4px 8px; border-radius: 6px;
        pointer-events: none;
        backdrop-filter: blur(2px);
        text-align: right;
        line-height: 1.3;
        opacity: 0.6; 
    }

</style>

<script type="importmap">
{
    "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/",
        "@pixiv/three-vrm": "https://unpkg.com/@pixiv/three-vrm@3.0.0/lib/three-vrm.module.js",
        "@pixiv/three-vrm-animation": "https://unpkg.com/@pixiv/three-vrm-animation@3.0.0/lib/three-vrm-animation.module.js"
    }
}
</script>
</head>

<body>

    <div id="loading-screen">
        <div class="loader" id="loader"></div>
        <div class="loading-text" id="status-text">åˆå§‹åŒ–æ–°å¹´ç³»çµ±...</div>
        <button id="start-btn">é–‹å§‹æ–°å¹´å°è©±</button>
    </div>

    <div id="file-status">
        <div class="file-status-item"><span class="icon-loading">â—</span> ç³»çµ±å•Ÿå‹•...</div>
    </div>

    <div id="api-status">
        <div class="status-dot" id="status-dot"></div>
        <span id="status-msg">é€£ç·šä¸­...</span>
    </div>
    
    <div id="emotion-debug">
        æƒ…ç·’: Neutral<br>
        å‹•ä½œ: None
    </div>

    <div id="chat-container">
        <div id="chat-display">
            <!-- è¨Šæ¯å°‡ç”± JavaScript å‹•æ…‹åŠ å…¥ -->
        </div>
        <div id="input-area">
            <button id="mute-btn" title="åˆ‡æ›è²éŸ³">ğŸ”Š</button>
            <input type="text" id="user-input" placeholder="è¼¸å…¥æ–°å¹´ç¥ç¦..." disabled>
            <button id="send-btn" disabled>ç™¼é€</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';
        import { VRMAnimationLoaderPlugin } from '@pixiv/three-vrm-animation';

        const API_URL = "/api/chat"; 
        const VRM_URL = 'https://davidkuodcam-crypto.github.io/VTuber/AvatarSample_C.vrm';
        
        // --- é–’ç½®å‹•ç•«è¨­å®š ---
        const IDLE_ANIMATIONS = [
            './Taunt_with_Skin.vrma',
            './Breakdance_Freeze_Var_3.vrma'
        ];
        const IDLE_TIMEOUT_MS = 10000; // 10ç§’

        let currentVrm = undefined;
        let currentMixer = undefined; // å‹•ç•«æ··åˆå™¨
        let idleClips = []; // å„²å­˜è¼‰å…¥çš„å‹•ç•«ç‰‡æ®µ
        let idleAction = undefined; // ç•¶å‰æ’­æ”¾çš„å‹•ç•«å‹•ä½œ
        let lastInteractionTime = Date.now();
        let isIdleMode = false;
        let currentIdleIndex = 0;

        let chatHistory = [];
        let isSpeaking = false;
        let currentEmotion = 'neutral';
        let isMuted = false;
        
        let externalSystemPrompt = ""; 
        let externalKnowledge = "";
        let openingRemark = ""; 

        const isPreviewEnv = window.location.protocol === 'blob:' || window.location.protocol === 'file:';

        // --- å ´æ™¯åˆå§‹åŒ– ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xfff8e1); 
        scene.fog = new THREE.Fog(0xfff8e1, 5, 15);
        scene.add(new THREE.GridHelper(20, 20, 0xd32f2f, 0xffcc80)); 

        const camera = new THREE.PerspectiveCamera(30.0, window.innerWidth / window.innerHeight, 0.1, 20.0);
        
        // **ç›¸æ©Ÿä½ç½®é‚è¼¯ (æ”¯æ´é–’ç½®å…¨èº«æ¨¡å¼)**
        function updateCameraPosition() {
            const aspect = window.innerWidth / window.innerHeight;
            
            if (isIdleMode) {
                // --- é–’ç½®æ¨¡å¼ï¼šå…¨èº«è¦–è§’ ---
                if (aspect < 0.8) {
                    // æ‰‹æ©Ÿç›´ç«‹ï¼šæ‹‰é ä»¥é¡¯ç¤ºå…¨èº«
                    camera.position.set(0.0, 1.0, 5.0);
                    if (currentVrm) controls.target.set(0.0, 0.9, 0.0);
                } else {
                    // é›»è…¦å¯¬è¢å¹•
                    camera.position.set(0.0, 1.0, 4.5);
                    if (currentVrm) controls.target.set(0.0, 0.9, 0.0);
                }
            } else {
                // --- æ­£å¸¸å°è©±æ¨¡å¼ï¼šåŠèº«/ç‰¹å¯«è¦–è§’ ---
                if (aspect < 0.8) {
                    // æ‰‹æ©Ÿç›´ç«‹ï¼šç‰¹å¯«
                    camera.position.set(0.0, 1.35, 2.2); 
                    if(currentVrm) controls.target.set(0.0, 1.35, 0.0);
                } else {
                    // é›»è…¦å¯¬è¢å¹•
                    camera.position.set(0.0, 1.4, 3.5);
                    if(currentVrm) controls.target.set(0.0, 1.3, 0.0); 
                }
            }
            camera.updateProjectionMatrix();
            controls.update();
        }

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
        document.body.appendChild(renderer.domElement);

        const directionalLight = new THREE.DirectionalLight(0xffedd5, 1.5); 
        directionalLight.position.set(-1.0, 2.0, 1.0).normalize();
        scene.add(directionalLight);
        
        const fillLight = new THREE.DirectionalLight(0xffd700, 0.6);
        fillLight.position.set(1.0, 1.0, 1.0).normalize();
        scene.add(fillLight);
        
        scene.add(new THREE.AmbientLight(0xffffff, 0.5));

        // --- æ–°å¹´ç‰¹æ•ˆ ---
        let particlesMesh;
        const particlesCount = 300; 
        function createFestiveParticles() {
            const geometry = new THREE.BufferGeometry();
            const posArray = new Float32Array(particlesCount * 3);
            const colorArray = new Float32Array(particlesCount * 3);
            
            for(let i = 0; i < particlesCount * 3; i+=3) {
                posArray[i] = (Math.random() - 0.5) * 15; 
                posArray[i+1] = Math.random() * 10;       
                posArray[i+2] = (Math.random() - 0.5) * 15; 

                if (Math.random() > 0.5) {
                    colorArray[i] = 0.9; colorArray[i+1] = 0.1; colorArray[i+2] = 0.1;
                } else {
                    colorArray[i] = 0.8; colorArray[i+1] = 0.6; colorArray[i+2] = 0.0;
                }
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.15, 
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
            });
            
            particlesMesh = new THREE.Points(geometry, material);
            scene.add(particlesMesh);
        }
        createFestiveParticles();

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enablePan = true; 
        controls.screenSpacePanning = true; 
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 1.0; 
        controls.maxDistance = 8.0;
        controls.maxPolarAngle = Math.PI / 2 + 0.1; 
        controls.minPolarAngle = Math.PI / 3;

        updateCameraPosition(); 

        // --- è¼‰å…¥å¤–éƒ¨æª”æ¡ˆèˆ‡å‹•ç•« ---
        async function loadExternalData() {
            // ... (åŒå‰ï¼Œç•¥éé‡è¤‡ç¨‹å¼ç¢¼ï¼Œä½†åŠ å…¥å‹•ç•«è¼‰å…¥) ...
            const statusText = document.getElementById('status-text');
            const fileStatusDiv = document.getElementById('file-status');
            
            let promptStatusHTML = '<span class="icon-loading">â—</span> Prompt';
            let kbStatusHTML = '<span class="icon-loading">â—</span> KB';

            const renderStatus = () => {
                fileStatusDiv.innerHTML = `
                    <div class="file-status-item">${promptStatusHTML}</div>
                    <div class="file-status-item">${kbStatusHTML}</div>
                `;
            };
            renderStatus();

            // 1. è®€å– Prompt
            try {
                statusText.innerText = "è®€å–è§’è‰²è¨­å®š...";
                const res = await fetch(`./Prompt.txt?t=${Date.now()}`);
                if (res.ok) {
                    externalSystemPrompt = await res.text();
                    promptStatusHTML = '<span class="icon-ok">âœ“</span> Prompt OK';
                } else {
                    promptStatusHTML = '<span class="icon-fail">âœ—</span> Prompt Def';
                }
            } catch (e) {
                promptStatusHTML = '<span class="icon-fail">âœ—</span> Prompt Err';
            }
            renderStatus();

            // 2. è®€å– KB
            statusText.innerText = "è®€å–é›²ç«¯çŸ¥è­˜åº«...";
            let fileIndex = 1;
            let keepLoading = true;
            let loadedCount = 0;
            
            while (keepLoading) {
                const fileNameRoot = `KnowledgeBase${String(fileIndex).padStart(2, '0')}.txt`;
                const fileNameFolder = `KnowledgeBase/KnowledgeBase${String(fileIndex).padStart(2, '0')}.txt`;
                
                kbStatusHTML = `<span class="icon-loading">â—</span> æƒæ KB${String(fileIndex).padStart(2,'0')}...`;
                renderStatus();

                try {
                    let res = await fetch(`./${fileNameFolder}?t=${Date.now()}`);
                    let usedPath = fileNameFolder;
                    if (!res.ok) {
                         res = await fetch(`./${fileNameRoot}?t=${Date.now()}`);
                         usedPath = fileNameRoot;
                    }

                    if (res.ok) {
                        const text = await res.text();
                        if (text.trim().length > 0) {
                            if (fileIndex === 1) openingRemark = text;
                            externalKnowledge += `\n\nã€KB: ${usedPath}ã€‘\n${text}`;
                            loadedCount++;
                            fileIndex++;
                        } else {
                            fileIndex++;
                        }
                    } else {
                        keepLoading = false;
                    }
                } catch (e) {
                    keepLoading = false;
                }
            }
            
            if (loadedCount > 0) kbStatusHTML = `<span class="icon-ok">âœ“</span> KB x${loadedCount}`;
            else kbStatusHTML = `<span class="icon-fail">âœ—</span> No KB`;
            renderStatus();

            // 3. é è¼‰å‹•ç•«æª”æ¡ˆ
            statusText.innerText = "è¼‰å…¥å‹•ä½œæª”æ¡ˆ...";
            // é€™è£¡æˆ‘å€‘åªè¼‰å…¥æª”æ¡ˆï¼Œç¶å®šåˆ° VRM æœƒåœ¨ VRM è¼‰å…¥å¾Œé€²è¡Œ
            for (const url of IDLE_ANIMATIONS) {
                try {
                    // æˆ‘å€‘ä½¿ç”¨ä¸» loader ä¾†è¼‰å…¥ vrma
                    // é€™è£¡å…ˆä¸åŸ·è¡Œï¼Œç­‰å¾… loader åˆå§‹åŒ–
                } catch (e) {
                    console.error("Failed to load animation", url, e);
                }
            }
            statusText.innerText = "ç³»çµ±å°±ç·’ï¼";
        }

        // --- VRM & å‹•ç•«è¼‰å…¥ ---
        const loader = new GLTFLoader();
        loader.crossOrigin = 'anonymous';
        
        // è¨»å†Šæ’ä»¶
        loader.register((parser) => new VRMLoaderPlugin(parser));
        loader.register((parser) => new VRMAnimationLoaderPlugin(parser));

        async function loadVRMAndAnimations() {
            // 1. è¼‰å…¥æœ¬é«”
            const vrmGltf = await new Promise((resolve, reject) => {
                loader.load(VRM_URL, resolve, 
                    (progress) => {
                        const percent = Math.round(100.0 * (progress.loaded / progress.total));
                        document.getElementById('status-text').innerText = `ä¸‹è¼‰æ¨¡å‹... ${percent}%`;
                    }, 
                    reject
                );
            });
            
            const vrm = vrmGltf.userData.vrm;
            VRMUtils.rotateVRM0(vrm);
            scene.add(vrm.scene);
            currentVrm = vrm;
            
            // åˆå§‹åŒ–å‹•ç•«æ··åˆå™¨
            currentMixer = new THREE.AnimationMixer(currentVrm.scene);

            // ä¿®æ­£æ‰‹è‡‚
            const leftUpperArm = vrm.humanoid.getNormalizedBoneNode('leftUpperArm');
            const rightUpperArm = vrm.humanoid.getNormalizedBoneNode('rightUpperArm');
            if (leftUpperArm) { leftUpperArm.rotation.z = -1.1; leftUpperArm.rotation.x = 0.15; }
            if (rightUpperArm) { rightUpperArm.rotation.z = 1.1; rightUpperArm.rotation.x = 0.15; }

            // 2. è¼‰å…¥å‹•ç•«ä¸¦ç¶å®šåˆ°æ­¤ VRM
            for (const url of IDLE_ANIMATIONS) {
                try {
                    const vrmaGltf = await new Promise((resolve, reject) => {
                        loader.load(url, resolve, undefined, reject);
                    });
                    
                    const vrmAnimation = vrmaGltf.userData.vrmAnimations[0];
                    if (vrmAnimation) {
                        const clip = vrmAnimation.createAnimationClip(currentVrm);
                        idleClips.push(clip);
                    }
                } catch (e) {
                    console.warn(`ç„¡æ³•è¼‰å…¥å‹•ç•«: ${url}`, e);
                }
            }

            updateCameraPosition();
            startBlinking();
        }

        Promise.all([
            loadVRMAndAnimations(),
            loadExternalData()
        ]).then(() => {
            const loaderEl = document.getElementById('loader');
            const statusText = document.getElementById('status-text');
            const startBtn = document.getElementById('start-btn');
            
            loaderEl.style.display = 'none';
            statusText.innerText = "æº–å‚™å®Œæˆ";
            startBtn.style.display = 'block';

            startBtn.addEventListener('click', () => {
                // äº’å‹•é–‹å§‹ï¼Œé‡ç½®æ™‚é–“
                lastInteractionTime = Date.now();

                if (!isMuted) {
                    window.speechSynthesis.cancel();
                    const silent = new SpeechSynthesisUtterance(" ");
                    silent.volume = 0; silent.rate = 10;
                    window.speechSynthesis.speak(silent);
                }

                const loadingScreen = document.getElementById('loading-screen');
                loadingScreen.style.opacity = 0;
                setTimeout(() => loadingScreen.style.display = 'none', 500);

                const introText = openingRemark || "ï¼ˆæœªè®€å–åˆ° KnowledgeBase01.txtï¼Œè«‹æª¢æŸ¥æª”æ¡ˆï¼‰";
                addMessage(introText, 'ai');
                chatHistory.push({ role: "model", parts: [{ text: introText }] });
                speak(introText);
                testApiConnection();
            });
        });

        // --- é–’ç½®é‚è¼¯ ---
        function startIdleAnimation() {
            if (isIdleMode || idleClips.length === 0) return;
            isIdleMode = true;
            updateCameraPosition(); // åˆ‡æ›åˆ°å…¨èº«è¦–è§’
            
            // æ’­æ”¾ç¬¬ä¸€å€‹å‹•ç•«
            playIdleClip(0);
        }

        function playIdleClip(index) {
            if (!isIdleMode) return;
            
            // åœæ­¢ç•¶å‰å‹•ä½œ
            if (idleAction) idleAction.fadeOut(0.5);
            
            const clip = idleClips[index % idleClips.length];
            idleAction = currentMixer.clipAction(clip);
            idleAction.reset();
            idleAction.fadeIn(0.5);
            idleAction.play();
            
            // ç›£è½å‹•ç•«çµæŸï¼Œæ’­æ”¾ä¸‹ä¸€å€‹ (loop)
            // éœ€æ³¨æ„ï¼šå¦‚æœæ˜¯ loop å‹•ç•«ï¼Œå¯èƒ½éœ€è¦æ‰‹å‹•ç›£è½æ™‚é–“æˆ–è¨­å®š loop once
            // å‡è¨­ vrma æ˜¯å¾ªç’°çš„ï¼Œæˆ‘å€‘è¨­å®šå…¶ loop æ¨¡å¼
            // è‹¥è¦è¼ªæ’­ï¼Œæˆ‘å€‘å¯ä»¥è®“æ¯å€‹å‹•ä½œæ’­ä¸€æ¬¡ç„¶å¾Œæ›ä¸‹ä¸€å€‹
            // ä½†é€šå¸¸ idle å‹•ä½œæ˜¯ Loop çš„ï¼Œé€™è£¡æˆ‘å€‘è¨­å®šæ’­å®Œä¸€æ¬¡æ›ä¸‹ä¸€å€‹ï¼Œæˆ–è€…æ’­ä¸€æ®µæ™‚é–“
            
            // é€™è£¡ç°¡å–®å¯¦ä½œï¼šç›£è½å–®æ¬¡æ’­æ”¾çµæŸ (è‹¥å‹•ç•«é Loop)
            // è‹¥å‹•ç•«é è¨­æ˜¯ Loopï¼Œå‰‡æˆ‘å€‘å¯ä»¥ç”¨ setTimeout å¼·åˆ¶åˆ‡æ›
            
            currentIdleIndex = index;
        }
        
        // ç›£è½å‹•ç•«å¾ªç’°/çµæŸäº‹ä»¶ä¾†åˆ‡æ›å‹•ä½œ
        // ç‚ºäº†ç°¡å–®è¼ªæ’­ï¼Œæˆ‘å€‘æ¯ 10 ç§’åˆ‡æ›ä¸€æ¬¡å‹•ä½œï¼Œæˆ–è€…ç›£è½ finished
        // ç”±æ–¼ AnimationMixer çš„ finished åªæœ‰åœ¨é Loop æ™‚è§¸ç™¼
        // æˆ‘å€‘é€™è£¡æ¡ç”¨ç°¡å–®çš„ Timer åˆ‡æ›ï¼Œè®“æ¯å€‹å‹•ä½œå±•ç¤ºä¸€é™£å­
        setInterval(() => {
            if (isIdleMode && idleClips.length > 1) {
                playIdleClip(currentIdleIndex + 1);
            }
        }, 12000); // æ¯ 12 ç§’æ›ä¸€å€‹å‹•ä½œ

        function stopIdleAnimation() {
            if (!isIdleMode) return;
            isIdleMode = false;
            updateCameraPosition(); // åˆ‡å›ç‰¹å¯«
            
            if (idleAction) {
                idleAction.fadeOut(0.5);
                idleAction = undefined;
            }
            // è®“ mixer å›åˆ°åˆå§‹ç‹€æ…‹
            currentMixer.stopAllAction();
        }

        // --- å‹•ç•« ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            const elapsedTime = clock.elapsedTime;

            // æª¢æŸ¥é–’ç½®
            if (!isIdleMode && Date.now() - lastInteractionTime > IDLE_TIMEOUT_MS) {
                startIdleAnimation();
            }

            // æ›´æ–°æ··åˆå™¨ (è™•ç† vrma å‹•ä½œ)
            if (currentMixer) {
                currentMixer.update(deltaTime);
            }

            // ç²’å­å‹•ç•«
            if (particlesMesh) {
                particlesMesh.rotation.y += 0.001; 
                const positions = particlesMesh.geometry.attributes.position.array;
                for(let i = 1; i < particlesCount * 3; i+=3) {
                    positions[i] -= 0.015; 
                    if (positions[i] < 0) positions[i] = 10;
                }
                particlesMesh.geometry.attributes.position.needsUpdate = true;
            }

            if (currentVrm) {
                currentVrm.update(deltaTime);
                
                // åªæœ‰åœ¨éé–’ç½®æ¨¡å¼ (æ²’æ’­å…¨èº«å‹•ä½œ) æ™‚ï¼Œæ‰åŠ å…¥å‘¼å¸èˆ‡èªªè©±å˜´å‹
                // é¿å…èˆ‡ vrma å‹•ä½œè¡çª
                if (!isIdleMode) {
                    const spine = currentVrm.humanoid.getNormalizedBoneNode('spine');
                    if (spine) {
                        spine.rotation.x = Math.sin(elapsedTime * 1.5) * 0.02;
                        spine.rotation.y = Math.sin(elapsedTime * 0.8) * 0.02;
                    }
                    if (isSpeaking && !isMuted) {
                        const s = Math.sin(elapsedTime * 18); 
                        currentVrm.expressionManager.setValue('aa', (s + 1) / 2 * 0.6);
                    } else {
                        const currentVal = currentVrm.expressionManager.getValue('aa');
                        currentVrm.expressionManager.setValue('aa', THREE.MathUtils.lerp(currentVal, 0, 0.2));
                    }
                } else {
                    // é–’ç½®æ¨¡å¼ä¸‹ï¼Œå˜´å·´é–‰ä¸Š (é™¤é vrma æœ‰è¡¨æƒ…)
                    currentVrm.expressionManager.setValue('aa', 0);
                }
            }
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        function startBlinking() {
            if(!currentVrm) return;
            const blinkLoop = () => {
                if (!window.actionActive && !isIdleMode) { // é–’ç½®æ™‚ä¹Ÿæš«åœçœ¨çœ¼ä»¥å…è¡çª
                    setTimeout(() => {
                        currentVrm.expressionManager.setValue('blink', 1);
                        setTimeout(() => {
                            currentVrm.expressionManager.setValue('blink', 0);
                            blinkLoop();
                        }, 120);
                    }, Math.random() * 3000 + 2000);
                } else {
                    setTimeout(blinkLoop, 1000);
                }
            };
            blinkLoop();
        }

        // --- æƒ…ç·’æ§åˆ¶ (ç•¥ï¼Œä¿æŒä¸è®Š) ---
        const VALID_EMOTIONS = ['neutral', 'happy', 'angry', 'sad', 'relaxed', 'surprised'];
        function setEmotion(emotionName) {
            if (!currentVrm) return;
            if (emotionName === 'joy') emotionName = 'happy';
            if (emotionName === 'sorrow') emotionName = 'sad';
            if (emotionName === 'fun') emotionName = 'relaxed';
            if (!VALID_EMOTIONS.includes(emotionName)) emotionName = 'neutral';
            
            updateDebugDisplay(emotionName, null);
            VALID_EMOTIONS.forEach(emo => currentVrm.expressionManager.setValue(emo, 0));
            if (emotionName !== 'neutral') currentVrm.expressionManager.setValue(emotionName, 0.8);
        }

        window.actionActive = false;
        function triggerAction(actionName, duration) {
            if (!currentVrm || actionName === 'none') return;
            updateDebugDisplay(null, `${actionName}`);
            let shapeName = actionName === 'blink_left' ? 'blinkLeft' : (actionName === 'blink_right' ? 'blinkRight' : 'blink');
            window.actionActive = true;
            currentVrm.expressionManager.setValue(shapeName, 1.0);
            setTimeout(() => {
                currentVrm.expressionManager.setValue(shapeName, 0);
                window.actionActive = false;
                updateDebugDisplay(null, 'Done');
            }, duration);
        }

        function updateDebugDisplay(emo, act) {
            const debugDiv = document.getElementById('emotion-debug');
            if(emo) debugDiv.innerHTML = debugDiv.innerHTML.replace(/æƒ…ç·’: .*/, `æƒ…ç·’: ${emo}`);
            if(act) debugDiv.innerHTML = debugDiv.innerHTML.replace(/å‹•ä½œ: .*/, `å‹•ä½œ: ${act}`);
        }

        function addMessage(text, type) {
            const chatDisplay = document.getElementById('chat-display');
            const div = document.createElement('div');
            div.className = `message message-${type}`;
            
            let safeText = text.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\n/g, "<br>");
            safeText = safeText.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank">$1</a>');
            
            div.innerHTML = safeText;
            chatDisplay.appendChild(div);
            chatDisplay.scrollTo({ top: chatDisplay.scrollHeight, behavior: 'smooth' });
            return div;
        }

        function removeMessage(el) { if(el && el.parentNode) el.parentNode.removeChild(el); }

        // --- API é€£ç·šæª¢æŸ¥ (ç•¥) ---
        const statusDot = document.getElementById('status-dot');
        const statusMsg = document.getElementById('status-msg');
        const userInput = document.getElementById('user-input');
        const sendBtn = document.getElementById('send-btn');
        const muteBtn = document.getElementById('mute-btn');

        async function testApiConnection() {
            if (isPreviewEnv) {
                statusDot.classList.add('status-preview');
                statusMsg.innerText = "é è¦½æ¨¡å¼";
                userInput.disabled = false; sendBtn.disabled = false;
                return;
            }
            statusMsg.innerText = "é€£ç·šæ¸¬è©¦...";
            statusDot.className = 'status-dot'; 
            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: "Test" }] }] })
                });
                if (response.ok) {
                    statusDot.classList.add('status-connected');
                    statusMsg.innerText = "ç³»çµ±é€£ç·šæ­£å¸¸";
                    userInput.disabled = false; 
                    sendBtn.disabled = false;
                } else {
                    throw new Error("API Response Error");
                }
            } catch (e) {
                statusDot.classList.add('status-error');
                statusMsg.innerText = "é€£ç·šå¤±æ•—";
                console.error("API Test Failed:", e);
                addMessage(`é€£ç·šæ¸¬è©¦å¤±æ•—: ${e.message}`, 'system');
            }
        }

        // --- è¨Šæ¯ç™¼é€èˆ‡è™•ç† ---
        muteBtn.addEventListener('click', () => {
            isMuted = !isMuted;
            muteBtn.classList.toggle('muted', isMuted);
            muteBtn.innerText = isMuted ? 'ğŸ”‡' : 'ğŸ”Š';
            if(isMuted) { window.speechSynthesis.cancel(); isSpeaking = false; }
        });

        async function handleSendMessage() {
            // *** å–šé†’ï¼šä½¿ç”¨è€…ç™¼é€è¨Šæ¯ï¼Œåœæ­¢é–’ç½®å‹•ä½œ ***
            stopIdleAnimation();
            lastInteractionTime = Date.now();

            const text = userInput.value.trim();
            if (!text) return;

            if (!isMuted) {
                window.speechSynthesis.cancel();
                const silent = new SpeechSynthesisUtterance(" ");
                silent.volume = 0; silent.rate = 10;
                window.speechSynthesis.speak(silent);
            }

            userInput.value = ''; userInput.disabled = true; sendBtn.disabled = true;
            addMessage(text, 'user');
            
            if (isPreviewEnv) {
                addMessage("ã€æç¤ºã€‘é è¦½æ¨¡å¼ç„¡æ³•é€£æ¥ AIï¼Œè«‹éƒ¨ç½²è‡³ Vercelã€‚", 'system');
                userInput.disabled = false; sendBtn.disabled = false; userInput.focus();
                return;
            }

            const loadingMsg = addMessage("Thinking...", 'system');
            chatHistory.push({ role: "user", parts: [{ text: text }] });

            let finalSystemInstruction = "";
            if (externalSystemPrompt) finalSystemInstruction += externalSystemPrompt;
            else finalSystemInstruction += `You are a virtual AI character. Reply in Traditional Chinese. Output JSON: { "text": "response", "emotion": "neutral", "action": "none" }`;

            if (externalKnowledge) {
                finalSystemInstruction += "\n\n====== KNOWLEDGE BASE ======\n" + externalKnowledge + "\n============================\n";
            }
            finalSystemInstruction += `\nã€INSTRUCTIONSã€‘\n1. Use Knowledge Base first.\n2. Use Google Search if needed.\n3. Return JSON format.`;

            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: chatHistory,
                        systemInstruction: { parts: [{ text: finalSystemInstruction }] },
                    })
                });

                if (!response.ok) throw new Error("Server Error");

                const data = await response.json();
                removeMessage(loadingMsg);
                
                let rawText = data.candidates?.[0]?.content?.parts?.[0]?.text || "Error";
                let result = { text: rawText, emotion: 'neutral' };

                try {
                    const jsonMatch = rawText.match(/\{[\s\S]*\}/);
                    if (jsonMatch) result = JSON.parse(jsonMatch[0]);
                } catch(e) {}

                if(!result.text) result.text = rawText;

                if(result.emotion === 'neutral') {
                    if(result.text.match(/(é–‹å¿ƒ|å¿«æ¨‚|happy)/)) result.emotion = 'happy';
                    if(result.text.match(/(é›£é|æ‚²å‚·|sad)/)) result.emotion = 'sad';
                }

                chatHistory.push({ role: "model", parts: [{ text: result.text }] });
                addMessage(result.text, 'ai');
                setEmotion(result.emotion);
                if(result.action) triggerAction(result.action, 2000);
                speak(result.text);

            } catch (error) {
                console.error(error);
                removeMessage(loadingMsg);
                addMessage(`éŒ¯èª¤: ${error.message}`, 'system');
            } finally {
                userInput.disabled = false; sendBtn.disabled = false; userInput.focus();
                // å†æ¬¡æ›´æ–°äº’å‹•æ™‚é–“ï¼Œç¢ºä¿å°è©±çµæŸå¾Œ 10 ç§’æ‰é–‹å§‹é–’ç½®
                lastInteractionTime = Date.now();
            }
        }

        function speak(text) {
            if (isMuted) return;
            const cleanText = text.replace(/\[.*?\]\(.*?\)/g, '').replace(/[^\u4e00-\u9fa5a-zA-Z0-9,.\?]/g, '');
            if(!cleanText) return;
            
            window.speechSynthesis.cancel();
            const u = new SpeechSynthesisUtterance(cleanText);
            u.lang = 'zh-TW';
            u.rate = 1.0; 
            u.pitch = 1.0;
            u.onstart = () => isSpeaking = true;
            u.onend = () => { isSpeaking = false; if(currentVrm) currentVrm.expressionManager.setValue('aa', 0); };
            window.speechSynthesis.speak(u);
        }

        sendBtn.addEventListener('click', handleSendMessage);
        userInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') handleSendMessage(); });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            updateCameraPosition();
        });
    </script>
</body>
</html>
