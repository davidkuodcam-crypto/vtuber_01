<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="utf-8">
<title>AI VTuber - Golden New Year (Fixed Lighting)</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<!-- å¼•å…¥ FontAwesome ç”¨æ–¼ UI åœ–ç¤º -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
    /* å…¨åŸŸæ¨£å¼è¨­å®š */
    * { box-sizing: border-box; }

    body {
        margin: 0; padding: 0; overflow: hidden;
        background: linear-gradient(135deg, #fff8e1 0%, #ffecb3 50%, #ffe0b2 100%);
        font-family: "Noto Sans TC", sans-serif;
        overscroll-behavior: none; 
        width: 100vw; height: 100vh; height: 100dvh; 
    }
    
    /* è®€å–ç•«é¢ */
    #loading-screen {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(255, 255, 255, 0.95);
        display: flex; flex-direction: column; justify-content: center; align-items: center;
        z-index: 999; transition: opacity 0.5s ease;
    }
    
    .loader {
        border: 4px solid #fff3e0; border-top: 4px solid #d32f2f;
        border-radius: 50%; width: 40px; height: 40px;
        animation: spin 1s linear infinite; margin-bottom: 15px;
    }
    .loading-text { color: #d32f2f; font-size: 1rem; font-weight: bold; margin-bottom: 20px; }

    #start-btn {
        padding: 12px 30px; font-size: 1.1rem;
        background: linear-gradient(to right, #d32f2f, #f44336);
        color: #ffd700; border: 2px solid #ffd700; border-radius: 50px;
        cursor: pointer; display: none;
        box-shadow: 0 4px 15px rgba(211, 47, 47, 0.3); font-weight: bold;
    }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    /* ç‹€æ…‹é¢æ¿ */
    #file-status {
        position: absolute; top: 15px; left: 15px; padding: 10px;
        background: rgba(255, 255, 255, 0.8); backdrop-filter: blur(4px);
        border-radius: 12px; font-size: 12px; color: #5d4037;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1); z-index: 100; border: 1px solid #ffcc80;
    }
    .file-status-item { margin-bottom: 4px; display: flex; align-items: center; }
    .icon-ok { color: #2e7d32; margin-right: 6px; font-weight: bold; }
    .icon-fail { color: #c62828; margin-right: 6px; font-weight: bold; }
    .icon-loading { color: #ef6c00; margin-right: 6px; animation: pulse 1s infinite; }

    #api-status {
        position: absolute; top: 15px; right: 15px; padding: 6px 12px;
        background: rgba(255, 255, 255, 0.8); backdrop-filter: blur(4px);
        border-radius: 20px; font-size: 12px; font-weight: bold; color: #333;
        display: flex; align-items: center; z-index: 100; border: 1px solid #ffcc80;
    }
    .status-dot { width: 8px; height: 8px; border-radius: 50%; background-color: #ccc; margin-right: 6px; }
    .status-connected { background-color: #2ecc71; box-shadow: 0 0 5px #2ecc71; }
    .status-error { background-color: #e74c3c; box-shadow: 0 0 5px #e74c3c; }
    .status-preview { background-color: #9b59b6; box-shadow: 0 0 5px #9b59b6; }

    /* å…‰æºæ§åˆ¶é¢æ¿å·²ç§»é™¤ */

    /* å°è©±ä»‹é¢ */
    #chat-container {
        position: absolute; bottom: 30px; bottom: calc(30px + env(safe-area-inset-bottom));
        left: 50%; transform: translateX(-50%); width: 90%; max-width: 600px;
        display: flex; flex-direction: column; gap: 8px; z-index: 100;
    }
    #chat-display {
        background: rgba(255, 255, 255, 0.4); padding: 12px; border-radius: 16px;
        height: 140px; overflow-y: auto; backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 215, 0, 0.6); display: flex; flex-direction: column; gap: 8px;
    }
    .message { padding: 8px 12px; border-radius: 12px; max-width: 85%; font-size: 14px; line-height: 1.5; word-wrap: break-word; }
    .message-user { align-self: flex-end; background-color: rgba(30, 136, 229, 0.9); color: #fff; }
    .message-ai { align-self: flex-start; background-color: rgba(255, 255, 255, 0.9); color: #333; border: 1px solid #ffd700; }
    .message-system { align-self: center; background: transparent; color: #e65100; font-size: 12px; font-style: italic; text-align: center;}

    #input-area { display: flex; gap: 8px; align-items: center; width: 100%; position: relative; }
    .input-wrapper { position: relative; flex: 1; display: flex; }
    #user-input {
        width: 100%; padding: 12px 16px; border-radius: 25px; border: 1px solid rgba(255, 215, 0, 0.6);
        background: rgba(255, 255, 255, 0.95); font-size: 16px; outline: none;
    }
    #voice-overlay {
        position: absolute; bottom: 1px; left: 20px; right: 20px; height: 3px;
        background-color: #3b82f6; z-index: 3; display: none; animation: voice-pulse 1.5s infinite;
    }
    @keyframes voice-pulse { 0%, 100% { opacity: 0.5; transform: scaleX(0.95); } 50% { opacity: 1; transform: scaleX(1); } }

    .control-btn {
        width: 44px; height: 44px; border-radius: 50%; border: 1px solid #ffd700;
        background: rgba(255, 255, 255, 0.95); font-size: 20px; cursor: pointer;
        display: flex; justify-content: center; align-items: center; color: #d32f2f;
        box-shadow: 0 4px 10px rgba(0,0,0,0.1); transition: all 0.2s;
    }
    .control-btn:active { transform: scale(0.9); }
    .active { background-color: #ef4444 !important; color: white !important; animation: mic-ring 2s infinite; }
    @keyframes mic-ring { 0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); } 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); } }

    #send-btn {
        padding: 0 20px; height: 44px; border-radius: 22px; border: none;
        background: linear-gradient(to right, #1976d2, #1565c0); color: #fff; font-weight: bold; cursor: pointer;
    }
    #send-btn:disabled { opacity: 0.5; cursor: not-allowed; }
</style>

<script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
<script type="importmap">
{
    "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/",
        "@pixiv/three-vrm": "https://unpkg.com/@pixiv/three-vrm@3.0.0/lib/three-vrm.module.js",
        "@pixiv/three-vrm-animation": "https://unpkg.com/@pixiv/three-vrm-animation@3.0.0/lib/three-vrm-animation.module.js"
    }
}
</script>
</head>

<body>
    <div id="loading-screen">
        <div class="loader" id="main-loader"></div>
        <div class="loading-text" id="status-text">è¼‰å…¥è§’è‰²èˆ‡å…‰ç…§ç³»çµ±...</div>
        <button id="start-btn">é–‹å§‹å°è©±é«”é©—</button>
    </div>

    <div id="file-status"></div>
    <div id="api-status">
        <div class="status-dot" id="status-dot"></div>
        <span id="status-msg">é€£ç·šä¸­...</span>
    </div>
    
    <div id="tts-debug" style="display:none;"></div>
    
    <div id="chat-container">
        <div id="chat-display"></div>
        <div id="input-area">
            <button id="dance-btn" class="control-btn" title="ç†±èˆçµ„æ›²">ğŸ’ƒ</button>
            <button id="mute-btn" class="control-btn" title="éœéŸ³åˆ‡æ›">ğŸ”Š</button>
            <div class="input-wrapper">
                <input type="text" id="user-input" placeholder="è«‹è¼¸å…¥è¨Šæ¯..." disabled>
                <div id="voice-overlay"></div>
            </div>
            <button id="mic-btn" class="control-btn" title="èªéŸ³è¼¸å…¥"><i class="fa-solid fa-microphone"></i></button>
            <button id="send-btn" disabled>ç™¼é€</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';
        import { VRMAnimationLoaderPlugin, createVRMAnimationClip } from '@pixiv/three-vrm-animation';

        const API_URL = "/api/chat"; 
        const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
        const isAndroid = /Android/i.test(navigator.userAgent);
        const isPreviewEnv = window.location.protocol === 'blob:' || window.location.protocol === 'file:';

        // --- é…ç½®å€åŸŸ ---
        const VRM_MODELS = [
            'https://davidkuodcam-crypto.github.io/VTuber/AvatarSample_C.vrm', // 0: C
            'https://davidkuodcam-crypto.github.io/VTuber/AvatarSample_W.vrm', // 1: W
            'https://davidkuodcam-crypto.github.io/VTuber/David_Kuo_03.vrm'    // 2: David
        ];
        const IDLE_ANIM_URLS = [
            'https://davidkuodcam-crypto.github.io/VTuber/Taunt_with_Skin.vrma',
            'https://davidkuodcam-crypto.github.io/VTuber/Idle_01.vrma',
            'https://davidkuodcam-crypto.github.io/VTuber/Idle.vrma'
        ];
        const TALK_ANIM_URLS = [
            'https://davidkuodcam-crypto.github.io/VTuber/Breathing_Idle.vrma',
            'https://davidkuodcam-crypto.github.io/VTuber/Talking_01.vrma',
            'https://davidkuodcam-crypto.github.io/VTuber/Breathing_Idle.vrma'
        ];
        const DANCE_URLS = [
            'https://davidkuodcam-crypto.github.io/VTuber/Breakdance_Freeze_Var_3.vrma',
            'https://davidkuodcam-crypto.github.io/VTuber/Flair.vrma',
            'https://davidkuodcam-crypto.github.io/VTuber/Hip_Hop_Dancing.vrma',
            'https://davidkuodcam-crypto.github.io/VTuber/Breakdance_Freeze_Var_1.vrma'
        ];
        const BGM_URL = 'https://davidkuodcam-crypto.github.io/VTuber/Happy_new_year.mp3';

        // --- ç‹€æ…‹ç®¡ç† ---
        let currentVrms = [], mixers = [], idleActions = [], talkActions = [], danceActionsMap = [];
        let isDancing = false, isSpeaking = false, isMuted = false, danceRound = 1, danceStepIndex = 0;
        let vrmDanceSequences = [];
        let currentStepActions = []; 
        let stepFinishedCount = 0; 
        let externalSystemPrompt = "", externalKnowledge = "", openingRemark = "";
        let currentActiveActionForListener = null;

        const bgm = new Audio(BGM_URL);
        bgm.loop = true; bgm.volume = 0.5;

        // --- å ´æ™¯è¨­å®š ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xfff8e1);
        scene.fog = new THREE.Fog(0xfff8e1, 5, 15);
        scene.add(new THREE.GridHelper(20, 20, 0xd32f2f, 0xffcc80)); 

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        
        // â­â­â­ 1. æ¢å¾©æœ€åŸå§‹æ¸²æŸ“è¨­å®š (ç„¡ Tone Mapping) â­â­â­
        renderer.outputEncoding = THREE.sRGBEncoding; 
        renderer.toneMapping = THREE.NoToneMapping; 
        
        document.body.appendChild(renderer.domElement);

        const camera = new THREE.PerspectiveCamera(30.0, window.innerWidth / window.innerHeight, 0.1, 20.0);
        camera.position.set(0, 1.4, 3.5);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 1.2, 0); controls.update();

        // â­â­â­ 2. å…‰æºé…ç½® (å·²é–å®šæ•¸å€¼) â­â­â­
        
        // ä¸»å…‰ï¼šæ·±ç´…è‰² (ä¾æˆªåœ–), å¼·åº¦ 2.0 (ä¾ç’°å¢ƒäº®åº¦æ¨ä¼°), Xä½ç½® -1.2
        const directionalLight = new THREE.DirectionalLight(0xcc0000, 2.0);
        directionalLight.position.set(-1.2, 2.0, 1.0).normalize();
        scene.add(directionalLight);
        
        // è£œå…‰ï¼šè†šè‰²/ç±³è‰² (ä¾æˆªåœ–), å¼·åº¦ 2.7 (ä¾æˆªåœ–), Xä½ç½® 0.0
        const fillLight = new THREE.DirectionalLight(0xffeebb, 2.7);
        fillLight.position.set(0.0, 1.0, 1.0).normalize();
        scene.add(fillLight);
        
        // ç’°å¢ƒå…‰ï¼šç™½è‰² (ä¾æˆªåœ–), å¼·åº¦ 1.4 (ä¾æˆªåœ–)
        const ambientLight = new THREE.AmbientLight(0xffffff, 1.4);
        scene.add(ambientLight);

        // --- ç²’å­ç‰¹æ•ˆ ---
        let particlesMesh;
        const particlesCount = 300; 
        function createFestiveParticles() {
            const geometry = new THREE.BufferGeometry();
            const posArray = new Float32Array(particlesCount * 3);
            const colorArray = new Float32Array(particlesCount * 3);
            for(let i = 0; i < particlesCount * 3; i+=3) {
                posArray[i] = (Math.random() - 0.5) * 15; 
                posArray[i+1] = Math.random() * 10;       
                posArray[i+2] = (Math.random() - 0.5) * 15; 
                if (Math.random() > 0.5) {
                    colorArray[i] = 0.9; colorArray[i+1] = 0.1; colorArray[i+2] = 0.1; 
                } else {
                    colorArray[i] = 0.8; colorArray[i+1] = 0.6; colorArray[i+2] = 0.0; 
                }
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));
            const material = new THREE.PointsMaterial({ size: 0.15, vertexColors: true, transparent: true, opacity: 0.8 });
            particlesMesh = new THREE.Points(geometry, material);
            scene.add(particlesMesh);
        }

        // --- æª”æ¡ˆæƒæ ---
        async function loadExternalData() {
            const statusDiv = document.getElementById('file-status');
            let pStatus = '<span class="icon-loading">â—</span> Prompt';
            let kbStatus = '<span class="icon-loading">â—</span> KB';
            const renderStatus = () => statusDiv.innerHTML = `<div class="file-status-item">${pStatus}</div><div class="file-status-item">${kbStatus}</div>`;
            renderStatus();

            try {
                const res = await fetch(`./Prompt.txt?t=${Date.now()}`);
                if (res.ok) { externalSystemPrompt = await res.text(); pStatus = '<span class="icon-ok">âœ“</span> Prompt OK'; }
                else pStatus = '<span class="icon-fail">âœ—</span> Prompt Err';
            } catch(e) { pStatus = '<span class="icon-fail">âœ—</span> Prompt Err'; }
            renderStatus();

            let kbIndex = 1, loadedKB = 0;
            while (true) {
                try {
                    const res = await fetch(`./KnowledgeBase${String(kbIndex).padStart(2,'0')}.txt?t=${Date.now()}`);
                    if (!res.ok) break;
                    const text = await res.text();
                    if (kbIndex === 1) openingRemark = text;
                    externalKnowledge += `\n\nã€KB${kbIndex}ã€‘\n${text}`;
                    loadedKB++; kbIndex++;
                } catch(e) { break; }
            }
            kbStatus = loadedKB > 0 ? `<span class="icon-ok">âœ“</span> KB x${loadedKB}` : '<span class="icon-fail">âœ—</span> No KB';
            renderStatus();
        }

        const loader = new GLTFLoader();
        loader.register((parser) => new VRMLoaderPlugin(parser));
        loader.register((parser) => new VRMAnimationLoaderPlugin(parser));

        async function initSystem() {
            createFestiveParticles();
            // initLightControls(); // å·²ç§»é™¤
            await loadExternalData();
            const modelPromises = VRM_MODELS.map((url, index) => {
                return new Promise((resolve) => {
                    loader.load(url, (gltf) => {
                        const vrm = gltf.userData.vrm;
                        VRMUtils.rotateVRM0(vrm);
                        scene.add(vrm.scene);
                        if (index === 0) vrm.scene.position.set(-0.35, 0, 0.2);
                        if (index === 1) vrm.scene.position.set(0.35, 0, -0.8);
                        if (index === 2) {
                            vrm.scene.position.set(0, 0, -1.3);
                        }
                        if (!vrm.userData) vrm.userData = {};
                        const mixer = new THREE.AnimationMixer(vrm.scene);
                        vrm.userData.mixer = mixer; mixers.push(mixer);
                        currentVrms[index] = vrm; startBlinking(vrm); resolve();
                    }, undefined, (e) => { console.error("Model Error:", e); resolve(); });
                });
            });

            await Promise.all(modelPromises);
            await loadActions();
            
            document.getElementById('status-text').innerText = "ç³»çµ±å°±ç·’ï¼";
            document.getElementById('main-loader').style.display = "none";
            const startBtn = document.getElementById('start-btn');
            startBtn.style.display = "block";
            startBtn.onclick = handleStart;
        }

        async function loadActions() {
            // åŠ å…¥ç°¡æ˜“éŒ¯èª¤è™•ç†ï¼Œé˜²æ­¢å‹•ç•«è¼‰å…¥å¤±æ•—å°è‡´ç¨‹å¼å¡ä½ (è§£æ±º T-pose æ½›åœ¨å•é¡Œ)
            for (let i = 0; i < currentVrms.length; i++) {
                if (!currentVrms[i]) continue;
                try {
                    const idleG = await new Promise((r, j) => loader.load(IDLE_ANIM_URLS[i], r, undefined, j));
                    const idleAction = currentVrms[i].userData.mixer.clipAction(createVRMAnimationClip(idleG.userData.vrmAnimations[0], currentVrms[i]));
                    idleActions[i] = idleAction; idleAction.play();
                } catch(e) { console.warn("Idle Anim Error:", e); }

                try {
                    const talkG = await new Promise((r, j) => loader.load(TALK_ANIM_URLS[i], r, undefined, j));
                    talkActions[i] = currentVrms[i].userData.mixer.clipAction(createVRMAnimationClip(talkG.userData.vrmAnimations[0], currentVrms[i]));
                } catch(e) { console.warn("Talk Anim Error:", e); }
            }
            
            try {
                const danceClips = await Promise.all(DANCE_URLS.map(url => new Promise((r, j) => loader.load(url, g => r(g.userData.vrmAnimations[0]), undefined, j))));
                danceClips.forEach(clip => {
                    danceActionsMap.push(currentVrms.map(vrm => vrm ? vrm.userData.mixer.clipAction(createVRMAnimationClip(clip, vrm)) : null));
                });
            } catch(e) { console.warn("Dance Anim Error:", e); }
        }

        function handleStart() {
            document.getElementById('loading-screen').style.display = 'none';
            document.getElementById('user-input').disabled = false;
            document.getElementById('send-btn').disabled = false;
            
            testApiConnection();
            if (openingRemark) { addMessage(openingRemark, "ai"); speak(openingRemark); }
        }

        // --- è·³èˆç³»çµ± ---
        function startDance() {
            if (isDancing) return; isDancing = true;
            document.getElementById('dance-btn').classList.add('active');
            
            if (window.speechSynthesis) window.speechSynthesis.cancel(); isSpeaking = false;
            idleActions.forEach(a => a && a.fadeOut(0.5));
            if (talkActions) talkActions.forEach(a => a && a.fadeOut(0.5));

            bgm.muted = isMuted; bgm.currentTime = 0; bgm.play().catch(e=>{});
            
            danceRound = 1; danceStepIndex = 0;
            updateSequences(); 
            playDanceStep();
        }

        function updateSequences() {
            vrmDanceSequences = [];
            const base = [0, 1, 2, 3];
            if (danceRound % 2 !== 0) {
                const seq = [...base];
                currentVrms.forEach(() => vrmDanceSequences.push([...seq]));
            } else {
                currentVrms.forEach(() => {
                    const randomSeq = [...base].sort(() => Math.random() - 0.5);
                    vrmDanceSequences.push(randomSeq);
                });
            }
            const mode = danceRound % 2 !== 0 ? "é½Šèˆ (Sync)" : "Battle (Random)";
            addMessage(`Round ${danceRound}: ${mode}`, "system");
        }

        function playDanceStep() {
            if (!isDancing) return;

            currentStepActions.forEach(a => a && a.fadeOut(0.5));
            currentStepActions = [];
            stepFinishedCount = 0;

            currentVrms.forEach((vrm, i) => {
                if(!vrm) { stepFinishedCount++; return; }
                const moveIdx = vrmDanceSequences[i][danceStepIndex];
                const action = danceActionsMap[moveIdx] ? danceActionsMap[moveIdx][i] : null;
                
                if (action) {
                    currentStepActions.push(action);
                    const onFinish = (e) => {
                        if (e.action === action) {
                            vrm.userData.mixer.removeEventListener('finished', onFinish);
                            checkStepComplete(); 
                        }
                    };
                    vrm.userData.mixer.addEventListener('finished', onFinish);

                    action.reset();
                    action.setLoop(THREE.LoopOnce);
                    action.clampWhenFinished = true;
                    action.fadeIn(0.5);
                    action.play();
                } else {
                    checkStepComplete();
                }
            });
        }

        function checkStepComplete() {
            stepFinishedCount++;
            if (stepFinishedCount >= currentVrms.length) {
                danceStepIndex++;
                if (danceStepIndex >= 4) { 
                    danceStepIndex = 0; 
                    danceRound++; 
                    updateSequences(); 
                }
                playDanceStep();
            }
        }

        function stopDance() {
            isDancing = false; document.getElementById('dance-btn').classList.remove('active');
            bgm.pause(); bgm.currentTime = 0;
            
            danceActionsMap.forEach(grp => grp.forEach(a => a && a.fadeOut(0.5)));
            currentStepActions = [];
            
            idleActions.forEach(a => a && a.reset().fadeIn(0.5).play());
            
            setTimeout(() => {
                camera.position.set(0, 1.4, 3.5);
                controls.target.set(0, 1.2, 0);
            }, 500);
        }

        // --- äº’å‹•èˆ‡æ ¡æ­£ ---
        let recognition = null;
        if ('webkitSpeechRecognition' in window) {
            recognition = new webkitSpeechRecognition();
            recognition.lang = 'zh-TW'; recognition.interimResults = true;
            recognition.onstart = () => { bgm.pause(); document.getElementById('mic-btn').classList.add('active'); };
            recognition.onend = () => document.getElementById('mic-btn').classList.remove('active');
            recognition.onresult = (e) => {
                const text = Array.from(e.results).map(r => r[0].transcript).join('');
                document.getElementById('user-input').value = text;
                if (e.results[0].isFinal) handleSend();
            };
        }

        async function handleSend() {
            if (isDancing) stopDance(); 
            if (window.speechSynthesis) window.speechSynthesis.cancel();

            const input = document.getElementById('user-input');
            const text = input.value.trim();
            if (!text) return;
            addMessage(text, 'user'); input.value = '';
            
            const sysPrompt = externalSystemPrompt || "Reply in JSON: { \"text\": \"...\", \"corrected_text\": \"...\" }";
            const loading = addMessage("Thinking...", "system");
            
            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ role: "user", parts: [{ text: text }] }],
                        systemInstruction: { parts: [{ text: sysPrompt + "\n\nKNOWLEDGE:\n" + externalKnowledge }] }
                    })
                });
                const data = await response.json();
                const raw = data.candidates[0].content.parts[0].text;
                const result = JSON.parse(raw.match(/{[\s\S]*}/)[0]);
                
                displayChat.removeChild(loading);
                
                const lastUserMsg = document.querySelector('.message-user:last-child');
                if (lastUserMsg && result.corrected_text) lastUserMsg.innerHTML = result.corrected_text;
                
                addMessage(result.text, "ai"); speak(result.text);
                if (text.includes("è·³èˆ") || result.text.includes("è·³èˆ")) startDance();
            } catch(e) { 
                displayChat.removeChild(loading); 
                addMessage("ç³»çµ±ç¹å¿™ (ç„¡å¾Œç«¯é€£ç·š)ã€‚", "system"); 
            }
        }

        async function speak(text) {
            if (isMuted || !window.speechSynthesis) return;
            window.speechSynthesis.cancel();
            const u = new SpeechSynthesisUtterance(text);
            u.lang = 'zh-TW';
            u.onstart = () => { isSpeaking = true; if (!isDancing) talkActions.forEach(a => a && a.reset().fadeIn(0.2).play()); };
            u.onend = () => { isSpeaking = false; talkActions.forEach(a => a && a.fadeOut(0.5)); };
            window.speechSynthesis.speak(u);
        }

        const displayChat = document.getElementById('chat-display');
        function addMessage(text, type) {
            const div = document.createElement('div'); div.className = `message message-${type}`;
            div.innerText = text; displayChat.appendChild(div);
            displayChat.scrollTop = displayChat.scrollHeight; return div;
        }

        function startBlinking(vrm) {
            const loop = () => { setTimeout(() => { vrm.expressionManager.setValue('blink', 1);
                setTimeout(() => { vrm.expressionManager.setValue('blink', 0); loop(); }, 150);
            }, 2000 + Math.random() * 3000); }; loop();
        }
        
        function logTTS(msg) { console.log(msg); } 

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();
            
            if (particlesMesh) {
                particlesMesh.rotation.y += 0.001;
                const pos = particlesMesh.geometry.attributes.position.array;
                for(let i=1; i<particlesCount*3; i+=3) {
                    pos[i] -= 0.015;
                    if(pos[i] < 0) pos[i] = 10;
                }
                particlesMesh.geometry.attributes.position.needsUpdate = true;
            }

            mixers.forEach(m => m.update(delta));
            currentVrms.forEach(v => {
                if (!v) return; v.update(delta);
                if (isDancing) {
                    camera.position.lerp(new THREE.Vector3(0, 0.8, 8.5), 0.02);
                    controls.target.lerp(new THREE.Vector3(0, 0.8, 0), 0.02);
                }
                if (isSpeaking) v.expressionManager.setValue('aa', (Math.sin(time * 18) + 1) / 2 * 0.7);
                else v.expressionManager.setValue('aa', 0);
            });
            renderer.render(scene, camera);
        }

        document.getElementById('send-btn').onclick = handleSend;
        document.getElementById('dance-btn').onclick = () => isDancing ? stopDance() : startDance();
        document.getElementById('mic-btn').onclick = () => recognition.start();
        document.getElementById('mute-btn').onclick = function() {
            isMuted = !isMuted; this.innerText = isMuted ? 'ğŸ”‡' : 'ğŸ”Š';
            bgm.muted = isMuted; 
            if (isMuted) window.speechSynthesis.cancel();
        };

        document.getElementById('user-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleSend();
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight);
        });

        async function testApiConnection() {
            const statusDot = document.getElementById('status-dot');
            const statusMsg = document.getElementById('status-msg');
            
            if (isPreviewEnv) {
                statusDot.classList.add('status-preview');
                statusMsg.innerText = "é è¦½æ¨¡å¼";
                return;
            }

            statusMsg.innerText = "é€£ç·šæ¸¬è©¦...";
            statusDot.className = 'status-dot'; 

            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 5000); 

            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: "Test" }] }] }),
                    signal: controller.signal
                });
                clearTimeout(timeoutId);

                if (response.ok) {
                    statusDot.classList.add('status-connected');
                    statusMsg.innerText = "ç³»çµ±é€£ç·šæ­£å¸¸";
                } else {
                    throw new Error("API status not 200");
                }
            } catch (e) {
                statusDot.classList.add('status-error');
                statusMsg.innerText = "å°šæœªé€£ç·šAIå¹³å°"; 
                console.warn("API Test Failed (Expected if no server):", e);
            }
        }

        initSystem(); animate();
    </script>
</body>
</html>
