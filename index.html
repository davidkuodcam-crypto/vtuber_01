<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="utf-8">
<title>AI VTuber - David Kuo & New Year Group</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<!-- å¼•å…¥ FontAwesome ç”¨æ–¼éº¥å…‹é¢¨åœ–ç¤º -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
    /* å…¨åŸŸè¨­å®š */
    * { box-sizing: border-box; }

    body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        /* é è¨­èƒŒæ™¯ï¼šæ–°å¹´é‡‘è‰²æ¼¸å±¤ */
        background: linear-gradient(135deg, #fff8e1 0%, #ffecb3 50%, #ffe0b2 100%);
        font-family: "Noto Sans TC", sans-serif;
        overscroll-behavior: none; 
        width: 100vw;
        height: 100vh;
        height: 100dvh; 
        transition: background 1s ease;
    }

    /* è®€å–ç•«é¢ */
    #loading-screen {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(255, 255, 255, 0.95);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 999;
        transition: opacity 0.5s ease;
    }
    
    .loader {
        border: 4px solid #fff3e0;
        border-top: 4px solid #d32f2f;
        border-radius: 50%;
        width: 40px; height: 40px;
        animation: spin 1s linear infinite;
        margin-bottom: 15px;
    }

    .loading-text { color: #d32f2f; font-size: 1rem; font-weight: bold; margin-bottom: 20px; }

    #start-btn {
        padding: 12px 30px;
        font-size: 1.1rem;
        background: linear-gradient(to right, #d32f2f, #f44336);
        color: #ffd700;
        border: 2px solid #ffd700;
        border-radius: 50px;
        cursor: pointer;
        display: none;
        box-shadow: 0 4px 15px rgba(211, 47, 47, 0.3);
        transition: transform 0.2s, background 0.2s;
        font-weight: bold;
        text-shadow: 0 1px 2px rgba(0,0,0,0.2);
        touch-action: manipulation; 
        -webkit-tap-highlight-color: transparent;
        user-select: none;
    }
    #start-btn:active { transform: scale(0.95); background: #b71c1c; }

    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    /* èƒŒæ™¯ Iframe (æ–‡è—»å®˜ç¶²) */
    #website-iframe {
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        border: none;
        z-index: 0; /* åœ¨ Canvas ä¸‹å±¤ */
        display: none; /* é è¨­éš±è— */
        background: white;
    }

    /* Canvas æ¨£å¼èª¿æ•´ */
    canvas {
        position: absolute;
        top: 0; left: 0;
        z-index: 1; /* åœ¨ Iframe ä¸Šå±¤ */
        transition: opacity 0.5s;
    }

    /* â­â­â­ è§’è‰² Hitbox (éš±å½¢è§¸æ§å€) â­â­â­ */
    #character-hitbox {
        position: absolute;
        z-index: 10; /* æ¯” Canvas é«˜ï¼Œç¢ºä¿èƒ½æ¥æ”¶é»æ“Š */
        border: none; 
        cursor: grab; /* é¡¯ç¤ºæ‰‹æŒ */
        display: none; /* é è¨­éš±è—ï¼Œå–®äººæ¨¡å¼é–‹å•Ÿ */
        touch-action: none; /* é˜²æ­¢æ‰‹æ©Ÿæ»‘å‹•é é¢ */
    }
    #character-hitbox:active {
        cursor: grabbing; /* æŠ“å–ä¸­ */
    }

    /* â­â­â­ å–®äººæ¨¡å¼å°è©±æ°£æ³¡ â­â­â­ */
    #solo-bubble {
        position: absolute;
        background: rgba(255, 255, 255, 0.95);
        color: #333;
        padding: 15px 20px;
        border-radius: 20px;
        border-bottom-left-radius: 2px; /* åƒæ°£æ³¡çš„å°–è§’ */
        max-width: 280px;
        box-shadow: 0 4px 15px rgba(0,0,0,0.15);
        font-size: 15px;
        line-height: 1.5;
        z-index: 20;
        display: none; /* é è¨­éš±è— */
        pointer-events: none; /* é»æ“Šç©¿é€ï¼Œä¸å½±éŸ¿æ‹–æ›³ */
        transition: opacity 0.3s;
        border: 1px solid #ddd;
    }

    /* API ç‹€æ…‹ */
    #api-status {
        position: absolute;
        top: 15px; right: 15px;
        padding: 6px 12px;
        background: rgba(255, 255, 255, 0.8);
        backdrop-filter: blur(4px);
        border-radius: 20px;
        font-size: 12px;
        font-weight: bold;
        color: #333;
        display: flex; align-items: center;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        z-index: 100;
        transition: all 0.3s;
        border: 1px solid #ffcc80;
        pointer-events: none; /* é¿å…é®æ“‹ */
    }
    .status-dot { width: 8px; height: 8px; border-radius: 50%; background-color: #ccc; margin-right: 6px; }
    .status-connected { background-color: #2ecc71; box-shadow: 0 0 5px #2ecc71; }
    .status-error { background-color: #e74c3c; box-shadow: 0 0 5px #e74c3c; }
    .status-preview { background-color: #f39c12; box-shadow: 0 0 5px #f39c12; }

    /* æª”æ¡ˆè®€å–ç‹€æ…‹ */
    #file-status {
        position: absolute;
        top: 15px; left: 15px;
        padding: 10px;
        background: rgba(255, 255, 255, 0.8);
        backdrop-filter: blur(4px);
        border-radius: 12px;
        font-size: 12px;
        color: #5d4037;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        z-index: 100;
        max-width: 180px;
        transition: opacity 0.5s;
        pointer-events: none;
        border: 1px solid #ffcc80;
    }
    .file-status-item { 
        margin-bottom: 4px; 
        display: flex; 
        align-items: center; 
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    .icon-ok { color: #2e7d32; margin-right: 6px; font-weight: bold; }
    .icon-fail { color: #c62828; margin-right: 6px; font-weight: bold; }
    .icon-loading { color: #ef6c00; margin-right: 6px; animation: pulse 1s infinite; }
    
    #tts-debug {
        position: absolute; top: 120px; left: 10px;
        background: rgba(0, 0, 0, 0.85); color: #00ff00;
        font-family: "Courier New", monospace; font-size: 11px;
        padding: 10px; border-radius: 8px; width: 280px; max-height: 200px;
        overflow-y: auto; z-index: 9999; pointer-events: none; display: none;
        border: 2px solid #00ff00; line-height: 1.4; white-space: pre-wrap;
    }

    #browser-warning {
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        background: rgba(255, 235, 59, 0.95); color: #b71c1c; padding: 20px;
        border-radius: 15px; text-align: center; z-index: 10000; display: none;
        box-shadow: 0 10px 25px rgba(0,0,0,0.3); border: 2px solid #f57f17; width: 80%; max-width: 400px;
    }
    #browser-warning button {
        margin-top: 15px; padding: 8px 16px; background: #b71c1c; color: white;
        border: none; border-radius: 20px; cursor: pointer;
    }

    @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }

    /* å°è©±ä»‹é¢ */
    #chat-container {
        position: absolute; 
        bottom: 30px; bottom: calc(30px + env(safe-area-inset-bottom));
        left: 50%; transform: translateX(-50%);
        width: 90%; max-width: 600px;
        display: flex; flex-direction: column; gap: 8px;
        z-index: 100; transition: bottom 0.3s;
        pointer-events: none; /* è®“é»æ“Šç©¿é€åˆ° iframe (éƒ¨åˆ†å€åŸŸ) */
    }
    /* è®“èŠå¤©ä»‹é¢çš„äº’å‹•å…ƒç´ æ¢å¾©å¯é»æ“Š */
    #chat-display, #input-area { pointer-events: auto; }

    @media (max-width: 600px) {
        #chat-container { width: 95%; bottom: 40px; bottom: calc(40px + env(safe-area-inset-bottom)); }
        #file-status, #api-status { top: 10px; transform: scale(0.9); transform-origin: top; }
        #file-status { left: 10px; }
        #api-status { right: 10px; }
        
        /* â­â­â­ æ‰‹æ©Ÿç‰ˆå¼·åˆ¶éš±è—å–®äººæ¨¡å¼åˆ‡æ›æŒ‰éˆ• (åªä¿ç•™é›™äººæ¨¡å¼) â­â­â­ */
        #switch-mode-btn { display: none !important; }
    }

    #chat-display {
        background: rgba(255, 255, 255, 0.4);
        padding: 12px; border-radius: 16px; height: 140px; overflow-y: auto;
        backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 215, 0, 0.6);
        display: flex; flex-direction: column; gap: 8px;
        scrollbar-width: none; -ms-overflow-style: none;
    }
    #chat-display::-webkit-scrollbar { display: none; }

    .message {
        padding: 8px 12px; border-radius: 12px; max-width: 85%;
        word-wrap: break-word; font-size: 14px; line-height: 1.5;
        color: white; text-shadow: 0 1px 1px rgba(0,0,0,0.1);
    }
    .message-user { align-self: flex-end; background-color: rgba(30, 136, 229, 0.9); border-bottom-right-radius: 2px; color: #fff; }
    .message-ai { align-self: flex-start; background-color: rgba(255, 255, 255, 0.9); border-bottom-left-radius: 2px; color: #333; text-shadow: none; border: 1px solid #ffd700; }
    .message-system { align-self: center; background: transparent; color: #e65100; font-size: 12px; font-style: italic; text-shadow: none; text-align: center;}
    .message a { color: #1e88e5; text-decoration: none; border-bottom: 1px dotted #1e88e5; }
    .message-user a { color: #bbdefb; }

    #input-area { 
        display: flex; gap: 8px; align-items: center; width: 100%; position: relative;
    }
    
    .input-wrapper { position: relative; flex: 1; display: flex; min-width: 0; }
    #user-input {
        width: 100%; padding: 12px 16px; border-radius: 25px; 
        border: 1px solid rgba(255, 215, 0, 0.6); outline: none;
        background: rgba(255, 255, 255, 0.95); font-size: 16px; 
        box-shadow: 0 4px 15px rgba(0,0,0,0.1); color: #5d4037; z-index: 2;
    }
    #user-input::placeholder { color: #999; }

    #voice-overlay {
        position: absolute; bottom: 1px; left: 20px; right: 20px; height: 3px;
        background-color: #3b82f6; z-index: 3; display: none; pointer-events: none;
        animation: voice-pulse 1.5s infinite;
    }
    @keyframes voice-pulse { 0%, 100% { opacity: 0.5; transform: scaleX(0.95); } 50% { opacity: 1; transform: scaleX(1); } }

    #send-btn {
        padding: 0 20px; height: 44px; border-radius: 22px; border: none;
        background: linear-gradient(to right, #1976d2, #1565c0); color: #fff;
        font-weight: bold; cursor: pointer; transition: background 0.2s;
        box-shadow: 0 4px 10px rgba(21, 101, 192, 0.3); flex-shrink: 0;
        border: 1px solid #90caf9; touch-action: manipulation; 
        -webkit-tap-highlight-color: transparent; user-select: none;
    }
    #send-btn:active { transform: scale(0.95); }
    #send-btn:disabled { background: #bdbdbd; box-shadow: none; cursor: not-allowed; border: none; color: #fff;}

    .control-btn {
        width: 44px; height: 44px; border-radius: 50%; border: none;
        background: rgba(255, 255, 255, 0.95); font-size: 20px; cursor: pointer;
        display: flex; justify-content: center; align-items: center;
        box-shadow: 0 4px 10px rgba(0,0,0,0.1); flex-shrink: 0;
        border: 1px solid #ffd700; color: #d32f2f; transition: all 0.2s;
        touch-action: manipulation; -webkit-tap-highlight-color: transparent; user-select: none;
    }
    .control-btn:active { transform: scale(0.95); }
    #mute-btn.muted { background: #e74c3c; color: white; border: none; }
    
    #dance-btn { color: #e91e63; } 
    #dance-btn.active { background: #e91e63; color: white; box-shadow: inset 0 0 10px rgba(0,0,0,0.3); border-color: #c2185b; }

    /* â­â­â­ æ¨¡å¼åˆ‡æ›æŒ‰éˆ•æ¨£å¼ â­â­â­ */
    #switch-mode-btn { color: #673ab7; border-color: #9575cd; }
    /* å–®äººæ¨¡å¼æ¨£å¼ */
    #switch-mode-btn.solo-active { 
        background: #ffffff; color: #673ab7; 
        border: 2px solid #673ab7;
        box-shadow: 0 0 10px rgba(103, 58, 183, 0.2);
    }
    /* é›™äººæ¨¡å¼æ¨£å¼ */
    #switch-mode-btn.group-active { 
        background: #673ab7; color: #ffffff; 
        border: 2px solid #512da8;
    }

    .recording-pulse {
        animation: pulse-ring 2s infinite; background-color: #ef4444 !important;
        color: white !important; border: none !important;
    }
    @keyframes pulse-ring {
        0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
        70% { transform: scale(1.1); box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
        100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
    }
    
    #emotion-debug {
        position: absolute; top: 60px; right: 15px; font-size: 10px; color: #5d4037;
        background: rgba(255,255,255,0.7); padding: 4px 8px; border-radius: 6px;
        pointer-events: none; backdrop-filter: blur(2px); text-align: right;
        line-height: 1.3; opacity: 0.6; 
    }
</style>

<script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
<script type="importmap">
{
    "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/",
        "@pixiv/three-vrm": "https://unpkg.com/@pixiv/three-vrm@3.0.0/lib/three-vrm.module.js",
        "@pixiv/three-vrm-animation": "https://unpkg.com/@pixiv/three-vrm-animation@3.0.0/lib/three-vrm-animation.module.js"
    }
}
</script>
</head>

<body>

    <!-- â­â­â­ èƒŒæ™¯ Iframe â­â­â­ -->
    <iframe id="website-iframe" src="https://a001.wzu.edu.tw/"></iframe>
    
    <!-- â­â­â­ è§’è‰² Hitbox (ç”¨æ–¼å–®äººæ¨¡å¼æ‹–æ›³) â­â­â­ -->
    <div id="character-hitbox"></div>

    <!-- â­â­â­ å–®äººæ¨¡å¼æ°£æ³¡ â­â­â­ -->
    <div id="solo-bubble">ä½ å¥½ï¼æˆ‘æ˜¯éƒ­å¤§ç¶­è€å¸«ï¼Œæ­¡è¿ä¾†åˆ°æ–‡è—»å¤–èªå¤§å­¸ã€‚</div>

    <div id="loading-screen">
        <div class="loader" id="loader"></div>
        <div class="loading-text" id="status-text">åˆå§‹åŒ–ç³»çµ±ä¸­...</div>
        <button id="start-btn">é–‹å§‹å°è©±</button>
    </div>

    <div id="browser-warning">
        <h3>âš ï¸ ç€è¦½å™¨åŠŸèƒ½é™åˆ¶</h3>
        <p>æª¢æ¸¬åˆ°ç›®å‰çš„ç€è¦½å™¨ä¸æ”¯æ´èªéŸ³åŠŸèƒ½ã€‚</p>
        <button onclick="document.getElementById('browser-warning').style.display='none'">æˆ‘çŸ¥é“äº†</button>
    </div>

    <div id="file-status">
        <div class="file-status-item"><span class="icon-loading">â—</span> ç³»çµ±å•Ÿå‹•...</div>
    </div>

    <div id="api-status">
        <div class="status-dot" id="status-dot"></div>
        <span id="status-msg">é€£ç·šä¸­...</span>
    </div>
    
    <div id="tts-debug">TTS ç³»çµ±è¨ºæ–·ä¸­...</div>
    
    <div id="emotion-debug">
        æƒ…ç·’: Neutral<br>
        å‹•ä½œ: None
    </div>

    <div id="chat-container">
        <div id="chat-display"></div>
        <div id="input-area">
            <!-- â­â­â­ ä¿®æ”¹ï¼šåˆä½µç‚ºå–®ä¸€æŒ‰éˆ•ï¼Œç¯€çœç©ºé–“ â­â­â­ -->
            <button id="switch-mode-btn" class="control-btn mode-btn group-active" title="åˆ‡æ›ç©ºé–“"><i class="fa-solid fa-user-group"></i></button>
            
            <button id="dance-btn" class="control-btn" title="ç†±èˆçµ„æ›²">ğŸ’ƒ</button>
            <button id="mute-btn" class="control-btn" title="åˆ‡æ›è²éŸ³">ğŸ”Š</button>
            
            <div class="input-wrapper">
                <input type="text" id="user-input" placeholder="è«‹è¼¸å…¥è¨Šæ¯..." disabled>
                <div id="voice-overlay"></div>
            </div>

            <button id="mic-btn" class="control-btn" title="èªéŸ³è¼¸å…¥"><i class="fa-solid fa-microphone"></i></button>
            <button id="send-btn" disabled>ç™¼é€</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';
        import { VRMAnimationLoaderPlugin, createVRMAnimationClip } from '@pixiv/three-vrm-animation';

        const API_URL = "/api/chat"; 
        const isAndroid = /Android/i.test(navigator.userAgent);
        const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
        const isLineApp = /Line/i.test(navigator.userAgent);
        const isFbApp = /FBAN|FBAV/i.test(navigator.userAgent);

        window.shouldResumeMic = false;
        const ttsDebug = document.getElementById('tts-debug');
        
        if (isAndroid) {
            ttsDebug.innerHTML = "=== Android Debug Log (Init) ===<br>";
        }

        function logTTS(msg) {
            if (!isAndroid && !isIOS) return;
            const time = new Date().toTimeString().split(' ')[0];
            ttsDebug.innerHTML = `[${time}] ${msg}<br>` + ttsDebug.innerHTML;
        }

        // --- TTS Check ---
        let ttsSupported = true;
        if (!window.speechSynthesis) {
            if (window.webkitSpeechSynthesis) {
                window.speechSynthesis = window.webkitSpeechSynthesis;
                window.SpeechSynthesisUtterance = window.webkitSpeechSynthesisUtterance;
            } else {
                ttsSupported = false;
            }
        }
        if (!ttsSupported && isAndroid) {
            document.getElementById('browser-warning').style.display = 'block';
        }

        // --- Model & Animation Config ---
        const VRM_MODELS = [
            'https://davidkuodcam-crypto.github.io/VTuber/AvatarSample_C.vrm', // C
            'https://davidkuodcam-crypto.github.io/VTuber/AvatarSample_W.vrm'  // W
        ];
        
        // â­â­â­ ä¿®æ”¹ï¼šæ›´æ–°ç‚º David_Kuo_03.vrm â­â­â­
        const SOLO_VRM_URL = 'https://davidkuodcam-crypto.github.io/VTuber/David_Kuo_03.vrm';
        const SOLO_ANIM_URL = 'https://davidkuodcam-crypto.github.io/VTuber/Idle.vrma';

        let currentVrms = []; 
        let mixers = [];      
        let isDancing = false;
        
        let isSoloMode = false;
        let soloVrm = null;
        let soloMixer = null;
        let soloAction = null;
        
        // â­â­â­ éš¨æ©Ÿé–’ç½®å‹•ä½œè®Šæ•¸ â­â­â­
        let idleRandomTimer = 0;
        let nextIdleChangeTime = 0;
        let currentRandomEmotion = 'neutral';
        let lookAtTarget = new THREE.Vector3(0, 1.5, 2.0); // çœ¼ç›çœ‹çš„åœ°æ–¹
        let headSwayTime = 0;

        // â­â­â­ æ‹–æ›³è®Šæ•¸ (ä½¿ç”¨ Raycasting) â­â­â­
        const hitbox = document.getElementById('character-hitbox');
        const soloBubble = document.getElementById('solo-bubble');
        let isDraggingSolo = false;
        let dragOffset = new THREE.Vector3(); // æ»‘é¼ é»æ“Šé»èˆ‡è§’è‰²ä¸­å¿ƒçš„åå·®å€¼
        
        const DANCE_URLS = [
            'https://davidkuodcam-crypto.github.io/VTuber/Breakdance_Freeze_Var_3.vrma', 
            'https://davidkuodcam-crypto.github.io/VTuber/Flair.vrma',                   
            'https://davidkuodcam-crypto.github.io/VTuber/Hip_Hop_Dancing.vrma',         
            'https://davidkuodcam-crypto.github.io/VTuber/Breakdance_Freeze_Var_1.vrma'  
        ];
        
        const TALK_ANIMATION_C_URL = 'https://davidkuodcam-crypto.github.io/VTuber/Breathing_Idle.vrma';
        const TALK_ANIMATION_W_URL = 'https://davidkuodcam-crypto.github.io/VTuber/Talking_01.vrma';
        const IDLE_ANIMATION_C_URL = 'https://davidkuodcam-crypto.github.io/VTuber/Taunt_with_Skin.vrma'; 
        const IDLE_ANIMATION_W_URL = 'https://davidkuodcam-crypto.github.io/VTuber/Idle_01.vrma'; 

        let talkingActionC = null; 
        let talkingActionW = null; 
        let idleActionC = null;    
        let idleActionW = null;    

        const BGM_URL = 'https://davidkuodcam-crypto.github.io/VTuber/Happy_new_year.mp3';
        const bgm = new Audio(BGM_URL);
        bgm.loop = true; 
        bgm.volume = 0.5; 
        
        let danceActionsMap = []; 
        let danceRound = 1;        
        let danceStepIndex = 0;    
        let vrmDanceSequences = []; 
        let currentDanceQueue = [];
        let currentPlayingDanceIndex = -1;
        let currentActiveActionForListener = null;

        let chatHistory = [];
        let isSpeaking = false;
        let currentEmotion = 'neutral';
        let isMuted = false;
        let preferredVoice = null;
        
        function updateVoices() {
            if (!window.speechSynthesis) return;
            const voices = window.speechSynthesis.getVoices();
            if (voices.length > 0) {
                preferredVoice = voices.find(v => (v.lang === 'zh-TW' || v.lang.includes('zh-TW')) && v.localService) ||
                                 voices.find(v => v.lang === 'zh-TW' || v.lang.includes('zh-TW')) ||
                                 voices.find(v => v.lang.includes('zh'));
            }
        }
        if (window.speechSynthesis) {
            window.speechSynthesis.onvoiceschanged = updateVoices;
            updateVoices(); 
        }

        let externalSystemPrompt = ""; 
        let externalKnowledge = "";
        let openingRemark = ""; 

        const isPreviewEnv = window.location.protocol === 'blob:' || window.location.protocol === 'file:';

        // --- Scene Init ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xfff8e1); // é è¨­èƒŒæ™¯è‰²
        scene.fog = new THREE.Fog(0xfff8e1, 5, 15);
        
        const gridHelper = new THREE.GridHelper(20, 20, 0xd32f2f, 0xffcc80);
        scene.add(gridHelper); 

        const camera = new THREE.PerspectiveCamera(30.0, window.innerWidth / window.innerHeight, 0.1, 20.0);
        
        function updateCameraPosition() {
            const aspect = window.innerWidth / window.innerHeight;
            
            // â­â­â­ ç¨ç«‹æ¨¡å¼ä¸‹çš„ç›¸æ©Ÿé‚è¼¯ â­â­â­
            if (isSoloMode) {
                if (aspect < 0.8) { // Mobile
                    camera.position.set(0.0, 1.1, 3.5); // ç¨å¾®è²¼è¿‘ï¼Œå› ç‚ºèƒŒæ™¯å¯äº’å‹•
                    controls.target.set(0.0, 1.1, 0.0);
                } else { // Desktop
                    camera.position.set(0.0, 1.3, 2.8);
                    controls.target.set(0.0, 1.2, 0.0);
                }
            } else {
                // åŸæœ¬ç¾¤é«”æ¨¡å¼
                if (aspect < 0.8) {
                    if (isDancing) {
                        camera.position.set(0.0, 0.8, 8.5); 
                        controls.target.set(0.0, 0.8, 0.0);
                    } else {
                        camera.position.set(0.0, 1.35, 2.5); 
                        controls.target.set(0.0, 1.35, -0.2);
                    }
                } else {
                    if (isDancing) {
                         camera.position.set(0.0, 1.0, 6.0);
                         controls.target.set(0.0, 0.8, 0.0);
                    } else {
                         camera.position.set(0.0, 1.4, 3.5);
                         controls.target.set(0.0, 1.3, -0.2);
                    }
                }
            }
            camera.updateProjectionMatrix();
            controls.update();
        }

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
        renderer.outputColorSpace = THREE.SRGBColorSpace; 
        
        document.body.appendChild(renderer.domElement);

        // --- Lights Setup ---
        const directionalLight = new THREE.DirectionalLight(0xfff0e6, 1.5); 
        directionalLight.position.set(-1.0, 2.0, 1.0).normalize();
        scene.add(directionalLight);
        
        const fillLight = new THREE.DirectionalLight(0xffe0b2, 0.6);
        fillLight.position.set(1.0, 1.0, 1.0).normalize();
        scene.add(fillLight);
        
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);

        // --- Particles ---
        let particlesMesh;
        const particlesCount = 300;
        function createFestiveParticles() {
            const geometry = new THREE.BufferGeometry();
            const posArray = new Float32Array(particlesCount * 3);
            const colorArray = new Float32Array(particlesCount * 3);
            
            for(let i = 0; i < particlesCount * 3; i+=3) {
                posArray[i] = (Math.random() - 0.5) * 15;
                posArray[i+1] = Math.random() * 10;
                posArray[i+2] = (Math.random() - 0.5) * 15;

                if (Math.random() > 0.5) {
                    colorArray[i] = 0.9; colorArray[i+1] = 0.1; colorArray[i+2] = 0.1;
                } else {
                    colorArray[i] = 0.8; colorArray[i+1] = 0.6; colorArray[i+2] = 0.0;
                }
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.15, vertexColors: true, transparent: true, opacity: 0.8
            });
            particlesMesh = new THREE.Points(geometry, material);
            scene.add(particlesMesh);
        }
        createFestiveParticles();

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enablePan = true; 
        controls.screenSpacePanning = true; 
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 1.0; 
        controls.maxDistance = 8.0;

        updateCameraPosition(); 

        // --- File Loading (æ¢å¾©è¼‰å…¥åŠŸèƒ½) ---
        async function loadExternalData() {
            const statusText = document.getElementById('status-text');
            const fileStatusDiv = document.getElementById('file-status');
            
            let promptStatusHTML = '<span class="icon-loading">â—</span> Prompt';
            let kbStatusHTML = '<span class="icon-loading">â—</span> KB';
            const renderStatus = () => {
                fileStatusDiv.innerHTML = `<div class="file-status-item">${promptStatusHTML}</div><div class="file-status-item">${kbStatusHTML}</div>`;
            };
            renderStatus();
            try {
                statusText.innerText = "è®€å–è§’è‰²è¨­å®š...";
                const res = await fetch(`./Prompt.txt?t=${Date.now()}`);
                if (res.ok) {
                    externalSystemPrompt = await res.text();
                    promptStatusHTML = '<span class="icon-ok">âœ“</span> Prompt OK';
                } else {
                    promptStatusHTML = '<span class="icon-fail">âœ—</span> Prompt Def';
                }
            } catch (e) {
                promptStatusHTML = '<span class="icon-fail">âœ—</span> Prompt Err';
            }
            renderStatus();

            statusText.innerText = "è®€å–é›²ç«¯çŸ¥è­˜åº«...";
            let fileIndex = 1; let keepLoading = true; let loadedCount = 0;
            while (keepLoading) {
                const fileNameRoot = `KnowledgeBase${String(fileIndex).padStart(2, '0')}.txt`;
                const fileNameFolder = `KnowledgeBase/KnowledgeBase${String(fileIndex).padStart(2, '0')}.txt`;
                kbStatusHTML = `<span class="icon-loading">â—</span> æƒæ KB${String(fileIndex).padStart(2,'0')}...`;
                renderStatus();
                try {
                    let res = await fetch(`./${fileNameFolder}?t=${Date.now()}`);
                    let usedPath = fileNameFolder;
                    if (!res.ok) {
                         try {
                             const resRoot = await fetch(`./${fileNameRoot}?t=${Date.now()}`);
                             if (resRoot.ok) { res = resRoot; usedPath = fileNameRoot; }
                         } catch(e) {}
                    }
                    if (res.ok) {
                        const text = await res.text();
                        if (text.trim().length > 0) {
                            if (fileIndex === 1) openingRemark = text;
                            externalKnowledge += `\n\nã€KB: ${usedPath}ã€‘\n${text}`;
                            loadedCount++; fileIndex++;
                        } else { fileIndex++; }
                    } else { keepLoading = false; }
                } catch (e) { keepLoading = false; }
            }
            if (loadedCount > 0) kbStatusHTML = `<span class="icon-ok">âœ“</span> KB x${loadedCount}`;
            else kbStatusHTML = `<span class="icon-fail">âœ—</span> No KB`;
            renderStatus();
            statusText.innerText = "ç³»çµ±å°±ç·’ï¼";
        }

        // --- VRM Loading ---
        const loader = new GLTFLoader();
        loader.crossOrigin = 'anonymous';
        loader.register((parser) => new VRMLoaderPlugin(parser));
        loader.register((parser) => new VRMAnimationLoaderPlugin(parser));

        const loadPromises = VRM_MODELS.map((url, index) => {
            return new Promise((resolve) => {
                loader.load(url, (gltf) => {
                    const vrm = gltf.userData.vrm;
                    VRMUtils.rotateVRM0(vrm);
                    scene.add(vrm.scene);
                    
                    if (index === 0) vrm.scene.position.set(-0.3, 0.0, 0.2);
                    else vrm.scene.position.set(0.3, 0.0, -0.8);

                    const leftUpperArm = vrm.humanoid.getNormalizedBoneNode('leftUpperArm');
                    const rightUpperArm = vrm.humanoid.getNormalizedBoneNode('rightUpperArm');
                    if (leftUpperArm) { leftUpperArm.rotation.z = -1.1; leftUpperArm.rotation.x = 0.15; }
                    if (rightUpperArm) { rightUpperArm.rotation.z = 1.1; rightUpperArm.rotation.x = 0.15; }

                    const mixer = new THREE.AnimationMixer(vrm.scene);
                    if (!vrm.userData) vrm.userData = {};
                    vrm.userData.mixer = mixer;
                    mixers.push(mixer); 
                    currentVrms[index] = vrm; 
                    startBlinking(vrm);
                    resolve();
                }, undefined, () => resolve());
            });
        });

        const loadSoloCharacter = new Promise((resolve) => {
            loader.load(SOLO_VRM_URL, (gltf) => {
                const vrm = gltf.userData.vrm;
                VRMUtils.rotateVRM0(vrm);
                scene.add(vrm.scene);
                vrm.scene.visible = false;
                vrm.scene.position.set(0, 0, 0); 
                
                // â­â­â­ ç¸®å°ä¸€é»æ¯”ä¾‹ (0.6) â­â­â­
                vrm.scene.scale.set(0.6, 0.6, 0.6);

                const leftUpperArm = vrm.humanoid.getNormalizedBoneNode('leftUpperArm');
                const rightUpperArm = vrm.humanoid.getNormalizedBoneNode('rightUpperArm');
                if (leftUpperArm) { leftUpperArm.rotation.z = -1.1; leftUpperArm.rotation.x = 0.15; }
                if (rightUpperArm) { rightUpperArm.rotation.z = 1.1; rightUpperArm.rotation.x = 0.15; }
                soloMixer = new THREE.AnimationMixer(vrm.scene);
                soloVrm = vrm;
                startBlinking(soloVrm);

                loader.load(SOLO_ANIM_URL, (animGltf) => {
                    const vrmAnimations = animGltf.userData.vrmAnimations;
                    if (vrmAnimations && vrmAnimations.length > 0) {
                        const clip = createVRMAnimationClip(vrmAnimations[0], soloVrm);
                        soloAction = soloMixer.clipAction(clip);
                        soloAction.loop = THREE.LoopRepeat;
                    }
                    resolve();
                });
            }, undefined, (e) => {
                console.error("Solo Load Error", e);
                resolve();
            });
        });

        function loadTalkAnimations() {
            const pC = new Promise((resolve) => {
                loader.load(TALK_ANIMATION_C_URL, (gltf) => {
                    const vrmAnimations = gltf.userData.vrmAnimations;
                    if (vrmAnimations && vrmAnimations.length > 0 && currentVrms[0]) {
                         const clip = createVRMAnimationClip(vrmAnimations[0], currentVrms[0]);
                         talkingActionC = currentVrms[0].userData.mixer.clipAction(clip);
                         talkingActionC.loop = THREE.LoopRepeat;
                    }
                    resolve();
                });
            });
            const pW = new Promise((resolve) => {
                loader.load(TALK_ANIMATION_W_URL, (gltf) => {
                    const vrmAnimations = gltf.userData.vrmAnimations;
                    if (vrmAnimations && vrmAnimations.length > 0 && currentVrms[1]) {
                         const clip = createVRMAnimationClip(vrmAnimations[0], currentVrms[1]);
                         talkingActionW = currentVrms[1].userData.mixer.clipAction(clip);
                         talkingActionW.loop = THREE.LoopRepeat;
                    }
                    resolve();
                });
            });
            return Promise.all([pC, pW]);
        }

        function loadIdleAnimations() {
            const pC = new Promise((resolve) => {
                loader.load(IDLE_ANIMATION_C_URL, (gltf) => {
                    const vrmAnimations = gltf.userData.vrmAnimations;
                    if (vrmAnimations && vrmAnimations.length > 0 && currentVrms[0]) {
                         const clip = createVRMAnimationClip(vrmAnimations[0], currentVrms[0]);
                         idleActionC = currentVrms[0].userData.mixer.clipAction(clip);
                         idleActionC.loop = THREE.LoopRepeat;
                         idleActionC.play();
                    }
                    resolve();
                });
            });
            const pW = new Promise((resolve) => {
                loader.load(IDLE_ANIMATION_W_URL, (gltf) => {
                    const vrmAnimations = gltf.userData.vrmAnimations;
                    if (vrmAnimations && vrmAnimations.length > 0 && currentVrms[1]) {
                         const clip = createVRMAnimationClip(vrmAnimations[0], currentVrms[1]);
                         idleActionW = currentVrms[1].userData.mixer.clipAction(clip);
                         idleActionW.loop = THREE.LoopRepeat;
                         idleActionW.play();
                    }
                    resolve();
                });
            });
            return Promise.all([pC, pW]);
        }

        Promise.all([...loadPromises, loadSoloCharacter, loadExternalData()]).then(() => {
            const handleStart = (e) => {
                const loadingScreen = document.getElementById('loading-screen');
                if (loadingScreen.style.opacity === '0') return; 
                loadingScreen.style.opacity = 0;
                loadingScreen.style.pointerEvents = 'none'; 
                setTimeout(() => loadingScreen.style.display = 'none', 500);
                updateVoices();
                const introText = openingRemark || "ï¼ˆæœªè®€å–åˆ° KnowledgeBase01.txtï¼Œè«‹æª¢æŸ¥æª”æ¡ˆï¼‰";
                speak(introText);
                addMessage(introText, 'ai');
                chatHistory.push({ role: "model", parts: [{ text: introText }] });
                testApiConnection();
            };

            Promise.all([loadTalkAnimations(), loadIdleAnimations()]).then(() => {
                const loaderEl = document.getElementById('loader');
                const statusText = document.getElementById('status-text');
                const startBtn = document.getElementById('start-btn');
                loaderEl.style.display = 'none';
                statusText.innerText = `æº–å‚™å®Œæˆ (${currentVrms.length} äºº)`;
                startBtn.style.display = 'block';
                updateCameraPosition();
                startBtn.addEventListener('click', handleStart);
                startBtn.addEventListener('touchend', (e) => { e.preventDefault(); handleStart(e); });
            });
        });

        // â­â­â­ éš¨æ©Ÿé–’ç½®è¡Œç‚º (David) â­â­â­
        function updateSoloRandomBehavior(deltaTime) {
            const head = soloVrm ? soloVrm.humanoid.getNormalizedBoneNode('head') : null;
            if (!head) return;

            // â­â­â­ æ‹–æ›³æ™‚ï¼Œå¼·åˆ¶è½‰å‘ç›¸æ©Ÿ â­â­â­
            if (isDraggingSolo && soloVrm) {
                const diffX = camera.position.x - soloVrm.scene.position.x;
                const diffY = camera.position.y - (soloVrm.scene.position.y + 1.45); 
                const diffZ = camera.position.z - soloVrm.scene.position.z;
                
                const targetYaw = Math.atan2(diffX, diffZ);
                const targetPitch = Math.atan2(diffY, Math.sqrt(diffX*diffX + diffZ*diffZ));
                
                head.rotation.y = THREE.MathUtils.lerp(head.rotation.y, targetYaw, 0.2);
                head.rotation.x = THREE.MathUtils.lerp(head.rotation.x, -targetPitch, 0.2);
                
                soloVrm.expressionManager.setValue('aa', THREE.MathUtils.lerp(soloVrm.expressionManager.getValue('aa'), 0, 0.2));
                return; 
            }

            if (isSpeaking) {
                soloVrm.expressionManager.setValue('happy', THREE.MathUtils.lerp(soloVrm.expressionManager.getValue('happy'), 0, 0.1));
                soloVrm.expressionManager.setValue('relaxed', THREE.MathUtils.lerp(soloVrm.expressionManager.getValue('relaxed'), 0, 0.1));
                head.rotation.y = THREE.MathUtils.lerp(head.rotation.y, 0, 0.05);
                head.rotation.x = THREE.MathUtils.lerp(head.rotation.x, 0, 0.05);
                return; 
            }

            idleRandomTimer += deltaTime;
            headSwayTime += deltaTime;

            // 1. è¡¨æƒ…éš¨æ©Ÿåˆ‡æ›
            if (idleRandomTimer > nextIdleChangeTime) {
                idleRandomTimer = 0;
                nextIdleChangeTime = Math.random() * 3 + 2; // 2~5ç§’åˆ‡æ›ä¸€æ¬¡
                const r = Math.random();
                if (r < 0.6) currentRandomEmotion = 'neutral';
                else if (r < 0.8) currentRandomEmotion = 'happy';
                else currentRandomEmotion = 'relaxed';
                
                // å¶çˆ¾éš¨æ©Ÿçœ‹ä¸åŒæ–¹å‘
                if (Math.random() < 0.4) {
                    lookAtTarget.x = (Math.random() - 0.5) * 2.0;
                    lookAtTarget.y = 1.5 + (Math.random() - 0.5) * 0.5;
                } else {
                    lookAtTarget.set(0, 1.4, 3.0); // çœ‹å‘å‰æ–¹ç›¸æ©Ÿ
                }
            }

            // å¹³æ»‘éæ¸¡è¡¨æƒ…
            const targetHappy = (currentRandomEmotion === 'happy') ? 0.3 : 0; 
            const targetRelaxed = (currentRandomEmotion === 'relaxed') ? 0.3 : 0;
            const currentHappy = soloVrm.expressionManager.getValue('happy');
            const currentRelaxed = soloVrm.expressionManager.getValue('relaxed');
            
            soloVrm.expressionManager.setValue('happy', THREE.MathUtils.lerp(currentHappy, targetHappy, 0.05));
            soloVrm.expressionManager.setValue('relaxed', THREE.MathUtils.lerp(currentRelaxed, targetRelaxed, 0.05));
            
            // ç¢ºä¿å˜´å·´é–‰åˆ
            soloVrm.expressionManager.setValue('aa', THREE.MathUtils.lerp(soloVrm.expressionManager.getValue('aa'), 0, 0.2));

            // 2. é ­éƒ¨å¾®å‹• (ä½¿ç”¨ Head Bone æ—‹è½‰)
            const swayX = Math.sin(headSwayTime * 0.5) * 0.03 + Math.sin(headSwayTime * 1.2) * 0.01;
            const swayY = Math.cos(headSwayTime * 0.3) * 0.03 + Math.sin(headSwayTime * 0.8) * 0.01;
            
            const targetLookRotX = -lookAtTarget.x * 0.1;
            const targetLookRotY = (lookAtTarget.y - 1.5) * 0.1;

            head.rotation.y = THREE.MathUtils.lerp(head.rotation.y, swayX + targetLookRotX, 0.05);
            head.rotation.x = THREE.MathUtils.lerp(head.rotation.x, swayY - targetLookRotY, 0.05);
        }

        // â­â­â­ æ›´æ–° Hitbox èˆ‡ æ°£æ³¡ä½ç½® â­â­â­
        function updateHitbox() {
            if (!isSoloMode || !soloVrm) {
                hitbox.style.display = 'none';
                soloBubble.style.display = 'none';
                return;
            }
            
            hitbox.style.display = 'block';
            
            const headNode = soloVrm.humanoid.getNormalizedBoneNode('head');
            const rootPos = soloVrm.scene.position.clone();
            const headPos = headNode ? headNode.getWorldPosition(new THREE.Vector3()) : rootPos.clone().add(new THREE.Vector3(0, 1.6, 0));
            headPos.y += 0.2;
            
            const headScreen = headPos.clone().project(camera);
            const rootScreen = rootPos.clone().project(camera);
            
            const x = (rootScreen.x * 0.5 + 0.5) * window.innerWidth;
            const yBottom = (-(rootScreen.y * 0.5) + 0.5) * window.innerHeight;
            const yTop = (-(headScreen.y * 0.5) + 0.5) * window.innerHeight;
            
            const dist = camera.position.distanceTo(rootPos);
            const width = (250 / dist); // èª¿æ•´å¯¬åº¦ä»¥åŒ¹é…ç¸®å°å¾Œçš„æ¨¡å‹
            
            // Hitbox ä½ç½®
            hitbox.style.left = `${x - width/2}px`;
            hitbox.style.top = `${yTop}px`;
            hitbox.style.width = `${width}px`;
            hitbox.style.height = `${yBottom - yTop}px`;
            
            // â­â­â­ æ°£æ³¡ä½ç½® (é ­éƒ¨å³ä¸Šæ–¹) â­â­â­
            if (soloBubble.innerText.trim() !== "") {
                soloBubble.style.display = 'block';
                soloBubble.style.left = `${x + width/2}px`; 
                // é™åˆ¶æ°£æ³¡ä¸è¶…å‡ºå³é‚Šç•Œ
                if (x + width/2 + 280 > window.innerWidth) {
                    soloBubble.style.left = `${x - width/2 - 290}px`; // æ”¹æ”¾å·¦é‚Š
                }
                soloBubble.style.top = `${yTop - 20}px`;
            } else {
                soloBubble.style.display = 'none';
            }
        }

        // â­â­â­ æ‹–æ›³äº‹ä»¶è™•ç† (Raycast Project 1:1) â­â­â­
        
        function getProjectedPosition(clientX, clientY, depthZ) {
            const vec = new THREE.Vector3();
            const pos = new THREE.Vector3();
            
            vec.set(
                (clientX / window.innerWidth) * 2 - 1,
                -(clientY / window.innerHeight) * 2 + 1,
                0.5
            );
            
            vec.unproject(camera);
            vec.sub(camera.position).normalize();
            
            const distance = (depthZ - camera.position.z) / vec.z;
            pos.copy(camera.position).add(vec.multiplyScalar(distance));
            
            return pos;
        }

        function onDragStart(clientX, clientY) {
            isDraggingSolo = true;
            if (soloVrm) {
                const mousePos3D = getProjectedPosition(clientX, clientY, soloVrm.scene.position.z);
                dragOffset.subVectors(soloVrm.scene.position, mousePos3D);
            }
        }

        function onDragMove(clientX, clientY) {
            if (!isDraggingSolo || !soloVrm) return;
            
            const mousePos3D = getProjectedPosition(clientX, clientY, soloVrm.scene.position.z);
            
            let newX = mousePos3D.x + dragOffset.x;
            let newY = mousePos3D.y + dragOffset.y;

            // Clamping
            const dist = Math.abs(camera.position.z - soloVrm.scene.position.z);
            const vFov = camera.fov * Math.PI / 180;
            const visibleHeight = 2 * Math.tan(vFov / 2) * dist;
            const visibleWidth = visibleHeight * camera.aspect;
            
            const cy = controls.target.y; 
            
            const marginX = visibleWidth * 0.4; 
            const marginTop = visibleHeight * 0.4; 
            const marginBottom = visibleHeight * 0.48;
            
            const minX = -marginX;
            const maxX = marginX;
            const minY = cy - marginBottom;
            const maxY = cy + marginTop;
            
            newX = Math.max(minX, Math.min(maxX, newX));
            newY = Math.max(minY, Math.min(maxY, newY));
            
            soloVrm.scene.position.x = newX;
            soloVrm.scene.position.y = newY;
        }

        function onDragEnd() {
            isDraggingSolo = false;
        }

        // æ»‘é¼ äº‹ä»¶
        hitbox.addEventListener('mousedown', (e) => { e.preventDefault(); onDragStart(e.clientX, e.clientY); });
        window.addEventListener('mousemove', (e) => { onDragMove(e.clientX, e.clientY); });
        window.addEventListener('mouseup', onDragEnd);

        // è§¸æ§äº‹ä»¶
        hitbox.addEventListener('touchstart', (e) => { 
            if(e.touches.length > 0) {
                e.preventDefault(); 
                onDragStart(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, {passive: false});
        
        window.addEventListener('touchmove', (e) => { 
            if(e.touches.length > 0) onDragMove(e.touches[0].clientX, e.touches[0].clientY);
        }, {passive: false});
        
        window.addEventListener('touchend', onDragEnd);


        // --- Animation Loop ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            const elapsedTime = clock.elapsedTime;

            if (isSoloMode) {
                // David ç©ºé–“å…‰ç·š
                ambientLight.intensity = THREE.MathUtils.lerp(ambientLight.intensity, 1.3, 0.05);
                directionalLight.intensity = THREE.MathUtils.lerp(directionalLight.intensity, 3.0, 0.05);
                const targetPos = new THREE.Vector3(0.5, 1.5, 2.0);
                directionalLight.position.lerp(targetPos, 0.05);
                fillLight.intensity = THREE.MathUtils.lerp(fillLight.intensity, 0.8, 0.05); 
                
                // â­â­â­ èº«é«”éš¨æ™‚è½‰å‘ç›¸æ©Ÿ (Yè»¸) â­â­â­
                if (soloVrm) {
                    const dx = camera.position.x - soloVrm.scene.position.x;
                    const dz = camera.position.z - soloVrm.scene.position.z;
                    const angle = Math.atan2(dx, dz);
                    soloVrm.scene.rotation.y = angle + Math.PI;
                }

                // â­ æ›´æ–° Hitbox â­
                updateHitbox();
            } else {
                // ç¾¤é«”æ¨¡å¼å…‰ç·š
                ambientLight.intensity = THREE.MathUtils.lerp(ambientLight.intensity, 0.8, 0.05); 
                directionalLight.intensity = THREE.MathUtils.lerp(directionalLight.intensity, 1.2, 0.05); 
                const targetPos = new THREE.Vector3(-1, 2, 1).normalize();
                directionalLight.position.lerp(targetPos, 0.05);
                fillLight.intensity = THREE.MathUtils.lerp(fillLight.intensity, 0.6, 0.05);
            }

            if (particlesMesh) {
                particlesMesh.visible = !isSoloMode;
                if (!isSoloMode) {
                    particlesMesh.rotation.y += 0.001;
                    const positions = particlesMesh.geometry.attributes.position.array;
                    for(let i = 1; i < particlesCount * 3; i+=3) {
                        positions[i] -= 0.015;
                        if (positions[i] < 0) positions[i] = 10;
                    }
                    particlesMesh.geometry.attributes.position.needsUpdate = true;
                }
            }

            if (!isSoloMode) {
                mixers.forEach(mixer => mixer.update(deltaTime));
                currentVrms.forEach((vrm, index) => {
                    if(!vrm) return;
                    vrm.update(deltaTime);
                    
                    if (!isDancing) {
                        const isC = (index === 0);
                        const isW = (index === 1);
                        let playBreathing = true;
                        if (isC && (idleActionC || (isSpeaking && talkingActionC))) playBreathing = false;
                        if (isW && (idleActionW || (isSpeaking && talkingActionW))) playBreathing = false;

                        if (playBreathing) {
                            const spine = vrm.humanoid.getNormalizedBoneNode('spine');
                            if (spine) {
                                spine.rotation.x = Math.sin(elapsedTime * 1.5) * 0.02;
                                spine.rotation.y = Math.sin(elapsedTime * 0.8) * 0.02;
                            }
                        }
                    }
                    
                    if (isSpeaking && !isMuted) {
                        const s = Math.sin(elapsedTime * 18); 
                        vrm.expressionManager.setValue('aa', (s + 1) / 2 * 0.6);
                    } else {
                        const currentVal = vrm.expressionManager.getValue('aa');
                        vrm.expressionManager.setValue('aa', THREE.MathUtils.lerp(currentVal, 0, 0.2));
                    }
                });
            }

            if (isSoloMode && soloVrm && soloMixer) {
                soloMixer.update(deltaTime);
                soloVrm.update(deltaTime);
                
                // â­â­â­ å‘¼å«é–’ç½®è¡Œç‚º (å«æ‹–æ›³æ³¨è¦–) â­â­â­
                updateSoloRandomBehavior(deltaTime);
                
                if (isSpeaking && !isMuted) {
                    const s = Math.sin(elapsedTime * 18);
                    soloVrm.expressionManager.setValue('aa', (s + 1) / 2 * 0.6);
                } 
            }

            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        function startBlinking(vrm) {
            if(!vrm) return;
            const blinkLoop = () => {
                if (!window.actionActive) {
                    setTimeout(() => {
                        vrm.expressionManager.setValue('blink', 1);
                        setTimeout(() => {
                            vrm.expressionManager.setValue('blink', 0);
                            blinkLoop();
                        }, 120);
                    }, Math.random() * 3000 + 1000); 
                } else { setTimeout(blinkLoop, 1000); }
            };
            blinkLoop();
        }

        // --- åˆ‡æ›æ¨¡å¼é‚è¼¯ ---
        const switchBtn = document.getElementById('switch-mode-btn');
        const danceBtn = document.getElementById('dance-btn');
        const iframe = document.getElementById('website-iframe');
        
        function toggleMode() {
            // åˆ‡æ›æ¨¡å¼ç‹€æ…‹
            isSoloMode = !isSoloMode;
            
            // åœæ­¢èªéŸ³
            if (window.speechSynthesis) window.speechSynthesis.cancel();
            isSpeaking = false;

            if (isSoloMode) {
                // --- é€²å…¥å–®äººæ¨¡å¼ ---
                if (isDancing) stopDance();
                
                // UI æ›´æ–°
                switchBtn.classList.remove('group-active');
                switchBtn.classList.add('solo-active');
                switchBtn.innerHTML = '<i class="fa-solid fa-user-group"></i>'; 
                
                danceBtn.style.opacity = '0.3';
                danceBtn.style.pointerEvents = 'none';

                // â­â­â­ å–®äººæ¨¡å¼ UI é‚è¼¯ â­â­â­
                // 1. éš±è—å°è©±åˆ—è¡¨ (æ­·å²è¨Šæ¯)
                document.getElementById('chat-display').style.display = 'none';
                
                // 2. ç¢ºä¿è¼¸å…¥æ¡†ã€éº¥å…‹é¢¨ã€ç™¼é€éˆ•é¡¯ç¤º
                document.querySelector('.input-wrapper').style.display = 'flex';
                document.getElementById('send-btn').style.display = 'block';
                if (recognition && !isAndroid && !isIOS) {
                    document.getElementById('mic-btn').style.display = 'flex';
                }

                // 3. é¡¯ç¤ºæ°£æ³¡ (å¦‚æœæœ‰çš„è©±)
                soloBubble.style.display = soloBubble.innerText ? 'block' : 'none';

                // æ¨¡å‹åˆ‡æ›
                currentVrms.forEach(vrm => { if(vrm) vrm.scene.visible = false; });
                if (soloVrm) soloVrm.scene.visible = true;

                // â­â­â­ ä¿®æ­£ï¼šèƒŒæ™¯è¨­å®šç‚º nullï¼Œè®“ Canvas é€æ˜ â­â­â­
                scene.background = null; 
                scene.fog.color.set(0xffffff); 
                renderer.setClearColor(0x000000, 0); 
                document.body.style.background = 'transparent';
                
                iframe.style.display = 'block';
                // â­é—œéµï¼šè®“ Canvas ä¸æ“‹æ»‘é¼ ï¼Œä»¥ä¾¿é»æ“Š Iframe
                renderer.domElement.style.pointerEvents = 'none';

                if (soloAction) { soloAction.reset(); soloAction.play(); }
            } else {
                // --- é€²å…¥ç¾¤é«”æ¨¡å¼ ---
                
                // UI æ›´æ–°
                switchBtn.classList.remove('solo-active');
                switchBtn.classList.add('group-active');
                switchBtn.innerHTML = '<i class="fa-solid fa-user"></i>'; 

                danceBtn.style.opacity = '1';
                danceBtn.style.pointerEvents = 'auto';

                // â­â­â­ ç¾¤é«”æ¨¡å¼ UI é‚è¼¯ â­â­â­
                // 1. é¡¯ç¤ºå°è©±åˆ—è¡¨
                document.getElementById('chat-display').style.display = 'flex';
                // 2. é¡¯ç¤ºè¼¸å…¥æ¡†
                document.querySelector('.input-wrapper').style.display = 'flex';
                document.getElementById('send-btn').style.display = ''; 
                if (recognition && !isAndroid && !isIOS) {
                    document.getElementById('mic-btn').style.display = 'flex';
                }
                
                // 3. éš±è—å–®äººæ°£æ³¡
                soloBubble.style.display = 'none';

                // æ¨¡å‹åˆ‡æ›
                currentVrms.forEach(vrm => { if(vrm) vrm.scene.visible = true; });
                if (soloVrm) soloVrm.scene.visible = false;

                // èƒŒæ™¯é‚„åŸ
                scene.background = new THREE.Color(0xfff8e1);
                renderer.setClearColor(0x000000, 0); 
                document.body.style.background = 'linear-gradient(135deg, #fff8e1 0%, #ffecb3 50%, #ffe0b2 100%)';
                scene.fog.color.set(0xfff8e1);
                
                iframe.style.display = 'none';
                // æ¢å¾© Canvas äº’å‹• (OrbitControls)
                renderer.domElement.style.pointerEvents = 'auto';

                if (soloAction) soloAction.stop();
                addMessage("å·²è¿”å›æ–°å¹´æœƒå ´ (AI Assistants)", "system");
            }
            updateCameraPosition();
        }
        
        // é è¨­æŒ‰éˆ•é¡¯ç¤ºã€Œå–®äººã€åœ–ç¤º (å› ç‚ºé è¨­æ˜¯ç¾¤é«”æ¨¡å¼)
        switchBtn.innerHTML = '<i class="fa-solid fa-user"></i>';
        switchBtn.addEventListener('click', toggleMode);
        switchBtn.addEventListener('touchend', (e) => { e.preventDefault(); toggleMode(); });

        // --- Dance Logic ---
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function generateSequences(round) {
            vrmDanceSequences = [];
            const baseSequence = [0, 1, 2, 3]; 
            currentVrms.forEach(() => {
                if (round % 2 !== 0) vrmDanceSequences.push([...baseSequence]);
                else vrmDanceSequences.push(shuffleArray([...baseSequence]));
            });
        }

        async function loadDanceAssets() {
            if (danceActionsMap.length > 0) return;
            if (currentVrms.length === 0) return;
            addMessage("æº–å‚™ç†±èˆè³‡æ–™ä¸­...", "system");
            const promises = DANCE_URLS.map(url => new Promise((resolve, reject) => {
                loader.load(url, (gltf) => {
                     const vrmAnimations = gltf.userData.vrmAnimations;
                     if (vrmAnimations && vrmAnimations.length > 0) resolve(vrmAnimations[0]);
                     else resolve(null);
                }, undefined, () => resolve(null));
            }));
            const animationClips = await Promise.all(promises);
            const validClips = animationClips.filter(c => c);
            if (validClips.length === 0) { addMessage("èˆè¹ˆè¼‰å…¥å¤±æ•—", "system"); return; }
            validClips.forEach(clipData => {
                const actionsForThisDance = [];
                currentVrms.forEach(vrm => {
                    if (!vrm || !vrm.userData || !vrm.userData.mixer) return;
                    const clip = createVRMAnimationClip(clipData, vrm);
                    const action = vrm.userData.mixer.clipAction(clip);
                    actionsForThisDance.push(action);
                });
                danceActionsMap.push(actionsForThisDance);
            });
            addMessage("èˆæ­¥è¼‰å…¥å®Œæˆï¼ŒLet's Dance!", "system");
        }

        async function loadAndPlayDance() {
            await loadDanceAssets();
            if (danceActionsMap.length > 0) startDance();
        }

        function startDance() {
            if (isSoloMode) return; // ç¨ç«‹æ¨¡å¼ä¸è·³èˆ
            
            isDancing = true;
            danceBtn.classList.add('active'); 
            if (isSpeaking) { window.speechSynthesis.cancel(); isSpeaking = false; }
            if (currentVrms[0]?.userData?.mixer) currentVrms[0].userData.mixer.removeEventListener('finished', onSequenceStepFinished);
            updateCameraPosition();
            if (idleActionC) idleActionC.fadeOut(0.5);
            if (idleActionW) idleActionW.fadeOut(0.5); 
            if (talkingActionC) talkingActionC.fadeOut(0.5);
            if (talkingActionW) talkingActionW.fadeOut(0.5);
            bgm.currentTime = 0; bgm.muted = isMuted;
            const playPromise = bgm.play();
            if (playPromise !== undefined) playPromise.catch(e=>{});
            danceRound = 1; danceStepIndex = 0;
            generateSequences(danceRound);
            playCurrentStep();
        }

        function playCurrentStep() {
            if (!isDancing) return;
            if (currentVrms[0]?.userData?.mixer) currentVrms[0].userData.mixer.removeEventListener('finished', onDanceFinished);
            currentVrms.forEach((vrm, vrmIndex) => {
                if (!vrm || !vrm.userData.mixer) return;
                const moveIndex = vrmDanceSequences[vrmIndex][danceStepIndex];
                const action = danceActionsMap[moveIndex]?.[vrmIndex];
                if (action) {
                    if (vrmIndex === 0) currentActiveActionForListener = action;
                    action.reset(); action.setLoop(THREE.LoopOnce); action.clampWhenFinished = true;
                    action.fadeIn(0.5); action.play();
                }
            });
            if (currentVrms[0]?.userData?.mixer) currentVrms[0].userData.mixer.addEventListener('finished', onDanceFinished);
        }

        function onDanceFinished(e) {
            if (!isDancing) return;
            if (e && e.action && currentActiveActionForListener && e.action !== currentActiveActionForListener) return;
            currentVrms.forEach((vrm, vrmIndex) => {
                const moveIndex = vrmDanceSequences[vrmIndex][danceStepIndex];
                const action = danceActionsMap[moveIndex]?.[vrmIndex];
                if (action) action.fadeOut(0.5);
            });
            danceStepIndex++;
            if (danceStepIndex >= 4) {
                danceStepIndex = 0; danceRound++;
                generateSequences(danceRound);
                if (danceRound % 2 === 0) addMessage(`Round ${danceRound}: Battle Mode!`, "system");
                else addMessage(`Round ${danceRound}: Sync Mode!`, "system");
            }
            playCurrentStep();
        }

        function stopDance() {
            if (!isDancing) return;
            isDancing = false;
            danceBtn.classList.remove('active');
            bgm.pause(); bgm.currentTime = 0;
            danceActionsMap.forEach(group => group.forEach(action => action.fadeOut(0.5)));
            if (currentVrms[0]?.userData?.mixer) {
                currentVrms[0].userData.mixer.removeEventListener('finished', onDanceFinished);
                currentVrms[0].userData.mixer.removeEventListener('finished', onSequenceStepFinished);
            }
            currentDanceQueue = []; currentPlayingDanceIndex = -1; currentActiveActionForListener = null;
            setTimeout(() => updateCameraPosition(), 500);
            if (idleActionC) { idleActionC.reset(); idleActionC.fadeIn(0.5).play(); }
            if (idleActionW) { idleActionW.reset(); idleActionW.fadeIn(0.5).play(); }
        }

        function toggleDance() {
            if (isDancing) stopDance(); else loadAndPlayDance();
        }
        
        function onSequenceStepFinished(e) {
             if (!isDancing) return;
             if (e && e.action && currentActiveActionForListener && e.action !== currentActiveActionForListener) return;
             if (currentPlayingDanceIndex !== -1) {
                 currentVrms.forEach((vrm, vrmIndex) => {
                    const action = danceActionsMap[currentPlayingDanceIndex]?.[vrmIndex];
                    if(action) action.fadeOut(0.5);
                 });
             }
             playNextDanceInQueue();
        }

        function safeParseAIJson(text) {
            try {
                const match = text.match(/{[\s\S]*}/);
                if (!match) return null;
                let jsonStr = match[0]
                    .replace(/"dance_list"\s*:\s*,/g, '"dance_list":[],')
                    .replace(/'/g, '"').replace(/,\s*}/g, '}').replace(/,\s*]/g, ']');
                const result = JSON.parse(jsonStr);
                if (result.action === "dance_sequence") {
                    if (typeof result.dance_list === "number") result.dance_list = [result.dance_list];
                    if (typeof result.dance_list === "string") result.dance_list = result.dance_list.split(",").map(n => parseInt(n.trim())).filter(n => !isNaN(n));
                    if (!Array.isArray(result.dance_list) || result.dance_list.length === 0) result.dance_list = null;
                }
                return result;
            } catch (err) { return null; }
        }

        function guessDanceFromText(text) {
            if (!text) return null;
            const map = {
                "éœ¹é‚": 0, "è¡—èˆ": 0, "hiphop": 0, "breakdance": 0,
                "wave": 1, "æ®æ‰‹": 1, "æ¹¯ç‘ªæ–¯": 1, "flair": 1, "thomas": 1,
                "å¯æ„›": 2, "æ„›å¿ƒ": 2, "å˜»å“ˆ": 2, "å¾‹å‹•": 2, "hip hop": 2,
                "æ€§æ„Ÿ": 3, "èµ°ç§€": 3,
                "é–‹å¿ƒ": 4, "happy": 4,
                "è·³èˆ": -1, "dance": -1, "éš¨æ©Ÿ": -1, "random": -1, "é¸ä¸€å€‹": -1, "è¡¨æ¼”": -1 
            };
            const lowerText = text.toLowerCase();
            for (const key in map) { if (lowerText.includes(key)) return [map[key]]; }
            return null;
        }

        async function playDanceSequence(sequence) {
            isDancing = true; danceBtn.classList.add('active');
            if (currentVrms[0]?.userData?.mixer) {
                currentVrms[0].userData.mixer.removeEventListener('finished', onDanceFinished);
                currentVrms[0].userData.mixer.removeEventListener('finished', onSequenceStepFinished);
            }
             danceActionsMap.forEach(group => group.forEach(action => action.fadeOut(0.5)));
            await loadDanceAssets(); 
            isDancing = true; updateCameraPosition();
            if (idleActionC) idleActionC.fadeOut(0.5);
            if (idleActionW) idleActionW.fadeOut(0.5);
            if (talkingActionC) talkingActionC.fadeOut(0.5);
            if (talkingActionW) talkingActionW.fadeOut(0.5);
            try {
                if (!bgm.paused) bgm.pause();
                bgm.currentTime = 0; bgm.muted = isMuted;
                const playPromise = bgm.play();
                if (playPromise !== undefined) playPromise.catch(e=>{});
            } catch(e) {}
            currentDanceQueue = Array.isArray(sequence) ? [...sequence] : [];
            currentDanceQueue = currentDanceQueue.map(id => (id === -1) ? Math.floor(Math.random() * DANCE_URLS.length) : id);
            playNextDanceInQueue();
        }

        function playNextDanceInQueue() {
            if (currentDanceQueue.length === 0) {
                if (currentVrms[0]?.userData?.mixer) currentVrms[0].userData.mixer.removeEventListener('finished', onSequenceStepFinished);
                isDancing = false; bgm.pause(); bgm.currentTime = 0; danceBtn.classList.remove('active');
                setTimeout(() => updateCameraPosition(), 500);
                if (idleActionC) { idleActionC.reset(); idleActionC.fadeIn(0.5).play(); }
                if (idleActionW) { idleActionW.reset(); idleActionW.fadeIn(0.5).play(); }
                return;
            }
            let nextIndex = currentDanceQueue.shift();
            if (nextIndex < 0 || nextIndex >= DANCE_URLS.length) nextIndex = Math.floor(Math.random() * DANCE_URLS.length);
            currentPlayingDanceIndex = nextIndex;
            currentVrms.forEach((vrm, vrmIndex) => {
                if (!vrm || !vrm.userData.mixer) return;
                const action = danceActionsMap[nextIndex]?.[vrmIndex];
                if (action) {
                    if (vrmIndex === 0) currentActiveActionForListener = action;
                    action.reset(); action.setLoop(THREE.LoopOnce); action.clampWhenFinished = true;
                    action.fadeIn(0.5); action.play();
                }
            });
            if (currentVrms[0]?.userData?.mixer) {
                currentVrms[0].userData.mixer.removeEventListener('finished', onSequenceStepFinished);
                currentVrms[0].userData.mixer.addEventListener('finished', onSequenceStepFinished);
            }
        }

        danceBtn.addEventListener('click', toggleDance);
        danceBtn.addEventListener('touchend', (e) => { e.preventDefault(); toggleDance(); });

        // --- Emotions ---
        const VALID_EMOTIONS = ['neutral', 'happy', 'angry', 'sad', 'relaxed', 'surprised'];
        function setEmotion(emotionName) {
            if (emotionName === 'joy') emotionName = 'happy';
            if (emotionName === 'sorrow') emotionName = 'sad';
            if (emotionName === 'fun') emotionName = 'relaxed';
            if (!VALID_EMOTIONS.includes(emotionName)) emotionName = 'neutral';
            
            updateDebugDisplay(emotionName, null);
            
            const targets = isSoloMode ? [soloVrm] : currentVrms;
            targets.forEach(vrm => {
                if(!vrm) return;
                VALID_EMOTIONS.forEach(emo => vrm.expressionManager.setValue(emo, 0));
                if (emotionName !== 'neutral') vrm.expressionManager.setValue(emotionName, 0.8);
            });
        }

        window.actionActive = false;
        function triggerAction(actionName, duration) {
            if (actionName === 'none') return;
            updateDebugDisplay(null, `${actionName}`);
            let shapeName = actionName === 'blink_left' ? 'blinkLeft' : (actionName === 'blink_right' ? 'blinkRight' : 'blink');
            window.actionActive = true;
            
            const targets = isSoloMode ? [soloVrm] : currentVrms;
            targets.forEach(vrm => {
                if(vrm) vrm.expressionManager.setValue(shapeName, 1.0);
            });
            
            setTimeout(() => {
                targets.forEach(vrm => {
                    if(vrm) vrm.expressionManager.setValue(shapeName, 0);
                });
                window.actionActive = false;
                updateDebugDisplay(null, 'Done');
            }, duration);
        }

        function updateDebugDisplay(emo, act) {
            const debugDiv = document.getElementById('emotion-debug');
            if(emo) debugDiv.innerHTML = debugDiv.innerHTML.replace(/æƒ…ç·’: .*/, `æƒ…ç·’: ${emo}`);
            if(act) debugDiv.innerHTML = debugDiv.innerHTML.replace(/å‹•ä½œ: .*/, `å‹•ä½œ: ${act}`);
        }

        function addMessage(text, type) {
            // â­â­â­ ä¿®æ”¹ï¼šæ ¹æ“šæ¨¡å¼é¡¯ç¤ºè¨Šæ¯ â­â­â­
            if (isSoloMode) {
                if (type === 'ai') {
                    const bubble = document.getElementById('solo-bubble');
                    // æ¸…é™¤ä¹‹å‰çš„æ‰“å­—æ©Ÿæ•ˆæœ (ç°¡å–®èµ·è¦‹ï¼Œç›´æ¥æ›¿æ›)
                    bubble.innerText = text;
                    bubble.style.display = 'block';
                    updateHitbox(); // ç«‹å³æ›´æ–°ä½ç½®
                }
                // å–®äººæ¨¡å¼ä¸é¡¯ç¤º User è¨Šæ¯åœ¨å°è©±æ¡† (æˆ–å¯é¸é¡¯ç¤ºåœ¨å¦ä¸€å€‹æ°£æ³¡)
                return;
            }

            const chatDisplay = document.getElementById('chat-display');
            const div = document.createElement('div');
            div.className = `message message-${type}`;
            let safeText = text.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\n/g, "<br>");
            safeText = safeText.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank">$1</a>');
            div.innerHTML = safeText;
            chatDisplay.appendChild(div);
            chatDisplay.scrollTo({ top: chatDisplay.scrollHeight, behavior: 'smooth' });
            return div;
        }
        function removeMessage(el) { if(el && el.parentNode) el.parentNode.removeChild(el); }

        // --- API & Interaction ---
        const statusDot = document.getElementById('status-dot');
        const statusMsg = document.getElementById('status-msg');
        const userInput = document.getElementById('user-input');
        const sendBtn = document.getElementById('send-btn');
        const muteBtn = document.getElementById('mute-btn');
        const micBtn = document.getElementById('mic-btn'); 

        async function testApiConnection() {
            if (isPreviewEnv) {
                statusDot.classList.add('status-preview'); statusMsg.innerText = "é è¦½æ¨¡å¼";
                userInput.disabled = false; sendBtn.disabled = false; return;
            }
            statusMsg.innerText = "é€£ç·šæ¸¬è©¦..."; statusDot.className = 'status-dot'; 
            setTimeout(() => {
                 if (userInput.disabled) { userInput.disabled = false; sendBtn.disabled = false; }
            }, 1000);
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 10000); 
            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: "Test" }] }] }),
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                if (response.ok) { statusDot.classList.add('status-connected'); statusMsg.innerText = "ç³»çµ±é€£ç·šæ­£å¸¸"; } 
                else { throw new Error("API Check Failed"); }
            } catch (e) {
                statusDot.classList.add('status-error'); statusMsg.innerText = "é€£ç·šå¤±æ•—"; 
            } finally {
                userInput.disabled = false; sendBtn.disabled = false; 
            }
        }

        muteBtn.addEventListener('click', () => {
            isMuted = !isMuted;
            muteBtn.classList.toggle('muted', isMuted);
            muteBtn.innerText = isMuted ? 'ğŸ”‡' : 'ğŸ”Š';
            if(isMuted) { window.speechSynthesis.cancel(); isSpeaking = false; }
            bgm.muted = isMuted;
        });

        async function unlockTTS() {
            logTTS("æ­£åœ¨è§£é–èªéŸ³...");
            return new Promise(resolve => {
                try {
                    const u = new SpeechSynthesisUtterance(" ");
                    window.currentUtterance = u; 
                    u.volume = 0; u.rate = 10; 
                    u.onend = () => resolve();
                    setTimeout(() => resolve(), 200); 
                    speechSynthesis.speak(u);
                } catch(e) { resolve(); }
            });
        }

        function handleAIResponse(aiText) {
            let result = safeParseAIJson(aiText);
            let danceSeq = null;
            if (result && Array.isArray(result.dance_list) && result.dance_list.length > 0) danceSeq = result.dance_list;
            if (!danceSeq) danceSeq = guessDanceFromText(aiText);
            if (!danceSeq && result && result.action === "dance_random") danceSeq = [Math.floor(Math.random() * DANCE_URLS.length)];

            if (danceSeq && !isSoloMode) { // ç¨ç«‹æ¨¡å¼ä¸è·³èˆ
                playDanceSequence(danceSeq);
            } 
            
            let speakText = result ? result.text : aiText;
            speak(speakText || "");
            if (result && result.emotion) setEmotion(result.emotion);
            if (result && result.action && result.action !== 'none' && !result.action.startsWith('dance')) triggerAction(result.action, 2000);
            
            if (result && result.corrected_text) {
                // å¦‚æœæ˜¯å–®äººæ¨¡å¼ï¼Œé€™è£¡æ²’æœ‰ message-userï¼Œå¯ä»¥å¿½ç•¥æˆ–å¦å¤–è™•ç†
                const lastUserMsg = document.querySelector('.message-user:last-child');
                if (lastUserMsg) lastUserMsg.innerHTML = result.corrected_text;
            }
        }

        async function handleSendMessage() {
            if (userInput.disabled || sendBtn.disabled) return;
            const text = userInput.value.trim();
            if (!text) return;
            if (isRecording) { stopRecording(); window.shouldResumeMic = true; } 
            else { window.shouldResumeMic = false; }
            if (isDancing) stopDance();
            if (window.speechSynthesis) window.speechSynthesis.cancel();
            if (!isMuted && ttsSupported) await Promise.race([unlockTTS(), new Promise(r => setTimeout(r, 300))]);

            userInput.value = ''; userInput.disabled = true; sendBtn.disabled = true;
            addMessage(text, 'user'); // å–®äººæ¨¡å¼ä¸‹æ­¤å‡½æ•¸æœƒè¢«æ””æˆªä¸é¡¯ç¤ºåœ¨å°è©±æ¡†ï¼Œé€™æ˜¯é æœŸçš„
            
            if (isPreviewEnv) {
                addMessage("ã€æç¤ºã€‘é è¦½æ¨¡å¼ç„¡æ³•é€£æ¥ AIã€‚", 'system');
                userInput.disabled = false; sendBtn.disabled = false; userInput.focus();
                return;
            }
            
            // å–®äººæ¨¡å¼ä¸‹ï¼Œé‚„æ˜¯éœ€è¦ä¸€å€‹ loading æç¤º
            if (isSoloMode) {
                const bubble = document.getElementById('solo-bubble');
                bubble.innerText = "Thinking...";
                bubble.style.display = 'block';
                updateHitbox();
            } else {
                 const loadingMsg = addMessage("Thinking...", 'system');
            }
            
            chatHistory.push({ role: "user", parts: [{ text: text }] });

            let finalSystemInstruction = "";
            if (externalSystemPrompt) finalSystemInstruction += externalSystemPrompt;
            else finalSystemInstruction += `You are a virtual AI character. Reply in Traditional Chinese. Output JSON: { "text": "response", "emotion": "neutral", "action": "none" }`;
            if (externalKnowledge) finalSystemInstruction += "\n\n====== KNOWLEDGE BASE ======\n" + externalKnowledge + "\n============================\n";
            finalSystemInstruction += `\nã€INSTRUCTIONSã€‘\n1. Use Knowledge Base first.\n2. Return JSON.\n3. Dance Rules: IDs 0,1,2,3. Repetition allowed. "action":"dance_sequence" for specific, "dance_random" for random.\n4. Correct user typo in "corrected_text".`;

            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 30000);
            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: chatHistory,
                        systemInstruction: { parts: [{ text: finalSystemInstruction }] },
                    }),
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                if (!response.ok) throw new Error("Server Error");
                const data = await response.json();
                
                // ç§»é™¤ loading (å–®äººæ¨¡å¼æœƒç›´æ¥è¦†è“‹æ–‡å­—ï¼Œç¾¤é«”æ¨¡å¼ç§»é™¤ DOM)
                if (!isSoloMode) {
                     const loadingMsgs = document.querySelectorAll('.message-system');
                     if(loadingMsgs.length > 0 && loadingMsgs[loadingMsgs.length-1].innerText === "Thinking...") {
                         removeMessage(loadingMsgs[loadingMsgs.length-1]);
                     }
                }

                let rawText = data.candidates?.[0]?.content?.parts?.[0]?.text || "Error";
                chatHistory.push({ role: "model", parts: [{ text: rawText }] });
                handleAIResponse(rawText);
                let tempResult = safeParseAIJson(rawText);
                addMessage(tempResult ? tempResult.text : rawText, 'ai');
            } catch (error) {
                if (!isSoloMode) {
                     const loadingMsgs = document.querySelectorAll('.message-system');
                     if(loadingMsgs.length > 0) removeMessage(loadingMsgs[loadingMsgs.length-1]);
                }
                addMessage(error.name === 'AbortError' ? "é€£ç·šé€¾æ™‚" : `éŒ¯èª¤: ${error.message}`, 'system');
            } finally {
                userInput.disabled = false; sendBtn.disabled = false; userInput.focus();
            }
        }

        async function speak(text) {
            if (isMuted) return;
            if (!ttsSupported || !window.speechSynthesis) return;
            const cleanText = text.replace(/\[.*?\]\(.*?\)/g, '').replace(/[^\u4e00-\u9fa5a-zA-Z0-9,.\?ï¼ã€‚ï¼Œã€â€¦~]/g, '');
            if (!cleanText) {
                if (window.shouldResumeMic) setTimeout(() => { if(!isRecording) startRecording(); }, 500);
                return;
            }
            try {
                if (speechSynthesis.getVoices().length === 0) await new Promise(r => setTimeout(r, 300));
                speechSynthesis.cancel();
                await new Promise(r => setTimeout(r, 50));
                const u = new SpeechSynthesisUtterance(cleanText);
                window.currentUtterance = u; 
                if (isAndroid) {
                    const voices = speechSynthesis.getVoices();
                    const voice = voices.find(v => v.lang === 'zh-TW') || voices.find(v => v.lang.includes('zh'));
                    if (voice) { u.voice = voice; u.lang = voice.lang; } else { u.lang = 'zh-TW'; }
                } else { u.lang = 'zh-TW'; }
                u.volume = 1;

                u.onstart = () => {
                    isSpeaking = true;
                    if (!isDancing) {
                        if (isSoloMode) {
                           // ç¨ç«‹æ¨¡å¼åªæ§åˆ¶ soloVrm èªªè©±å‹•ä½œï¼Œé€™è£¡ç°¡å–®è™•ç†ï¼Œåªè¦é–‹å•Ÿå˜´å‹å³å¯ (åœ¨ animate è£¡)
                           // å¦‚æœæœ‰ç¨ç«‹çš„èªªè©±å‹•ä½œè³‡æºå¯ä»¥ loaded é€™è£¡ï¼Œç›®å‰åƒ…ä½¿ç”¨ Breathing_Idle
                        } else {
                            if (idleActionC) idleActionC.fadeOut(0.2);
                            if (idleActionW) idleActionW.fadeOut(0.2); 
                            if (talkingActionC) { talkingActionC.reset(); talkingActionC.fadeIn(0.2).play(); }
                            if (talkingActionW) { talkingActionW.reset(); talkingActionW.fadeIn(0.2).play(); }
                        }
                    }
                };
                u.onend = () => {
                    isSpeaking = false;
                    const targets = isSoloMode ? [soloVrm] : currentVrms;
                    targets.forEach(vrm => { if(vrm) vrm.expressionManager.setValue('aa', 0); });
                    if (!isDancing && !isSoloMode) {
                         if (talkingActionC) talkingActionC.fadeOut(0.5);
                         if (talkingActionW) talkingActionW.fadeOut(0.5);
                         if (idleActionC) { idleActionC.reset(); idleActionC.fadeIn(0.5).play(); }
                         if (idleActionW) { idleActionW.reset(); idleActionW.fadeIn(0.5).play(); }
                    }
                    if (window.shouldResumeMic) setTimeout(() => { if (!isRecording) startRecording(); }, 500);
                };
                u.onerror = (e) => { if (e.error !== 'interrupted' && e.error !== 'canceled') console.error("TTS error", e.error); };
                speechSynthesis.speak(u);
            } catch (err) { console.error("Speech error:", err); }
        }

        sendBtn.addEventListener('click', handleSendMessage);
        sendBtn.addEventListener('touchend', (e) => { e.preventDefault(); handleSendMessage(); });
        userInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') handleSendMessage(); });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            updateCameraPosition();
        });

        // --- Speech Recognition ---
        let recognition = null;
        let isRecording = false;
        let silenceTimer = null;
        let finalTranscript = '';
        const voiceOverlay = document.getElementById('voice-overlay'); 

        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
            const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SR();
            if (isIOS || isAndroid) { recognition.continuous = false; recognition.maxAlternatives = 1; } 
            else { recognition.continuous = true; }
            recognition.interimResults = true; recognition.lang = 'zh-TW'; 

            recognition.onstart = () => { 
                isRecording = true; updateMicUI(true); 
                if (window.speechSynthesis) window.speechSynthesis.cancel();
                bgm.pause(); isSpeaking = false; 
            };
            recognition.onend = () => { 
                if (isRecording) { if (isIOS || isAndroid) setTimeout(() => safeStartRecognition(), 100); else safeStartRecognition(); } 
                else { updateMicUI(false); }
            };
            recognition.onerror = (e) => { 
                if (e.error === 'no-speech') return;
                if (e.error === 'not-allowed' || e.error === 'service-not-allowed') {
                    isRecording = false; updateMicUI(false);
                    alert("éº¥å…‹é¢¨åŠŸèƒ½å·²è¢«å°é–æˆ–ä¸æ”¯æ´ã€‚");
                } else { recognition.stop(); }
            };
            recognition.onresult = (e) => {
                let interim = '';
                for (let i = e.resultIndex; i < e.results.length; ++i) {
                    if (e.results[i].isFinal) finalTranscript += e.results[i][0].transcript;
                    else interim += e.results[i][0].transcript;
                }
                userInput.value = finalTranscript + interim;
                clearTimeout(silenceTimer);
                if (userInput.value.trim()) {
                    silenceTimer = setTimeout(async () => { 
                        const rawText = userInput.value.trim();
                        if(rawText) handleSendMessage();
                    }, 1500);
                }
            };
        } else { micBtn.style.display = 'none'; }

        function toggleRecording() { if(!recognition) return; if(isRecording) stopRecording(); else startRecording(); }
        function startRecording() {
            if (window.speechSynthesis) try { window.speechSynthesis.cancel(); } catch(e) {}
            isSpeaking = false; finalTranscript = ''; userInput.value = ''; isRecording = true; safeStartRecognition();
        }
        function stopRecording() { isRecording = false; recognition.stop(); clearTimeout(silenceTimer); updateMicUI(false); }
        function safeStartRecognition() { try { recognition.start(); } catch(e) {} }
        function updateMicUI(active) {
            if(active) { 
                micBtn.classList.add('recording-pulse'); 
                micBtn.innerHTML = '<i class="fa-solid fa-microphone-lines"></i>'; 
                voiceOverlay.style.display = 'block'; 
            } else { 
                micBtn.classList.remove('recording-pulse'); 
                micBtn.innerHTML = '<i class="fa-solid fa-microphone"></i>';
                voiceOverlay.style.display = 'none'; 
            }
        }
        micBtn.addEventListener('click', (e) => {
            if (isIOS && (isLineApp || isFbApp)) { alert("è«‹ä½¿ç”¨ Safari é–‹å•Ÿã€‚"); return; }
            toggleRecording();
        });
        if (isAndroid || isIOS) micBtn.style.display = 'none';

    </script>
</body>
</html>
