<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="utf-8">
<title>AI VTuber - Golden New Year (Voice Enabled)</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<!-- å¼•å…¥ FontAwesome ç”¨æ–¼éº¥å…‹é¢¨åœ–ç¤º -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<style>
    /* å…¨åŸŸè¨­å®šï¼šç¢ºä¿é‚Šæ¡†è¨ˆç®—ä¸å½±éŸ¿å¯¬åº¦ */
    * { box-sizing: border-box; }

    body {
        margin: 0;
        padding: 0;
        overflow: hidden; /* ç¦æ­¢æ²å‹• */
        /* ä¿®æ”¹ï¼šæ”¹ç‚ºäº®é‡‘è‰²æ¼¸å±¤èƒŒæ™¯ï¼Œçªé¡¯é»‘è‰²è¡£æœ */
        background: linear-gradient(135deg, #fff8e1 0%, #ffecb3 50%, #ffe0b2 100%);
        font-family: "Noto Sans TC", sans-serif;
        overscroll-behavior: none; 
        width: 100vw;
        height: 100vh;
        /* è§£æ±º Safari/Chrome Mobile é«˜åº¦å•é¡Œ */
        height: 100dvh; 
    }
    
    /* è®€å–ç•«é¢ */
    #loading-screen {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(255, 255, 255, 0.95);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 999;
        transition: opacity 0.5s ease;
    }
    
    .loader {
        border: 4px solid #fff3e0;
        border-top: 4px solid #d32f2f;
        border-radius: 50%;
        width: 40px; height: 40px;
        animation: spin 1s linear infinite;
        margin-bottom: 15px;
    }

    .loading-text { color: #d32f2f; font-size: 1rem; font-weight: bold; margin-bottom: 20px; }

    #start-btn {
        padding: 12px 30px;
        font-size: 1.1rem;
        background: linear-gradient(to right, #d32f2f, #f44336);
        color: #ffd700;
        border: 2px solid #ffd700;
        border-radius: 50px;
        cursor: pointer;
        display: none;
        box-shadow: 0 4px 15px rgba(211, 47, 47, 0.3);
        transition: transform 0.2s, background 0.2s;
        font-weight: bold;
        text-shadow: 0 1px 2px rgba(0,0,0,0.2);
        /* Android è§¸æ§å„ªåŒ– */
        touch-action: manipulation; 
        -webkit-tap-highlight-color: transparent;
        user-select: none;
    }
    #start-btn:active { transform: scale(0.95); background: #b71c1c; }

    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    /* API ç‹€æ…‹ (å³ä¸Šè§’) */
    #api-status {
        position: absolute;
        top: 15px; right: 15px;
        padding: 6px 12px;
        background: rgba(255, 255, 255, 0.8);
        backdrop-filter: blur(4px);
        border-radius: 20px;
        font-size: 12px;
        font-weight: bold;
        color: #333; /* ä¿®æ”¹ï¼šæ”¹ç‚ºä¸€èˆ¬é»‘è‰²/æ·±ç°è‰² */
        display: flex; align-items: center;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        z-index: 100;
        transition: all 0.3s;
        border: 1px solid #ffcc80;
    }
    .status-dot { width: 8px; height: 8px; border-radius: 50%; background-color: #ccc; margin-right: 6px; }
    .status-connected { background-color: #2ecc71; box-shadow: 0 0 5px #2ecc71; }
    .status-error { background-color: #e74c3c; box-shadow: 0 0 5px #e74c3c; }
    .status-preview { background-color: #f39c12; box-shadow: 0 0 5px #f39c12; }

    /* æª”æ¡ˆè®€å–ç‹€æ…‹é¢æ¿ */
    #file-status {
        position: absolute;
        top: 15px; left: 15px;
        padding: 10px;
        background: rgba(255, 255, 255, 0.8);
        backdrop-filter: blur(4px);
        border-radius: 12px;
        font-size: 12px;
        color: #5d4037;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        z-index: 100;
        max-width: 180px;
        transition: opacity 0.5s;
        pointer-events: none;
        border: 1px solid #ffcc80;
    }
    .file-status-item { 
        margin-bottom: 4px; 
        display: flex; 
        align-items: center; 
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    .file-status-item:last-child { margin-bottom: 0; }
    .icon-ok { color: #2e7d32; margin-right: 6px; font-weight: bold; }
    .icon-fail { color: #c62828; margin-right: 6px; font-weight: bold; }
    .icon-loading { color: #ef6c00; margin-right: 6px; animation: pulse 1s infinite; }
    
    /* Android é™¤éŒ¯é¢æ¿ */
    #tts-debug {
        position: absolute;
        top: 120px; /* ä½æ–¼å…¶ä»–ç‹€æ…‹ä¸‹æ–¹ */
        left: 10px;
        background: rgba(0, 0, 0, 0.85);
        color: #00ff00; /* é§­å®¢ç¶ ï¼Œæ–¹ä¾¿é–±è®€ */
        font-family: "Courier New", monospace;
        font-size: 11px;
        padding: 10px;
        border-radius: 8px;
        width: 280px;
        max-height: 200px;
        overflow-y: auto;
        z-index: 9999;
        pointer-events: none; /* é»æ“Šç©¿é€ */
        display: none; /* é è¨­éš±è—ï¼ŒJS åµæ¸¬åˆ° Android æ‰é–‹å•Ÿ */
        border: 2px solid #00ff00;
        line-height: 1.4;
        white-space: pre-wrap;
        box-shadow: 0 0 10px rgba(0,0,0,0.5);
    }

    /* ç€è¦½å™¨ä¸æ”¯æ´è­¦å‘Š */
    #browser-warning {
        position: absolute;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 235, 59, 0.95);
        color: #b71c1c;
        padding: 20px;
        border-radius: 15px;
        text-align: center;
        z-index: 10000;
        display: none;
        box-shadow: 0 10px 25px rgba(0,0,0,0.3);
        border: 2px solid #f57f17;
        width: 80%;
        max-width: 400px;
    }
    #browser-warning h3 { margin-top: 0; }
    #browser-warning button {
        margin-top: 15px;
        padding: 8px 16px;
        background: #b71c1c;
        color: white;
        border: none;
        border-radius: 20px;
        cursor: pointer;
    }

    @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }

    /* å°è©±ä»‹é¢ */
    #chat-container {
        position: absolute; 
        /* ä¿®æ”¹ï¼šæé«˜åº•éƒ¨è·é›¢ï¼Œä¸¦åŠ å…¥å®‰å…¨å€åŸŸï¼Œé˜²æ­¢è¢«æ‰‹æ©Ÿå°è¦½åˆ—é®æ“‹ */
        bottom: 30px; 
        bottom: calc(30px + env(safe-area-inset-bottom));
        left: 50%; 
        transform: translateX(-50%);
        width: 90%; 
        max-width: 600px;
        display: flex; 
        flex-direction: column; 
        gap: 8px;
        z-index: 100;
        transition: bottom 0.3s;
    }

    @media (max-width: 600px) {
        #chat-container {
            width: 95%; 
            /* æ‰‹æ©Ÿç‰ˆç¨å¾®å†é«˜ä¸€é» */
            bottom: 40px; 
            bottom: calc(40px + env(safe-area-inset-bottom));
        }
        #file-status, #api-status {
            top: 10px;
            transform: scale(0.9); 
            transform-origin: top;
        }
        #file-status { left: 10px; }
        #api-status { right: 10px; }
    }

    #chat-display {
        background: rgba(255, 255, 255, 0.15); /* â­ æ”¹å›åŠé€æ˜ï¼Œä¸¦å¤§å¹…æé«˜é€æ˜åº¦ (æ•¸å€¼è¶Šå°è¶Šé€æ˜) */
        padding: 12px; 
        border-radius: 16px;
        height: 140px; 
        overflow-y: auto;
        backdrop-filter: blur(8px); /* â­ åŠ å›æ¯›ç»ç’ƒæ•ˆæœ */
        -webkit-backdrop-filter: blur(8px);
        border: 1px solid rgba(255, 215, 0, 0.6);
        display: flex;
        flex-direction: column;
        gap: 8px;
        scrollbar-width: none; 
        -ms-overflow-style: none;
    }
    #chat-display::-webkit-scrollbar { display: none; }

    .message {
        padding: 8px 12px;
        border-radius: 12px;
        max-width: 85%;
        word-wrap: break-word;
        font-size: 14px;
        line-height: 1.5;
        color: white;
        text-shadow: 0 1px 1px rgba(0,0,0,0.1);
    }

    .message-user { 
        align-self: flex-end; 
        background-color: rgba(30, 136, 229, 0.9); /* ä¿®æ”¹ï¼šè—åº• */
        border-bottom-right-radius: 2px; 
        color: #fff;
    }
    .message-ai { 
        align-self: flex-start; 
        background-color: rgba(255, 255, 255, 0.9); 
        border-bottom-left-radius: 2px; 
        color: #333; 
        text-shadow: none;
        border: 1px solid #ffd700;
    }
    .message-system { align-self: center; background: transparent; color: #e65100; font-size: 12px; font-style: italic; text-shadow: none; text-align: center;}

    .message a { color: #1e88e5; text-decoration: none; border-bottom: 1px dotted #1e88e5; }
    .message-user a { color: #bbdefb; } /* ä¿®æ”¹ï¼šä½¿ç”¨è€…è¨Šæ¯å…§çš„é€£çµé¡è‰² */

    #input-area { 
        display: flex; 
        gap: 8px; 
        align-items: center; 
        width: 100%; /* ç¢ºä¿æ»¿ç‰ˆ */
        position: relative; /* ç‚ºäº†å®šä½èªéŸ³æ³¢å‹•æ¢ */
    }
    
    /* è¼¸å…¥æ¡†å®¹å™¨ï¼Œç”¨æ–¼åŒ…è£¹ input èˆ‡èªéŸ³æ³¢å‹•æ¢ */
    .input-wrapper {
        position: relative;
        flex: 1;
        display: flex;
        min-width: 0;
    }

    #user-input {
        width: 100%;
        padding: 12px 16px; 
        border-radius: 25px; 
        border: 1px solid rgba(255, 215, 0, 0.6);
        outline: none;
        background: rgba(255, 255, 255, 0.95); 
        font-size: 16px; 
        box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        color: #5d4037;
        z-index: 2; /* ç¢ºä¿æ–‡å­—åœ¨æ³¢å‹•æ¢ä¸Šæ–¹ */
        background-color: transparent; /* è®“èƒŒæ™¯é€æ˜ä»¥é¡¯ç¤ºæ³¢å‹•æ¢ */
        background: rgba(255, 255, 255, 0.95);
    }
    #user-input::placeholder { color: #999; }

    /* â­â­â­ èªéŸ³æ³¢å‹•æ¢æ¨£å¼ â­â­â­ */
    #voice-overlay {
        position: absolute;
        bottom: 1px;
        left: 20px; /* é…åˆ border-radius */
        right: 20px;
        height: 3px;
        background-color: #3b82f6;
        z-index: 3;
        display: none; /* é è¨­éš±è— */
        pointer-events: none;
        animation: voice-pulse 1.5s infinite;
    }
    @keyframes voice-pulse { 0%, 100% { opacity: 0.5; transform: scaleX(0.95); } 50% { opacity: 1; transform: scaleX(1); } }

    #send-btn {
        padding: 0 20px; 
        height: 44px; 
        border-radius: 22px; border: none;
        background: linear-gradient(to right, #1976d2, #1565c0); /* ä¿®æ”¹ï¼šè—è‰²æ¼¸å±¤ */
        color: #fff; /* ä¿®æ”¹ï¼šæ–‡å­—ç™½è‰² */
        font-weight: bold; cursor: pointer;
        transition: background 0.2s;
        box-shadow: 0 4px 10px rgba(21, 101, 192, 0.3); /* ä¿®æ”¹ï¼šè—è‰²é™°å½± */
        flex-shrink: 0;
        border: 1px solid #90caf9; /* ä¿®æ”¹ï¼šé‚Šæ¡†é¡è‰² */
        /* Android è§¸æ§å„ªåŒ– */
        touch-action: manipulation; 
        -webkit-tap-highlight-color: transparent;
        user-select: none;
    }
    #send-btn:active { transform: scale(0.95); }
    #send-btn:disabled { background: #bdbdbd; box-shadow: none; cursor: not-allowed; border: none; color: #fff;}

    /* æŒ‰éˆ•å…±ç”¨æ¨£å¼ */
    .control-btn {
        width: 44px; height: 44px; border-radius: 50%; border: none;
        background: rgba(255, 255, 255, 0.95); font-size: 20px; cursor: pointer;
        display: flex; justify-content: center; align-items: center;
        box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        flex-shrink: 0;
        border: 1px solid #ffd700;
        color: #d32f2f;
        transition: all 0.2s; /* å¢åŠ éæ¸¡æ•ˆæœ */
        /* Android è§¸æ§å„ªåŒ– */
        touch-action: manipulation; 
        -webkit-tap-highlight-color: transparent;
        user-select: none;
    }
    .control-btn:active { transform: scale(0.95); }
    #mute-btn.muted { background: #e74c3c; color: white; border: none; }
    
    /* ä¿®æ”¹ï¼šè·³èˆæŒ‰éˆ•æŒ‰ä¸‹ç‹€æ…‹çš„æ¨£å¼ */
    #dance-btn { color: #e91e63; } 
    #dance-btn.active {
        background: #e91e63; /* æŒ‰ä¸‹è®Šæ·±ç²‰ç´… */
        color: white;
        box-shadow: inset 0 0 10px rgba(0,0,0,0.3);
        border-color: #c2185b;
    }

    /* â­â­â­ éº¥å…‹é¢¨éŒ„éŸ³å‹•ç•« â­â­â­ */
    .recording-pulse {
        animation: pulse-ring 2s infinite;
        background-color: #ef4444 !important; /* ç´…è‰²èƒŒæ™¯ */
        color: white !important;
        border: none !important;
    }
    @keyframes pulse-ring {
        0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
        70% { transform: scale(1.1); box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
        100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
    }
    
    #emotion-debug {
        position: absolute; top: 60px; right: 15px;
        font-size: 10px; color: #5d4037;
        background: rgba(255,255,255,0.7);
        padding: 4px 8px; border-radius: 6px;
        pointer-events: none;
        backdrop-filter: blur(2px);
        text-align: right;
        line-height: 1.3;
        opacity: 0.6; 
    }

    /* â­â­â­ æ–°å¢ï¼šç•«é¢ä¸Šæ–¹çš„å‹•ä½œæŒ‡ä»¤ç›£æ§é¢æ¿ â­â­â­ */
    #action-debug-panel {
        position: absolute;
        top: 15px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.85);
        color: #00ffcc; /* è¢å…‰ç¶ è‰²ï¼Œæ–¹ä¾¿éŒ„å½±æ™‚çœ‹æ¸…æ¥š */
        font-family: "Courier New", monospace;
        font-size: 11px;
        padding: 10px;
        border-radius: 8px;
        width: 60%;
        max-width: 500px;
        max-height: 120px;
        overflow-y: auto;
        z-index: 10000;
        pointer-events: auto; /* å…è¨±æ»¾å‹• */
        border: 1px solid #00ffcc;
        line-height: 1.4;
        white-space: pre-wrap;
        word-wrap: break-word;
        box-shadow: 0 4px 10px rgba(0,0,0,0.5);

        /* åŠ å…¥ä»¥ä¸‹é€™å››è¡Œä¾†éš±è—å®ƒ */
        top: -9999px; 
        left: -9999px;
        opacity: 0;
        pointer-events: none;
    }
    @media (max-width: 600px) {
        #action-debug-panel {
            width: 90%;
            top: 40px; /* æ‰‹æ©Ÿç‰ˆå¾€ä¸‹æŒªä¸€é»é¿å…èˆ‡å…¶ä»–ç‹€æ…‹é‡ç–Š */
        }
    }

</style>

<!-- â­ æ–°å¢: ES Module Shimsï¼Œç¢ºä¿ importmap åœ¨æ‰€æœ‰ç€è¦½å™¨éƒ½èƒ½æ­£å¸¸é‹ä½œ -->
<script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>

<script type="importmap">
{
    "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/",
        "@pixiv/three-vrm": "https://unpkg.com/@pixiv/three-vrm@3.0.0/lib/three-vrm.module.js",
        "@pixiv/three-vrm-animation": "https://unpkg.com/@pixiv/three-vrm-animation@3.0.0/lib/three-vrm-animation.module.js"
    }
}
</script>
</head>

<body>

    <div id="loading-screen">
        <div class="loader" id="loader"></div>
        <div class="loading-text" id="status-text">åˆå§‹åŒ–æ–°å¹´ç³»çµ±...</div>
        <button id="start-btn">é–‹å§‹æ–°å¹´å°è©±</button>
    </div>

    <!-- ç€è¦½å™¨ä¸æ”¯æ´è­¦å‘Š -->
    <div id="browser-warning">
        <h3>âš ï¸ ç€è¦½å™¨åŠŸèƒ½é™åˆ¶</h3>
        <p>æª¢æ¸¬åˆ°ç›®å‰çš„ç€è¦½å™¨ (ä¾‹å¦‚ LINE/FB å…§å»ºç€è¦½å™¨) ä¸æ”¯æ´èªéŸ³åŠŸèƒ½ã€‚</p>
        <p>è«‹é»æ“Šå³ä¸Šè§’é¸å–®ï¼Œé¸æ“‡ã€Œåœ¨ç€è¦½å™¨ä¸­é–‹å•Ÿã€ (Open in Chrome/Safari) ä»¥ç²å¾—å®Œæ•´é«”é©—ã€‚</p>
        <button onclick="document.getElementById('browser-warning').style.display='none'">æˆ‘çŸ¥é“äº† (ç¹¼çºŒç„¡è²æ¨¡å¼)</button>
    </div>

    <div id="file-status">
        <div class="file-status-item"><span class="icon-loading">â—</span> ç³»çµ±å•Ÿå‹•...</div>
    </div>

    <div id="api-status">
        <div class="status-dot" id="status-dot"></div>
        <span id="status-msg">é€£ç·šä¸­...</span>
    </div>
    
    <!-- Android èªéŸ³è¨ºæ–·é¢æ¿ (é è¨­éš±è—) -->
    <div id="tts-debug">TTS ç³»çµ±è¨ºæ–·ä¸­...</div>
    
    <div id="emotion-debug">
        æƒ…ç·’: Neutral<br>
        å‹•ä½œ: None
    </div>

    <!-- â­â­â­ æ–°å¢ï¼šå‹•ä½œæŒ‡ä»¤ç›£æ§é¢æ¿ (Action Debug Panel) â­â­â­ -->
    <div id="action-debug-panel">ç­‰å¾…å‹•ä½œæŒ‡ä»¤...</div>

    <div id="chat-container">
        <div id="chat-display">
            <!-- è¨Šæ¯å°‡ç”± JavaScript å‹•æ…‹åŠ å…¥ -->
        </div>
        <div id="input-area">
            <button id="dance-btn" class="control-btn" title="ç†±èˆçµ„æ›²">ğŸ’ƒ</button>
            <button id="mute-btn" class="control-btn" title="åˆ‡æ›è²éŸ³">ğŸ”Š</button>
            
            <!-- â­â­â­ è¼¸å…¥æ¡†åŒ…è£¹å€èˆ‡èªéŸ³æ³¢å‹•æ¢ â­â­â­ -->
            <div class="input-wrapper">
                <input type="text" id="user-input" placeholder="è«‹è¼¸å…¥è¨Šæ¯..." disabled>
                <div id="voice-overlay"></div>
            </div>

            <!-- â­â­â­ æ–°å¢éº¥å…‹é¢¨æŒ‰éˆ• â­â­â­ -->
            <button id="mic-btn" class="control-btn" title="èªéŸ³è¼¸å…¥"><i class="fa-solid fa-microphone"></i></button>

            <button id="send-btn" disabled>ç™¼é€</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';
        import { VRMAnimationLoaderPlugin, createVRMAnimationClip } from '@pixiv/three-vrm-animation';

        const API_URL = "/api/chat"; 
        
        // --- åµæ¸¬ä½œæ¥­ç³»çµ± ---
        const isAndroid = /Android/i.test(navigator.userAgent);
        const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
        // â­â­â­ åµæ¸¬æ˜¯å¦ç‚º LINE æˆ– Facebook å…§å»ºç€è¦½å™¨ â­â­â­
        const isLineApp = /Line/i.test(navigator.userAgent);
        const isFbApp = /FBAN|FBAV/i.test(navigator.userAgent);

        // Global flag for auto-resuming mic
        window.shouldResumeMic = false;
        window.pendingMicResume = false; // â­ æ–°å¢ï¼šç”¨æ–¼æ¨™è¨˜è·³èˆçµæŸå¾Œæ‰å•Ÿå‹•éº¥å…‹é¢¨çš„æ’ç¨‹

        // Android Debug Logger Setup
        const ttsDebug = document.getElementById('tts-debug');
        
        // ä¿®æ­£ï¼šå¦‚æœåµæ¸¬åˆ°æ˜¯ Androidï¼Œç«‹åˆ»é¡¯ç¤ºé¢æ¿ä¸¦å¯«å…¥ç¬¬ä¸€è¡Œ Log
        if (isAndroid) {
            // ttsDebug.style.display = 'block'; // ä¿®æ”¹ï¼šéš±è—é™¤éŒ¯é¢æ¿
            ttsDebug.innerHTML = "=== Android Debug Log (Init) ===<br>";
        }

        function logTTS(msg) {
            // å…è¨± Android/iOS æˆ–å¼·åˆ¶é–‹å•Ÿé™¤éŒ¯æ™‚å¯«å…¥
            if (!isAndroid && !isIOS) return;
            const time = new Date().toTimeString().split(' ')[0];
            // æ¡ç”¨ append æ–¹å¼ï¼Œæ–°çš„è¨Šæ¯åœ¨æœ€ä¸Šæ–¹
            ttsDebug.innerHTML = `[${time}] ${msg}<br>` + ttsDebug.innerHTML;
        }

        // ç«‹å³æ¸¬è©¦ Log åŠŸèƒ½
        logTTS("è…³æœ¬è¼‰å…¥... æª¢æŸ¥ API");

        // â­â­â­ æ–°å¢ï¼šå‹•ä½œç›£æ§å¯«å…¥å‡½å¼ â­â­â­
        function logAction(msg) {
            const panel = document.getElementById('action-debug-panel');
            if (panel) {
                const time = new Date().toTimeString().split(' ')[0];
                // å°‡æ–°è¨Šæ¯åŠ åœ¨æœ€ä¸Šæ–¹
                panel.innerHTML = `[${time}] ${msg}\n-------------------\n` + panel.innerHTML;
            }
        }

        // â­â­â­ ç€è¦½å™¨åŠŸèƒ½æª¢æŸ¥èˆ‡ç›¸å®¹æ€§ä¿®å¾© â­â­â­
        let ttsSupported = true;

        if (!window.speechSynthesis) {
            // å˜—è©¦èˆŠç‰ˆå‰ç¶´
            if (window.webkitSpeechSynthesis) {
                window.speechSynthesis = window.webkitSpeechSynthesis;
                window.SpeechSynthesisUtterance = window.webkitSpeechSynthesisUtterance;
                logTTS("âš ï¸ ä½¿ç”¨ webkitSpeechSynthesis ç›¸å®¹æ¨¡å¼");
            } else {
                logTTS("âŒ éŒ¯èª¤: ä¸æ”¯æ´ speechSynthesis");
                ttsSupported = false;
            }
        } else {
            logTTS("âœ… æ”¯æ´ speechSynthesis");
        }

        if (ttsSupported && !window.SpeechSynthesisUtterance) {
             logTTS("âŒ éŒ¯èª¤: ä¸æ”¯æ´ SpeechSynthesisUtterance");
             ttsSupported = false;
        } else if (ttsSupported) {
             logTTS("âœ… æ”¯æ´ SpeechSynthesisUtterance");
        }

        // å¦‚æœä¸æ”¯æ´ï¼Œé¡¯ç¤ºè­¦å‘Šé¢æ¿
        if (!ttsSupported && isAndroid) {
            document.getElementById('browser-warning').style.display = 'block';
            logTTS(">> å·²é¡¯ç¤ºç€è¦½å™¨æ›´æ›æç¤º <<");
        }

        // --- éš¨æ©Ÿè§’è‰²é¸æ“‡é‚è¼¯ (æ–°å¢ç¬¬ä¸‰ä½è§’è‰²) ---
        const VRM_MODELS = [
            'https://davidkuodcam-crypto.github.io/VTuber/AvatarSample_C.vrm', // è§’è‰² 0: C
            'https://davidkuodcam-crypto.github.io/VTuber/AvatarSample_W.vrm', // è§’è‰² 1: W
            'https://davidkuodcam-crypto.github.io/VTuber/David_Kuo_07.vrm'    // è§’è‰² 2: David (æ–°å¢)
        ];
        
        // è®Šæ•¸ä¿®æ”¹ï¼šæ”¯æ´å¤šè§’è‰²
        let currentVrms = []; // æ”¹ç‚ºé™£åˆ—
        let mixers = [];      // å‹•ç•«æ··åˆå™¨é™£åˆ—
        let isDancing = false;
        
        // --- èˆæ­¥æ¸…å–® ---
        const DANCE_URLS = [
            'https://davidkuodcam-crypto.github.io/VTuber/Breakdance_Freeze_Var_3.vrma', // 0: éœ¹é‚èˆå®šæ ¼A
            'https://davidkuodcam-crypto.github.io/VTuber/Flair.vrma',                   // 1: æ¹¯ç‘ªæ–¯è¿´æ—‹
            'https://davidkuodcam-crypto.github.io/VTuber/Hip_Hop_Dancing.vrma',         // 2: å˜»å“ˆå¾‹å‹•
            'https://davidkuodcam-crypto.github.io/VTuber/Breakdance_Freeze_Var_1.vrma'  // 3: éœ¹é‚èˆå®šæ ¼B
        ];
        
        // --- å‹•ä½œè¨­å®š (èªªè©± / é–’ç½®) (æ–°å¢ç¬¬ä¸‰ä½) ---
        const TALK_ANIMATION_C_URL = 'https://davidkuodcam-crypto.github.io/VTuber/Breathing_Idle.vrma';
        const TALK_ANIMATION_W_URL = 'https://davidkuodcam-crypto.github.io/VTuber/Talking_01.vrma';
        const TALK_ANIMATION_D_URL = 'https://davidkuodcam-crypto.github.io/VTuber/Breathing_Idle.vrma'; // æ–°å¢ D
        
        const IDLE_ANIMATION_C_URL = 'https://davidkuodcam-crypto.github.io/VTuber/Taunt_with_Skin.vrma'; // C çš„é–’ç½®å‹•ä½œ
        const IDLE_ANIMATION_W_URL = 'https://davidkuodcam-crypto.github.io/VTuber/Idle_01.vrma'; // W çš„é–’ç½®å‹•ä½œ
        const IDLE_ANIMATION_D_URL = 'https://davidkuodcam-crypto.github.io/VTuber/Idle_01.vrma'; // æ–°å¢ D çš„é–’ç½®å‹•ä½œ
        
        let talkingActionC = null;
        let talkingActionW = null;
        let talkingActionD = null; // æ–°å¢ D
        let idleActionC = null;    
        let idleActionW = null;    
        let idleActionD = null;    // æ–°å¢ D

        // --- BGM è¨­å®š ---
        const BGM_URL = 'https://davidkuodcam-crypto.github.io/VTuber/Happy_new_year.mp3';
        const bgm = new Audio(BGM_URL);
        bgm.loop = true; // å¾ªç’°æ’­æ”¾
        bgm.volume = 0.5; // éŸ³é‡é©ä¸­
        // â­ æ–°å¢ï¼šé›™é‡ä¿éšªï¼Œç¢ºä¿å› ç‚ºæŸäº›ç€è¦½å™¨ä¸æ”¯æ´ loop å±¬æ€§æ™‚ï¼ŒéŸ³æ¨‚ä¾ç„¶èƒ½ç„¡ç¸«å¾ªç’°æ’­åˆ°è·³èˆçµæŸ
        bgm.addEventListener('ended', function() {
            if (isDancing) {
                this.currentTime = 0;
                const p = this.play();
                if(p) p.catch(e => console.warn(e));
            }
        });
        
        let danceActionsMap = []; // å„²å­˜æ‰€æœ‰èˆæ­¥çš„ Actionï¼Œçµæ§‹: [ [VRM1_Dance1, VRM2_Dance1], [VRM1_Dance2, VRM2_Dance2]... ]
        
        // â­â­â­ æ–°å¢ï¼šå›åˆåˆ¶èˆ‡éš¨æ©Ÿé‚è¼¯è®Šæ•¸ â­â­â­
        let danceRound = 1;        // ç›®å‰å›åˆæ•¸ (1, 2, 3...)
        let danceStepIndex = 0;    // ç›®å‰è·³åˆ°è©²å›åˆçš„ç¬¬å¹¾å€‹å‹•ä½œ (0~3)
        let vrmDanceSequences = []; // å„²å­˜æ¯å€‹ VRM åœ¨è©²å›åˆçš„å‹•ä½œé †åº [VRM1_Seq, VRM2_Seq]
        
        // â­â­â­ æ–°å¢ï¼šé€£çºŒèˆæ­¥æ’­æ”¾ä½‡åˆ— â­â­â­
        let currentDanceQueue = [];
        let currentPlayingDanceData = null; 
        
        // â­ çµ‚æ¥µé˜²å‘†ï¼šå„²å­˜æ‰€æœ‰çš„äº‹ä»¶ç›£è½å™¨ï¼Œé˜²æ­¢ Three.js ç™¼ç”Ÿ Memory Leak èˆ‡å‹•ä½œé›™é‡è§¸ç™¼çš„ Bug
        let currentDanceListeners = [null, null, null];

        // ============================================================================
        // â­â­â­ çµ‚æ¥µä¿®å¾©ï¼šæ ¸å¿ƒå‹•ç•«ç®¡ç†å¼•æ“ (å®Œå…¨æ‹‹æ£„æ‰‹å‹•è¿½è¹¤é™£åˆ—ï¼Œæœçµ• A-pose) â­â­â­
        // ============================================================================
        
        // å–å¾—è©²è§’è‰²ç›®å‰è¼‰å…¥çš„æ‰€æœ‰å¯èƒ½å‹•ä½œ
        function getAllActions(vrmIndex) {
            const actions = [];
            if (vrmIndex === 0) {
                if (idleActionC) actions.push(idleActionC);
                if (talkingActionC) actions.push(talkingActionC);
            } else if (vrmIndex === 1) {
                if (idleActionW) actions.push(idleActionW);
                if (talkingActionW) actions.push(talkingActionW);
            } else if (vrmIndex === 2) {
                if (idleActionD) actions.push(idleActionD);
                if (talkingActionD) actions.push(talkingActionD);
            }
            // åŠ å…¥æ‰€æœ‰å¯èƒ½çš„èˆè¹ˆå‹•ä½œ
            danceActionsMap.forEach(group => {
                if (group && group[vrmIndex]) actions.push(group[vrmIndex]);
            });
            return actions;
        }

        // å¼·å¤§çš„ç„¡ç¸«åˆ‡æ›å¼•æ“ï¼Œç›´æ¥è©¢å• Mixer çš„çœŸå¯¦ç‹€æ…‹
        function switchToAction(vrmIndex, targetAction, duration = 0.5, forceReset = false) {
            const allActions = getAllActions(vrmIndex);
            
            // 1. è®“æ‰€æœ‰ã€Œéç›®æ¨™ã€ä¸”ã€Œæ­£åœ¨æ’­æ”¾/ä½”æœ‰æ¬Šé‡ã€çš„å‹•ä½œè‡ªå‹•æ·¡å‡º
            allActions.forEach(action => {
                if (action && action !== targetAction && action.getEffectiveWeight() > 0) {
                    action.fadeOut(duration);
                }
            });

            // 2. è™•ç†æˆ‘å€‘çœŸæ­£è¦æ’­æ”¾çš„ç›®æ¨™å‹•ä½œ
            if (targetAction) {
                if (forceReset) {
                    targetAction.reset(); // é‡å°èˆè¹ˆå‹•ä½œï¼Œå¼·åˆ¶å¾ç¬¬ä¸€å¹€é–‹å§‹
                    targetAction.play();
                    targetAction.fadeIn(duration);
                } else {
                    targetAction.play(); // ç¢ºä¿å®ƒæ˜¯å•Ÿå‹•ç‹€æ…‹
                    // â­ é—œéµåˆ¤æ–·ï¼šåªæœ‰ç•¶é€™å€‹å‹•ä½œç›®å‰çš„æ¬Šé‡ä¸è¶³ï¼ˆä¾‹å¦‚ä¹‹å‰è¢«æ·¡å‡ºéï¼‰ï¼Œæˆ‘å€‘æ‰éœ€è¦æŠŠå®ƒæ·¡å…¥å›ä¾†
                    // é€™æ¨£å¦‚æœå®ƒæœ¬ä¾†å°±åœ¨å®Œç¾æ’­æ”¾ä¸­ï¼Œå°±ä¸æœƒå› ç‚ºå¤šé¤˜çš„ fadeIn è€Œæ‰å› A-pose é–ƒçˆ
                    if (targetAction.getEffectiveWeight() < 1) {
                        targetAction.fadeIn(duration);
                    }
                }
            }
        }
        // ============================================================================


        let chatHistory = [];
        let isSpeaking = false;
        let isOpeningRemark = false; // â­ æ–°å¢ï¼šæ¨™è¨˜æ˜¯å¦æ­£åœ¨è¬›é–‹å ´ç™½
        let currentEmotion = 'neutral';
        let isMuted = false;
        
        // Android èªéŸ³å„ªåŒ–
        let preferredVoice = null;
        
        function updateVoices() {
            if (!window.speechSynthesis) return;
            const voices = window.speechSynthesis.getVoices();
            // console.log("Voices loaded:", voices.length); // Debug
            if (voices.length > 0) {
                // Android å„ªå…ˆç­–ç•¥ï¼š
                // 1. æœ¬åœ° (localService) çš„ç¹é«”ä¸­æ–‡
                // 2. ä»»ä½•ç¹é«”ä¸­æ–‡ (zh-TW)
                // 3. ä»»ä½•ä¸­æ–‡ (zh) - é¿å…ç„¡è²
                preferredVoice = voices.find(v => (v.lang === 'zh-TW' || v.lang.includes('zh-TW')) && v.localService) ||
                                 voices.find(v => v.lang === 'zh-TW' || v.lang.includes('zh-TW')) ||
                                 voices.find(v => v.lang.includes('zh'));
                
                if (preferredVoice) {
                    logTTS(`é¸å®š: ${preferredVoice.name} (${preferredVoice.lang})`);
                } else {
                    logTTS(`âš ï¸ è­¦å‘Š: æœªæ‰¾åˆ°åˆé©ä¸­æ–‡èªéŸ³`);
                }
            } else {
                logTTS(`ç­‰å¾…èªéŸ³åŒ…è¼‰å…¥...`);
            }
        }
        
        // ç¢ºä¿èªéŸ³åˆ—è¡¨è¼‰å…¥ (Android éœ€è¦é‡è©¦)
        if (window.speechSynthesis) {
            window.speechSynthesis.onvoiceschanged = () => {
                logTTS("Event: voiceschanged");
                updateVoices();
            };
            updateVoices(); 
            // å¼·åˆ¶é‡è©¦æ©Ÿåˆ¶ï¼Œæ¯ç§’æª¢æŸ¥ä¸€æ¬¡ï¼Œç›´åˆ°æŠ“åˆ°èªéŸ³æˆ–éäº† 5 ç§’
            let voiceRetryCount = 0;
            const voiceInterval = setInterval(() => {
                updateVoices();
                voiceRetryCount++;
                if ((preferredVoice && preferredVoice.lang) || voiceRetryCount > 8) {
                    clearInterval(voiceInterval);
                    logTTS(`èªéŸ³æƒæçµæŸ (å˜—è©¦ ${voiceRetryCount} æ¬¡)`);
                }
            }, 1000);
        }

        let externalSystemPrompt = ""; 
        let externalKnowledge = "";
        let openingRemark = ""; // å„²å­˜é–‹å ´ç™½

        const isPreviewEnv = window.location.protocol === 'blob:' || window.location.protocol === 'file:';

        // --- å ´æ™¯åˆå§‹åŒ– ---
        const scene = new THREE.Scene();
        // ä¿®æ”¹ï¼šæ”¹ç‚ºæš–ç±³é»ƒè‰²èƒŒæ™¯ï¼Œèˆ‡ CSS äº®é‡‘èƒŒæ™¯å‘¼æ‡‰
        scene.background = new THREE.Color(0xfff8e1); 
        
        // éœ§æ°£æ”¹ç‚ºæš–ç±³è‰²
        scene.fog = new THREE.Fog(0xfff8e1, 5, 15);
        
        // ä¿®æ”¹ï¼šç¶²æ ¼ç·šæ”¹ç‚ºäº®ç´…è‰² (Red) å’Œ æ·±æ©˜è‰² (Deep Orange)ï¼Œåœ¨äº®åœ°æ¿ä¸Šæ¸…æ™°å¯è¦‹
        scene.add(new THREE.GridHelper(20, 20, 0xd32f2f, 0xffcc80)); 

        const camera = new THREE.PerspectiveCamera(30.0, window.innerWidth / window.innerHeight, 0.1, 20.0);
        
        // **ç›¸æ©Ÿä½ç½®é‚è¼¯ (æ”¯æ´è·³èˆæ™‚è‡ªå‹•é‹é¡ä¸¦é©æ‡‰ 3 äººé™£å‹)**
        function updateCameraPosition() {
            const aspect = window.innerWidth / window.innerHeight;
            if (aspect < 0.8) {
                // æ‰‹æ©Ÿç›´ç«‹æ¨¡å¼
                if (isDancing) {
                    // è·³èˆæ™‚ï¼šç›¸æ©Ÿå¤§å¹…æ‹‰é ã€è¦–é»é™ä½ï¼Œç¢ºä¿åœ°æ¿å‹•ä½œèˆ‡å…¨èº«å…¥é¡ (å›  3 äººç¸±æ·±è¼ƒå¤§ï¼Œé€€æ›´é )
                    camera.position.set(0.0, 1.2, 8.5); 
                    controls.target.set(0.0, 0.8, -0.5); // ç„æº–é™£å‹ä¸­å¿ƒ
                } else {
                    // å°è©±æ™‚ï¼šç›¸æ©Ÿæ‹‰è¿‘ã€è¦–é»æé«˜ï¼Œç‰¹å¯«ä¸ŠåŠèº«
                    camera.position.set(0.0, 1.35, 3.2); 
                    controls.target.set(0.0, 1.2, -0.5);
                }
            } else {
                // æ¡Œé¢å¯¬è¢å¹•æ¨¡å¼
                if (isDancing) {
                     camera.position.set(0.0, 1.0, 7.0);
                     controls.target.set(0.0, 0.8, -0.5);
                } else {
                     // â­â­â­ ä¿®æ”¹ï¼šå°‡ PC é è¨­æ¨¡å¼çš„æ”å½±æ©Ÿå¤§å¹…æ‹‰è¿‘ï¼Œä¸¦ç¨å¾®é™ä½è¦–è§’ä¸­å¿ƒ
                     camera.position.set(0.0, 1.3, 2.8); // å°‡ Z è»¸å¾ 3.8 ç¸®çŸ­è‡³ 2.8 è®“è§’è‰²æ›´é è¿‘
                     controls.target.set(0.0, 1.1, -0.5); 
                }
            }
            camera.updateProjectionMatrix();
            controls.update();
        }

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
        document.body.appendChild(renderer.domElement);

        // ç‡ˆå…‰å„ªåŒ–ï¼šæš–è‰²å…‰ (å½±éŸ¿ Layer 0)
        const directionalLight = new THREE.DirectionalLight(0xffedd5, 1.5); // æš–ç™½å…‰
        directionalLight.position.set(-1.0, 2.0, 1.0).normalize();
        scene.add(directionalLight);
        
        // è£œå…‰ (é‡‘è‰²) (å½±éŸ¿ Layer 0)
        const fillLight = new THREE.DirectionalLight(0xffd700, 0.6);
        fillLight.position.set(1.0, 1.0, 1.0).normalize();
        scene.add(fillLight);
        
        scene.add(new THREE.AmbientLight(0xffffff, 0.5));

        // â­â­â­ æ–°å¢ï¼šç¬¬ä¸‰è§’è‰² (David) çš„å°ˆå±¬èšå…‰ç‡ˆç¾¤çµ„ â­â­â­
        // â­ ä¿®æ”¹ï¼šèª¿é™é ­éƒ¨èšå…‰ç‡ˆçš„äº®åº¦ï¼Œä¿ç•™æŸ”å’Œå¥½æ°£è‰²ä½†é¿å…éæ›
        const dLight1 = new THREE.SpotLight(0xfff5e6, 0.7); // â­ å°‡äº®åº¦ç”± 0.5 å¾®èª¿è‡³ 0.7
        dLight1.angle = Math.PI / 2.5; // æ”¾å¯¬è§’åº¦ï¼Œè®“å…‰ç·šå‡å‹»è¦†è“‹æ•´å€‹è‡‰é¾
        dLight1.penumbra = 0.8; // å…‰ç·šé‚Šç·£éæ¸¡æ›´æŸ”å’Œè‡ªç„¶
        dLight1.distance = 2.5; // ç¨å¾®å»¶é•·ç…§å°„è·é›¢
        dLight1.decay = 1.5; // æ¸›ç·©å…‰ç·šè¡°æ¸›ï¼Œè®“è‡‰éƒ¨ç«‹é«”æ„Ÿæ›´å¥½
        scene.add(dLight1); scene.add(dLight1.target);

        // â­â­â­ 2. è¡£æœå°ˆå±¬èšå…‰ç‡ˆ (å¾€ä¸‹æ‰“å…‰ï¼Œçµ•å°é¿é–‹è‡‰éƒ¨) â­â­â­
        const dLightBody = new THREE.SpotLight(0xffffff, 120.0); // â­ ä¾è¦æ±‚å†æ¬¡åŠ å¼·ç¶ ç·šèšå…‰ç‡ˆäº®åº¦ (ç”± 60.0 æå‡è‡³ 120.0)
        dLightBody.angle = Math.PI / 7.0; // â­ é—œéµä¿®æ­£ï¼šæ”¶çª„ç…§å°„è§’åº¦ï¼Œè®“å…‰éŒæ›´é›†ä¸­ï¼Œé¿å…å‘ä¸Šæº¢å‡ºç…§åˆ°è‡‰
        dLightBody.penumbra = 0.5;
        dLightBody.distance = 1.5; // ç¸®çŸ­è·é›¢ï¼Œç¢ºä¿ä¸æ³¢åŠä»–äºº
        dLightBody.decay = 1.0;
        scene.add(dLightBody); scene.add(dLightBody.target);

        // â­â­â­ 3. è¤²å­å°ˆå±¬èšå…‰ç‡ˆ (å¾€ä¸‹æ‰“å…‰ï¼Œå°ˆæ³¨ä¸‹åŠèº«) â­â­â­
        const dLightLegs = new THREE.SpotLight(0xffffff, 0.5); // â­ ä¾è¦æ±‚é€²ä¸€æ­¥é™ä½è—ç·šèšå…‰ç‡ˆäº®åº¦ (ç”± 3.0 é™ä½è‡³ 0.5)
        dLightLegs.angle = Math.PI / 4.0;
        dLightLegs.penumbra = 0.5;
        dLightLegs.distance = 1.5;
        dLightLegs.decay = 1.0;
        scene.add(dLightLegs); scene.add(dLightLegs.target);


        // --- æ–°å¹´ç‰¹æ•ˆï¼šé£„è½é‡‘ç²‰/ç´…ç´™å±‘ ---
        let particlesMesh;
        const particlesCount = 300; // ç²’å­æ•¸é‡
        function createFestiveParticles() {
            const geometry = new THREE.BufferGeometry();
            const posArray = new Float32Array(particlesCount * 3);
            const colorArray = new Float32Array(particlesCount * 3);
            
            for(let i = 0; i < particlesCount * 3; i+=3) {
                // éš¨æ©Ÿä½ç½®
                posArray[i] = (Math.random() - 0.5) * 15; // X
                posArray[i+1] = Math.random() * 10;       // Y
                posArray[i+2] = (Math.random() - 0.5) * 15; // Z

                // ä¿®æ”¹ï¼šé¡è‰²å°æ¯”åº¦èª¿æ•´
                if (Math.random() > 0.5) {
                    // æ­£ç´…è‰² (åœ¨æ·ºè‰²èƒŒæ™¯å¾ˆæ˜é¡¯)
                    colorArray[i] = 0.9;
                    colorArray[i+1] = 0.1;
                    colorArray[i+2] = 0.1;
                } else {
                    // æ·±é‡‘è‰² (é¿å…å¤ªäº®çœ‹ä¸è¦‹)
                    colorArray[i] = 0.8;
                    colorArray[i+1] = 0.6;
                    colorArray[i+2] = 0.0;
                }
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.15, // ç¨å¾®åŠ å¤§ç²’å­
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                // blending: THREE.AdditiveBlending // åœ¨æ·ºè‰²èƒŒæ™¯å–æ¶ˆ Additiveï¼Œä¸ç„¶æœƒè®Šç™½
            });
            
            particlesMesh = new THREE.Points(geometry, material);
            scene.add(particlesMesh);
        }
        createFestiveParticles();

        // --- æ§åˆ¶å™¨è¨­å®š (OrbitControls) ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enablePan = true; 
        controls.screenSpacePanning = true; 
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 1.0; 
        controls.maxDistance = 8.0;
        controls.maxPolarAngle = Math.PI / 2 + 0.1; 
        controls.minPolarAngle = Math.PI / 3;

        updateCameraPosition(); 

        // --- æª”æ¡ˆè®€å– (å·¦ä¸Šè§’ç‹€æ…‹) ---
        async function loadExternalData() {
            const statusText = document.getElementById('status-text');
            const fileStatusDiv = document.getElementById('file-status');
            
            let promptStatusHTML = '<span class="icon-loading">â—</span> Prompt';
            let kbStatusHTML = '<span class="icon-loading">â—</span> KB';

            const renderStatus = () => {
                fileStatusDiv.innerHTML = `
                    <div class="file-status-item">${promptStatusHTML}</div>
                    <div class="file-status-item">${kbStatusHTML}</div>
                `;
            };
            
            renderStatus();

            try {
                statusText.innerText = "è®€å–è§’è‰²è¨­å®š...";
                const res = await fetch(`./Prompt.txt?t=${Date.now()}`);
                if (res.ok) {
                    externalSystemPrompt = await res.text();
                    promptStatusHTML = '<span class="icon-ok">âœ“</span> Prompt OK';
                } else {
                    promptStatusHTML = '<span class="icon-fail">âœ—</span> Prompt Def';
                }
            } catch (e) {
                promptStatusHTML = '<span class="icon-fail">âœ—</span> Prompt Err';
            }
            renderStatus();

            statusText.innerText = "è®€å–é›²ç«¯çŸ¥è­˜åº«...";
            let fileIndex = 1;
            let keepLoading = true;
            let loadedCount = 0;
            
            while (keepLoading) {
                const fileNameRoot = `KnowledgeBase${String(fileIndex).padStart(2, '0')}.txt`;
                const fileNameFolder = `KnowledgeBase/KnowledgeBase${String(fileIndex).padStart(2, '0')}.txt`;
                
                kbStatusHTML = `<span class="icon-loading">â—</span> æƒæ KB${String(fileIndex).padStart(2,'0')}...`;
                renderStatus();

                try {
                    let res = await fetch(`./${fileNameFolder}?t=${Date.now()}`);
                    let usedPath = fileNameFolder;
                    
                    if (!res.ok) {
                         // å˜—è©¦å¾æ ¹ç›®éŒ„è®€å–
                         try {
                             const resRoot = await fetch(`./${fileNameRoot}?t=${Date.now()}`);
                             if (resRoot.ok) {
                                 res = resRoot;
                                 usedPath = fileNameRoot;
                             }
                         } catch(e) {}
                    }

                    if (res.ok) {
                        const text = await res.text();
                        if (text.trim().length > 0) {
                            if (fileIndex === 1) {
                                openingRemark = text;
                            }
                            externalKnowledge += `\n\nã€KB: ${usedPath}ã€‘\n${text}`;
                            loadedCount++;
                            fileIndex++;
                        } else {
                            fileIndex++;
                        }
                    } else {
                        // 404 is expected when no more files
                        keepLoading = false;
                    }
                } catch (e) {
                    keepLoading = false;
                }
            }

            if (loadedCount > 0) {
                kbStatusHTML = `<span class="icon-ok">âœ“</span> KB x${loadedCount}`;
            } else {
                kbStatusHTML = `<span class="icon-fail">âœ—</span> No KB`;
            }
            renderStatus();
            statusText.innerText = "ç³»çµ±å°±ç·’ï¼";
        }

        // --- VRM è¼‰å…¥ (ä¿®æ”¹ï¼šåŒæ™‚è¼‰å…¥å¤šå€‹è§’è‰²) ---
        const loader = new GLTFLoader();
        loader.crossOrigin = 'anonymous';
        // è¨»å†Š VRM èˆ‡ VRM å‹•ç•«æ’ä»¶
        loader.register((parser) => new VRMLoaderPlugin(parser));
        loader.register((parser) => new VRMAnimationLoaderPlugin(parser));

        // ä½¿ç”¨ Promise.all åŒæ™‚è¼‰å…¥æ‰€æœ‰æ¨¡å‹
        const loadPromises = VRM_MODELS.map((url, index) => {
            return new Promise((resolve) => {
                loader.load(url, (gltf) => {
                    const vrm = gltf.userData.vrm;
                    VRMUtils.rotateVRM0(vrm);
                    scene.add(vrm.scene);
                    
                    // --- â­â­â­ éšŠå½¢æ’åˆ— (é˜²ç©¿æ¨¡ä¸”ç¾è§€) â­â­â­ ---
                    if (index === 0) {
                        // ç¬¬ä¸€å€‹è§’è‰²ï¼šé è¿‘ä¸­ç·šï¼Œç¨å¾®å¾€å‰
                        vrm.scene.position.set(-0.25, 0.0, 0.4);
                    } else if (index === 1) {
                        // ç¬¬äºŒå€‹è§’è‰²ï¼šé è¿‘ä¸­ç·šï¼Œç¨å¾®å¾€å¾Œ (æ‹‰å¤§èˆ‡è§’è‰² 1 è·é›¢)
                        vrm.scene.position.set(0.25, 0.0, -0.4);
                    } else if (index === 2) {
                        // ç¬¬ä¸‰å€‹è§’è‰²ï¼šåœ¨ä¸­ç·šä¸Šï¼Œå‘å¾Œæ‹‰é–‹èˆ‡è§’è‰² 2 è·é›¢ (ä¿æŒè·³èˆä¸ç©¿æ¨¡)
                        vrm.scene.position.set(0.0, 0.0, -1.5);
                        
                        // â­ æ¢å¾©æè³ªæäº®ï¼šé€™æ˜¯è®“è§’è‰²ã€Œå®¹å…‰ç…¥ç™¼ã€çš„é—œéµï¼Œå¾æ ¹æœ¬è§£æ±ºè¡£æœèˆ‡çš®è†šæš—æ²‰
                        vrm.scene.traverse((object) => {
                            if (object.isMesh) {
                                const materials = Array.isArray(object.material) ? object.material : [object.material];
                                materials.forEach((mat) => {
                                    if (mat.color) {
                                        mat.color.multiplyScalar(1.1); // å¾®èª¿åº•è‰²ï¼Œå¾1.2é™è‡³1.1ï¼Œé¿å…å…‰ç·šæ‰“ä¸Šå¾Œéæ›
                                    }
                                });
                            }
                        });
                    }

                    // èª¿æ•´æ‰‹è‡‚
                    const leftUpperArm = vrm.humanoid.getNormalizedBoneNode('leftUpperArm');
                    const rightUpperArm = vrm.humanoid.getNormalizedBoneNode('rightUpperArm');
                    if (leftUpperArm) { leftUpperArm.rotation.z = -1.1; leftUpperArm.rotation.x = 0.15; }
                    if (rightUpperArm) { rightUpperArm.rotation.z = 1.1; rightUpperArm.rotation.x = 0.15; }

                    // --- é‡è¦ä¿®æ”¹ï¼šç‚ºæ¯å€‹è§’è‰²é å…ˆå»ºç«‹ Mixerï¼Œé¿å…é‡è¤‡å»ºç«‹ ---
                    const mixer = new THREE.AnimationMixer(vrm.scene);
                    
                    // â­ FIX: ç¢ºä¿ userData å­˜åœ¨ï¼Œé¿å…å´©æ½° â­
                    if (!vrm.userData) {
                        vrm.userData = {};
                    }
                    vrm.userData.mixer = mixer;
                    
                    mixers.push(mixer); // åŠ å…¥å…¨åŸŸ mixers ä»¥ä¾¿ update

                    // ä¿®æ”¹ï¼šä¾ç´¢å¼•æŒ‡å®šé™£åˆ—ä½ç½®ï¼Œç¢ºä¿é †åºæ­£ç¢º
                    currentVrms[index] = vrm; 
                    startBlinking(vrm);    // å€‹åˆ¥å•Ÿå‹•çœ¨çœ¼
                    resolve();
                }, undefined, (e) => {
                    console.error("VRM Load Error:", e);
                    resolve(); // å¤±æ•—ä¹Ÿ resolveï¼Œé¿å…å¡ä½
                });
            });
        });

        // ç¨ç«‹è¼‰å…¥èªªè©±å‹•ä½œ
        function loadTalkAnimations() {
            const pC = new Promise((resolve) => {
                loader.load(TALK_ANIMATION_C_URL, (gltf) => {
                    const vrmAnimations = gltf.userData.vrmAnimations;
                    if (vrmAnimations && vrmAnimations.length > 0 && currentVrms[0]) {
                         const clip = createVRMAnimationClip(vrmAnimations[0], currentVrms[0]);
                         talkingActionC = currentVrms[0].userData.mixer.clipAction(clip);
                         talkingActionC.loop = THREE.LoopRepeat;
                    }
                    resolve();
                }, undefined, (e) => { console.error("Talk C Anim Error:", e); resolve(); });
            });

            const pW = new Promise((resolve) => {
                loader.load(TALK_ANIMATION_W_URL, (gltf) => {
                    const vrmAnimations = gltf.userData.vrmAnimations;
                    if (vrmAnimations && vrmAnimations.length > 0 && currentVrms[1]) {
                         const clip = createVRMAnimationClip(vrmAnimations[0], currentVrms[1]);
                         talkingActionW = currentVrms[1].userData.mixer.clipAction(clip);
                         talkingActionW.loop = THREE.LoopRepeat;
                    }
                    resolve();
                }, undefined, (e) => { console.error("Talk W Anim Error:", e); resolve(); });
            });

            const pD = new Promise((resolve) => {
                loader.load(TALK_ANIMATION_D_URL, (gltf) => {
                    const vrmAnimations = gltf.userData.vrmAnimations;
                    if (vrmAnimations && vrmAnimations.length > 0 && currentVrms[2]) {
                         const clip = createVRMAnimationClip(vrmAnimations[0], currentVrms[2]);
                         talkingActionD = currentVrms[2].userData.mixer.clipAction(clip);
                         talkingActionD.loop = THREE.LoopRepeat;
                    }
                    resolve();
                }, undefined, (e) => { console.error("Talk D Anim Error:", e); resolve(); });
            });

            return Promise.all([pC, pW, pD]);
        }

        // â­â­â­ ç¨ç«‹è¼‰å…¥é–’ç½®å‹•ä½œ (Taunt & Idle) â­â­â­
        function loadIdleAnimations() {
            const pC = new Promise((resolve) => {
                loader.load(IDLE_ANIMATION_C_URL, (gltf) => {
                    const vrmAnimations = gltf.userData.vrmAnimations;
                    if (vrmAnimations && vrmAnimations.length > 0 && currentVrms[0]) {
                         const clip = createVRMAnimationClip(vrmAnimations[0], currentVrms[0]);
                         idleActionC = currentVrms[0].userData.mixer.clipAction(clip);
                         idleActionC.loop = THREE.LoopRepeat;
                         idleActionC.play();
                    }
                    resolve();
                }, undefined, (e) => { console.error("Idle C Anim Error:", e); resolve(); });
            });

            const pW = new Promise((resolve) => {
                loader.load(IDLE_ANIMATION_W_URL, (gltf) => {
                    const vrmAnimations = gltf.userData.vrmAnimations;
                    if (vrmAnimations && vrmAnimations.length > 0 && currentVrms[1]) {
                         const clip = createVRMAnimationClip(vrmAnimations[0], currentVrms[1]);
                         idleActionW = currentVrms[1].userData.mixer.clipAction(clip);
                         idleActionW.loop = THREE.LoopRepeat;
                         idleActionW.play();
                    }
                    resolve();
                }, undefined, (e) => { console.error("Idle W Anim Error:", e); resolve(); });
            });

            const pD = new Promise((resolve) => {
                loader.load(IDLE_ANIMATION_D_URL, (gltf) => {
                    const vrmAnimations = gltf.userData.vrmAnimations;
                    if (vrmAnimations && vrmAnimations.length > 0 && currentVrms[2]) {
                         const clip = createVRMAnimationClip(vrmAnimations[0], currentVrms[2]);
                         idleActionD = currentVrms[2].userData.mixer.clipAction(clip);
                         idleActionD.loop = THREE.LoopRepeat;
                         idleActionD.play();
                    }
                    resolve();
                }, undefined, (e) => { console.error("Idle D Anim Error:", e); resolve(); });
            });

            return Promise.all([pC, pW, pD]);
        }

        Promise.all([...loadPromises, loadExternalData()]).then(() => {
            // å®šç¾©å•Ÿå‹•å‡½å¼
            const handleStart = (e) => {
                // 1. UI First: ç¢ºä¿ç•«é¢å…ˆæœ‰åæ‡‰
                const loadingScreen = document.getElementById('loading-screen');
                if (loadingScreen.style.opacity === '0') return; // é¿å…é‡è¤‡è§¸ç™¼

                loadingScreen.style.opacity = 0;
                loadingScreen.style.pointerEvents = 'none'; // é˜²æ­¢é€£é»
                setTimeout(() => loadingScreen.style.display = 'none', 500);
                
                // ç¢ºä¿èªéŸ³åˆ—è¡¨å·²è¼‰å…¥
                updateVoices();

                // 2. Audio Unlock (ä¿®æ­£ï¼šç›´æ¥åœ¨é»æ“Šäº‹ä»¶ä¸­å‘¼å« speakï¼Œä¸ä½¿ç”¨ setTimeoutï¼Œä»¥ç¬¦åˆç€è¦½å™¨è‡ªå‹•æ’­æ”¾ç­–ç•¥)
                const introText = openingRemark || "ï¼ˆæœªè®€å–åˆ° KnowledgeBase01.txtï¼Œè«‹æª¢æŸ¥æª”æ¡ˆï¼‰";
                
                isOpeningRemark = true; // â­ æ¨™è¨˜é–‹å§‹è¬›é–‹å ´ç™½

                // ç›´æ¥æ’­æ”¾ï¼Œä¸è¦å»¶é²ï¼Œå¦å‰‡åœ¨è¡Œå‹•è£ç½®æœƒè¢«æ“‹
                speak(introText);

                // 3. Logic
                addMessage(introText, 'ai');
                
                chatHistory.push({ role: "model", parts: [{ text: introText }] });
                
                testApiConnection();
            };

            // ç¢ºä¿èªªè©±å’Œé–’ç½®å‹•ä½œè¼‰å…¥
            Promise.all([loadTalkAnimations(), loadIdleAnimations()]).then(() => {
                const loaderEl = document.getElementById('loader');
                const statusText = document.getElementById('status-text');
                const startBtn = document.getElementById('start-btn');
                
                loaderEl.style.display = 'none';
                statusText.innerText = `æº–å‚™å®Œæˆ (${currentVrms.length} äºº)`;
                startBtn.style.display = 'block';
                
                // æ›´æ–°ç›¸æ©Ÿä»¥å°æº–é™£å‹ä¸­å¿ƒ
                updateCameraPosition();
                
                // ç¶å®šäº‹ä»¶ï¼šåœ¨é€™è£¡ startBtn è‚¯å®šå·²å®šç¾©
                startBtn.addEventListener('click', handleStart);
                startBtn.addEventListener('touchend', (e) => {
                    e.preventDefault(); // é˜²æ­¢è§¸ç™¼ click å°è‡´é›™é‡è§¸ç™¼ï¼Œä¸¦æé«˜åæ‡‰é€Ÿåº¦
                    handleStart(e);
                });
            });
        });

        // --- å‹•ç•« ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            const elapsedTime = clock.elapsedTime;

            // ç²’å­å‹•ç•« (ç·©ç·©é£„è½)
            if (particlesMesh) {
                particlesMesh.rotation.y += 0.001; // æ•´é«”æ—‹è½‰
                const positions = particlesMesh.geometry.attributes.position.array;
                for(let i = 1; i < particlesCount * 3; i+=3) {
                    positions[i] -= 0.015; // å‘ä¸‹é£„è½
                    // å¦‚æœæ‰åˆ°åœ°æ¿ä»¥ä¸‹ï¼Œé‡ç½®åˆ°ä¸Šæ–¹éš¨æ©Ÿä½ç½®
                    if (positions[i] < 0) {
                        positions[i] = 10;
                    }
                }
                particlesMesh.geometry.attributes.position.needsUpdate = true;
            }

            // æ›´æ–°æ‰€æœ‰ å‹•ç•«æ··åˆå™¨
            mixers.forEach(mixer => mixer.update(deltaTime));

            // æ›´æ–°æ‰€æœ‰ VRM è§’è‰²
            currentVrms.forEach((vrm, index) => {
                if(!vrm) return; // é¿å…é™£åˆ—æœ‰ç©ºæ´
                vrm.update(deltaTime);
                
                // â­â­â­ è®“ç¬¬ä¸‰è§’è‰² (David) çš„å°ˆå±¬èšå…‰ç‡ˆç„¡ç¸«è·Ÿéš¨ä»–ç§»å‹•èˆ‡ç¿»è½‰ â­â­â­
                if (index === 2 && typeof dLight1 !== 'undefined') {
                    const spine = vrm.humanoid.getNormalizedBoneNode('spine');
                    const hips = vrm.humanoid.getNormalizedBoneNode('hips');
                    if (spine && hips) {
                        // å–å‡ºè„Šæ¤ä½ç½®èˆ‡ 3D æ—‹è½‰è§’åº¦ (å››å…ƒæ•¸)
                        const tPos = new THREE.Vector3();
                        spine.getWorldPosition(tPos);
                        const spineQuat = new THREE.Quaternion();
                        spine.getWorldQuaternion(spineQuat);

                        // å–å‡ºéª¨ç›†ä½ç½®èˆ‡ 3D æ—‹è½‰è§’åº¦ (å››å…ƒæ•¸)
                        const hipsPos = new THREE.Vector3();
                        hips.getWorldPosition(hipsPos);
                        const hipsQuat = new THREE.Quaternion();
                        hips.getWorldQuaternion(hipsQuat);

                        // â­ æ ¸å¿ƒä¿®æ­£ï¼šå±€éƒ¨ Z è»¸çš„è² æ–¹å‘ (-Z) æ‰æ˜¯è§’è‰²çš„ã€Œæ­£å‰æ–¹ã€ï¼

                        // 1. é ­éƒ¨ç‡ˆå…‰ (éš±è—ç·šæ¡†)
                        const d1PosOffset = new THREE.Vector3(0, 0.85, -0.4).applyQuaternion(spineQuat); // å…‰æºç¨å¾®å¾€é æ‹‰ä¸€é»ï¼Œè®“æ‰“å…‰æ›´æŸ”å’Œ
                        const d1TargetOffset = new THREE.Vector3(0, 0.65, 0).applyQuaternion(spineQuat); // ç›®æ¨™ç¨å¾®ä¸‹ç§»å°æº–è‡‰éƒ¨æ­£ä¸­å¿ƒ
                        dLight1.position.copy(tPos).add(d1PosOffset);
                        dLight1.target.position.copy(tPos).add(d1TargetOffset);

                        // â­ 2. è¡£æœå…‰ (éš±è—ç·šæ¡†)ï¼šè·Ÿéš¨è„Šæ¤ä¸€èµ·å½è…°èˆ‡ç¿»è½‰
                        const bodyPosOffset = new THREE.Vector3(0, 0.3, -0.7).applyQuaternion(spineQuat); // æ”¹ç‚ºè² å€¼
                        const bodyTargetOffset = new THREE.Vector3(0, 0.15, 0).applyQuaternion(spineQuat);
                        dLightBody.position.copy(tPos).add(bodyPosOffset);
                        dLightBody.target.position.copy(tPos).add(bodyTargetOffset);

                        // â­ 3. è¤²å­å…‰ (éš±è—ç·šæ¡†)ï¼šè·Ÿéš¨ä¸‹åŠèº«éª¨ç›†ä¸€èµ·æ—‹è½‰
                        const legsPosOffset = new THREE.Vector3(0, 0, -0.8).applyQuaternion(hipsQuat); // æ”¹ç‚ºè² å€¼
                        const legsTargetOffset = new THREE.Vector3(0, -0.5, 0).applyQuaternion(hipsQuat);
                        dLightLegs.position.copy(hipsPos).add(legsPosOffset);
                        dLightLegs.target.position.copy(hipsPos).add(legsTargetOffset);
                    }
                }

                // å¦‚æœæ²’æœ‰åœ¨è·³èˆï¼Œæ‰åŸ·è¡Œè‡ªç„¶çš„å‘¼å¸å‹•ä½œ
                if (!isDancing) {
                    const isC = (index === 0);
                    const isW = (index === 1);
                    const isD = (index === 2);
                    let playBreathing = true;

                    // æœ‰é–’ç½®æˆ–èªªè©±å‹•ä½œæ™‚ä¸è§¸ç™¼é è¨­å‘¼å¸ï¼Œé¿å…å‹•ä½œè¡çª
                    if (isC && (idleActionC || (isSpeaking && talkingActionC))) playBreathing = false;
                    if (isW && (idleActionW || (isSpeaking && talkingActionW))) playBreathing = false;
                    if (isD && (idleActionD || (isSpeaking && talkingActionD))) playBreathing = false;

                    if (playBreathing) {
                        const spine = vrm.humanoid.getNormalizedBoneNode('spine');
                        if (spine) {
                            spine.rotation.x = Math.sin(elapsedTime * 1.5) * 0.02;
                            spine.rotation.y = Math.sin(elapsedTime * 0.8) * 0.02;
                        }
                    }
                }

                // â­ èªªè©±å˜´å‹åŒæ­¥ (ä¿®æ”¹ï¼šé™å®šåªæœ‰ç¬¬2å€‹è§’è‰² index === 1 æ‰æœƒå°å˜´)
                if (isSpeaking && !isMuted) {
                    if (index === 1) {
                        const s = Math.sin(elapsedTime * 18); // èªªè©±é€Ÿåº¦å¾®èª¿
                        vrm.expressionManager.setValue('aa', (s + 1) / 2 * 0.6);
                    } else if (isOpeningRemark) {
                        if (index === 0) {
                            // â­ é–‹å ´ç™½æ™‚ï¼Œç¬¬ 1 ä½è§’è‰²ï¼šé–‹å¿ƒå¤§ç¬‘ã€å¼µå¤§å˜´å·´
                            vrm.expressionManager.setValue('happy', 1.0);
                            vrm.expressionManager.setValue('aa', 0.8);
                        } else if (index === 2) {
                            // â­ é–‹å ´ç™½æ™‚ï¼Œç¬¬ 3 ä½è§’è‰²ï¼šå¾®ç¬‘ (ä¿æŒå˜´å·´é–‰åˆ)
                            vrm.expressionManager.setValue('happy', 0.8); 
                            const currentVal = vrm.expressionManager.getValue('aa');
                            vrm.expressionManager.setValue('aa', THREE.MathUtils.lerp(currentVal, 0, 0.2));
                        }
                    } else {
                        const currentVal = vrm.expressionManager.getValue('aa');
                        vrm.expressionManager.setValue('aa', THREE.MathUtils.lerp(currentVal, 0, 0.2));
                    }
                } else {
                    const currentVal = vrm.expressionManager.getValue('aa');
                    vrm.expressionManager.setValue('aa', THREE.MathUtils.lerp(currentVal, 0, 0.2));
                }
            });

            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // ä¿®æ”¹ï¼šæ”¯æ´å¤šè§’è‰²ç¨ç«‹çœ¨çœ¼
        function startBlinking(vrm) {
            if(!vrm) return;
            const blinkLoop = () => {
                if (!window.actionActive) {
                    setTimeout(() => {
                        vrm.expressionManager.setValue('blink', 1);
                        setTimeout(() => {
                            vrm.expressionManager.setValue('blink', 0);
                            blinkLoop();
                        }, 120);
                    }, Math.random() * 3000 + 2000); // éš¨æ©Ÿæ™‚é–“ï¼Œè®“å…©äººçœ¨çœ¼ä¸åŒæ­¥ï¼Œæ›´è‡ªç„¶
                } else {
                    setTimeout(blinkLoop, 1000);
                }
            };
            blinkLoop();
        }

        // --- è·³èˆé‚è¼¯ (å›åˆåˆ¶ï¼šå¥‡æ•¸å›åˆé½Šèˆï¼Œå¶æ•¸å›åˆ Battle) ---
        const danceBtn = document.getElementById('dance-btn');
        
        // è¼”åŠ©å‡½å¼ï¼šé™£åˆ—æ´—ç‰Œ
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // æ ¸å¿ƒé‚è¼¯ï¼šç”¢ç”Ÿè©²å›åˆçš„å‹•ä½œé †åº
        function generateSequences(round) {
            vrmDanceSequences = [];
            const baseSequence = [0, 1, 2, 3]; // å°æ‡‰ DANCE_URLS çš„ç´¢å¼•
            
            // ç‚ºæ¯å€‹è§’è‰²ç”¢ç”Ÿå‹•ä½œè¡¨
            currentVrms.forEach(() => {
                if (round % 2 !== 0) {
                    // å¥‡æ•¸å›åˆï¼šå›ºå®šé †åºï¼Œé½Šèˆ
                    vrmDanceSequences.push([...baseSequence]);
                } else {
                    // å¶æ•¸å›åˆï¼šéš¨æ©Ÿé †åºï¼ŒBattle
                    vrmDanceSequences.push(shuffleArray([...baseSequence]));
                }
            });
            
            // Debug: é¡¯ç¤ºè©²å›åˆæ¨¡å¼
            const mode = round % 2 !== 0 ? "é½Šèˆ (Sync)" : "Battle (Random)";
            console.log(`[Round ${round}] ${mode}`, vrmDanceSequences);
        }

        // â­â­â­ çµ‚æ¥µé˜²å‘†ï¼šåš´æ ¼ç®¡ç† Three.js Mixer çš„äº‹ä»¶ç›£è½å™¨ï¼Œé˜²æ­¢è¨˜æ†¶é«”æ´©æ¼èˆ‡å‹•ä½œå¿«è½‰ â­â­â­
        function assignMixerListener(vrm, index, listener) {
            if (!vrm || !vrm.userData.mixer) return;
            if (currentDanceListeners[index]) {
                vrm.userData.mixer.removeEventListener('finished', currentDanceListeners[index]);
            }
            currentDanceListeners[index] = listener;
            vrm.userData.mixer.addEventListener('finished', listener);
        }

        function clearAllMixerListeners() {
            currentVrms.forEach((vrm, i) => {
                if (vrm && vrm.userData.mixer && currentDanceListeners[i]) {
                    vrm.userData.mixer.removeEventListener('finished', currentDanceListeners[i]);
                }
                currentDanceListeners[i] = null;
            });
        }

        // â­â­â­ ä¿®æ­£ï¼šå°‡è¼‰å…¥é‚è¼¯ç¨ç«‹ç‚º loadDanceAssetsï¼Œä»¥ä¾¿ AI æŒ‡ä»¤å‘¼å« â­â­â­
        async function loadDanceAssets() {
            // å¦‚æœå·²ç¶“è¼‰å…¥éå‹•ç•«ï¼Œç›´æ¥è¿”å›
            if (danceActionsMap.length > 0) {
                return;
            }

            if (currentVrms.length === 0) return;

            addMessage("æº–å‚™ç†±èˆè³‡æ–™ä¸­...", "system");
            
            // ä½¿ç”¨ Promise.all ä¸€æ¬¡è¼‰å…¥æ‰€æœ‰èˆæ­¥
            const promises = DANCE_URLS.map(url => new Promise((resolve, reject) => {
                loader.load(url, (gltf) => {
                     const vrmAnimations = gltf.userData.vrmAnimations;
                     if (vrmAnimations && vrmAnimations.length > 0) {
                         resolve(vrmAnimations[0]);
                     } else {
                         resolve(null);
                     }
                }, undefined, (e) => {
                    console.error("Dance Load Error:", url, e);
                    resolve(null); // éŒ¯èª¤æ™‚å›å‚³ nullï¼Œé¿å…å¡æ­»
                });
            }));

            const animationClips = await Promise.all(promises);
            // éæ¿¾æ‰è¼‰å…¥å¤±æ•—çš„
            const validClips = animationClips.filter(c => c);
            
            if (validClips.length === 0) {
                addMessage("èˆè¹ˆè¼‰å…¥å¤±æ•—", "system");
                return;
            }

            // ç‚ºæ¯å€‹èˆæ­¥ã€æ¯å€‹è§’è‰²å»ºç«‹ Action
            validClips.forEach(clipData => {
                const actionsForThisDance = [];
                currentVrms.forEach(vrm => {
                    // FIX: å®‰å…¨è®€å– userData
                    if (!vrm || !vrm.userData || !vrm.userData.mixer) return;
                    
                    // å»ºç«‹ Clip èˆ‡ Action
                    const clip = createVRMAnimationClip(clipData, vrm);
                    const action = vrm.userData.mixer.clipAction(clip);
                    actionsForThisDance.push(action);
                });
                danceActionsMap.push(actionsForThisDance);
            });
            
            addMessage("èˆæ­¥è¼‰å…¥å®Œæˆï¼ŒLet's Dance!", "system");
            console.log("Assets Loaded!");
        }

        // ä¿®æ”¹å¾Œçš„æŒ‰éˆ•é‚è¼¯ï¼šå‘¼å« loadDanceAssets å¾Œå† startDance
        async function loadAndPlayDance() {
            await loadDanceAssets();
            if (danceActionsMap.length > 0) {
                startDance();
            }
        }

        // é–‹å§‹è·³èˆæµç¨‹
        function startDance() {
            isDancing = true;
            danceBtn.classList.add('active'); 
            
            // â­â­â­ å¼·åˆ¶åœæ­¢èªªè©± (ä¿®æ­£) â­â­â­
            if (isSpeaking) {
                window.speechSynthesis.cancel();
                isSpeaking = false;
            }

            // è§¸ç™¼å‹•æ…‹é‹é¡
            updateCameraPosition();
            
            // æ’­æ”¾ BGM
            bgm.currentTime = 0;
            bgm.muted = isMuted;
            
            // â­â­â­ FIX: å¢å¼·çš„ BGM æ’­æ”¾ (é˜²æ­¢ä¸­æ–·éŒ¯èª¤) â­â­â­
            const playPromise = bgm.play();
            if (playPromise !== undefined) {
                playPromise.catch(error => {
                    console.error("BGM Play Error:", error);
                    // è‡ªå‹•é‡è©¦æˆ–å¿½ç•¥
                });
            }

            // é‡ç½®ç‹€æ…‹åˆ°ç¬¬ 1 å›åˆ
            danceRound = 1;
            danceStepIndex = 0;

            // ç”¢ç”Ÿç¬¬ 1 å›åˆçš„å‹•ä½œè¡¨
            generateSequences(danceRound);

            // æ¸…ç†ä»»ä½•æ®˜ç•™çš„ç›£è½å™¨
            clearAllMixerListeners();

            // é–‹å§‹æ’­æ”¾
            playCurrentStep();
        }

        // â­â­â­ æ‰‹å‹•è·³èˆæŒ‰éˆ•å¼•æ“ï¼šå…¨åŒæ­¥ç­‰å¾…æ©Ÿåˆ¶ â­â­â­
        function playCurrentStep() {
            if (!isDancing) return;

            let dancersFinished = [true, true, true]; // â­ é è¨­å¤§å®¶éƒ½ä¸ç”¨è·³ (è§£æ±ºäººæ•¸å°‘æ–¼ 3 æœƒå¡æ­»çš„å•é¡Œ)
            let anyoneDancing = false;
            let stepTriggered = false; // â­ åŠ å…¥å–®æ¬¡é–å®šï¼Œé˜²æ­¢åŒæ­¥è·³å®Œæ™‚ç™¼ç”Ÿé›™é‡è§¸ç™¼ Bug

            currentVrms.forEach((vrm, vrmIndex) => {
                if (!vrm || !vrm.userData.mixer) return;

                const moveIndex = vrmDanceSequences[vrmIndex][danceStepIndex];
                const action = danceActionsMap[moveIndex]?.[vrmIndex];

                if (action) {
                    anyoneDancing = true;
                    dancersFinished[vrmIndex] = false; // æœ‰å‹•ä½œçš„äººæ¨™ç‚ºæœªå®Œæˆ
                    
                    action.setLoop(THREE.LoopOnce); 
                    action.clampWhenFinished = true; // â­ å®Œç¾åœæ ¼ç­‰å¾…ï¼šæ’­å®Œåœåœ¨æœ€å¾Œä¸€å¹€å®šæ ¼
                    
                    // åˆ©ç”¨ switchToAction å®Œç¾äº¤æ¥ä¸¦é˜²æ­¢æ¬Šé‡æŠµæ¶ˆ
                    switchToAction(vrmIndex, action, 0.5, true); 
                    
                    // ç‚ºæ¯å€‹è§’è‰²çš„ Mixer ç¨ç«‹æ›ä¸Šä¸€æ¬¡æ€§ç›£è½å™¨ (ä½¿ç”¨å®‰å…¨å‡½å¼é˜²æ­¢ Memory Leak)
                    const onFinished = (e) => {
                        if (e.action === action) {
                            if (currentDanceListeners[vrmIndex]) {
                                vrm.userData.mixer.removeEventListener('finished', currentDanceListeners[vrmIndex]);
                                currentDanceListeners[vrmIndex] = null;
                            }

                            if (!isDancing) return;

                            dancersFinished[vrmIndex] = true; // æ¨™è¨˜é€™å€‹è§’è‰²å·²è·³å®Œ

                            // â­ åªæœ‰ç•¶ã€Œä¸‰å€‹äººéƒ½è·³å®Œã€ä¸”ã€Œå°šæœªè§¸ç™¼éä¸‹ä¸€æ­¥ã€æ™‚ï¼Œæ‰ä¸€èµ·é€²å…¥ä¸‹ä¸€æ­¥ï¼
                            if (dancersFinished.every(v => v) && !stepTriggered) {
                                stepTriggered = true; // é–å®šï¼Œé˜²æ­¢åŒå¹€å…§çš„å…¶ä»–äººå†æ¬¡è§¸ç™¼
                                
                                // å‰é€²åˆ°ä¸‹ä¸€æ­¥
                                danceStepIndex++;
                                if (danceStepIndex >= 4) {
                                    danceStepIndex = 0;
                                    danceRound++;
                                    generateSequences(danceRound);
                                    if (danceRound % 2 === 0) {
                                        addMessage(`Round ${danceRound}: Battle Mode!`, "system");
                                    } else {
                                        addMessage(`Round ${danceRound}: Sync Mode!`, "system");
                                    }
                                }
                                playCurrentStep();
                            }
                        }
                    };
                    assignMixerListener(vrm, vrmIndex, onFinished);
                } else {
                    switchToAction(vrmIndex, null, 0.5);
                }
            });

            // é˜²å‘†ï¼šå¦‚æœå®Œå…¨æ²’äººæœ‰å‹•ä½œï¼Œå»¶é²å¾Œç›´æ¥è·³é
            if (!anyoneDancing && !stepTriggered) {
                stepTriggered = true;
                setTimeout(() => {
                    danceStepIndex++;
                    if (danceStepIndex >= 4) {
                        danceStepIndex = 0;
                        danceRound++;
                        generateSequences(danceRound);
                    }
                    playCurrentStep();
                }, 50);
            }
        }

        // åœæ­¢è·³èˆ
        function stopDance() {
            if (!isDancing) return;
            
            isDancing = false;
            danceBtn.classList.remove('active');
            
            // åœæ­¢ BGM
            bgm.pause();
            bgm.currentTime = 0;
            
            // â­â­â­ å¾¹åº•æ¸…é™¤æ‰€æœ‰æ®˜ç•™çš„ç›£è½å™¨ â­â­â­
            clearAllMixerListeners();
            
            // â­â­â­ æ¸…ç©ºä½‡åˆ— â­â­â­
            currentDanceQueue = [];
            currentPlayingDanceData = null; 
            window.pendingMicResume = false; // å–æ¶ˆç­‰å¾…ä¸­çš„éº¥å…‹é¢¨è‡ªå‹•é–‹å•Ÿä»»å‹™
            
            // é‡ç½®ç›¸æ©Ÿ
            setTimeout(() => {
                updateCameraPosition();
            }, 500);
            
            // â­ æ ¹æ“šèªªè©±ç‹€æ…‹ï¼Œæ¢å¾©å°æ‡‰çš„å‹•ä½œ (åˆ©ç”¨ switchToAction å®Œç¾éæ¸¡ï¼Œä¸å¼•ç™¼ A-pose)
            for (let i = 0; i < 3; i++) {
                let targetAction = null;
                if (isSpeaking) {
                    targetAction = (i === 0) ? talkingActionC : ((i === 1) ? talkingActionW : talkingActionD);
                } else {
                    targetAction = (i === 0) ? idleActionC : ((i === 1) ? idleActionW : idleActionD);
                }
                switchToAction(i, targetAction, 0.5, false);
            }
        }

        function toggleDance() {
            if (isDancing) {
                stopDance();
            } else {
                loadAndPlayDance(); 
            }
        }

        // â­â­â­ 1ï¸âƒ£ JSON è§£æå™¨ï¼ˆçµ‚æ¥µé˜²å‘†ç ´è£‚ç‰ˆï¼šä¿®å¾© AI æ¼é€—è™Ÿçš„å•é¡Œï¼‰ â­â­â­
        function safeParseAIJson(text) {
            try {
                // æ¸…é™¤å¯èƒ½åŒ…å«çš„ Markdown æ¨™è¨˜
                let cleanText = text.replace(/```json/gi, '').replace(/```/g, '').trim();
                
                // å°‹æ‰¾ JSON çš„èµ·é»èˆ‡çµ‚é»
                const start = cleanText.indexOf('{');
                const end = cleanText.lastIndexOf('}');
                if (start === -1 || end === -1) return null;
                
                let jsonStr = cleanText.substring(start, end + 1);
                
                // â­ çµ‚æ¥µä¿®å¾© 1ï¼šæŠŠæ‰€æœ‰çš„çœŸå¯¦æ›è¡Œç¬¦è™Ÿæ›¿æ›æˆç©ºæ ¼ï¼Œé¿å…å­—ä¸²å…§æ›è¡Œå°è‡´ JSON.parse å´©æ½°
                jsonStr = jsonStr.replace(/[\n\r]+/g, ' ');
                
                // â­ çµ‚æ¥µä¿®å¾© 2 (æ‹¯æ•‘çŸ©é™£)ï¼šAI å¸¸å¸¸å¿˜è¨˜äºŒç¶­é™£åˆ—ä¸­é–“çš„é€—è™Ÿï¼Œä¾‹å¦‚ [[1,2][3,4]]ï¼Œå¹«å®ƒè£œä¸Šè®Šæˆ [[1,2], [3,4]]
                jsonStr = jsonStr.replace(/\]\s*\[/g, '], [');
                
                // â­ çµ‚æ¥µä¿®å¾© 3 (é˜²æ­¢å–®å¼•è™Ÿæ—äº‚)
                jsonStr = jsonStr.replace(/'/g, '"');
                
                // ä¿®å¾©å¸¸è¦‹å£ JSON
                jsonStr = jsonStr
                    .replace(/"dance_list"\s*:\s*,/g, '"dance_list":[],') // ä¿®å¾©ç©ºå€¼
                    .replace(/,\s*}/g, '}') // ä¿®å¾©å°¾éƒ¨é€—è™Ÿ
                    .replace(/,\s*]/g, ']'); // ä¿®å¾©é™£åˆ—å°¾éƒ¨é€—è™Ÿ
                    
                const result = JSON.parse(jsonStr);
                
                // å…è¨±ä¸€ç¶­æˆ–äºŒç¶­é™£åˆ—
                if (result.action === "dance_sequence") {
                    if (typeof result.dance_list === "number") {
                        result.dance_list = [result.dance_list];
                    }
                    if (!Array.isArray(result.dance_list) || result.dance_list.length === 0) {
                        result.dance_list = null; // è¨­ç‚º nullï¼Œè®“ handleAIResponse ç”¨æ–‡å­—çŒœæ¸¬
                    } else {
                        // â­ å¼·åˆ¶è½‰æ›æ‰€æœ‰å…ƒç´ ç‚ºæ•¸å­—ï¼Œé˜²æ­¢ AI å¡æ–‡å­—é€²ä¾†
                        result.dance_list = result.dance_list.map(item => {
                            if (Array.isArray(item)) {
                                return item.map(v => parseInt(v)).map(v => isNaN(v) ? -1 : v);
                            } else {
                                let v = parseInt(item);
                                return isNaN(v) ? -1 : v;
                            }
                        });
                    }
                }
                return result;
            } catch (err) {
                console.warn("JSON ä¿®å¾©å¤±æ•—:", err, "\nRaw text:", text);
                return null;
            }
        }

        // â­â­â­ 2ï¸âƒ£ fallbackï¼šå¾æ–‡å­—çŒœèˆè¹ˆï¼ˆåŠ å…¥ã€Œå„è‡ªè·³ã€å…œåº•è™•ç†ï¼‰ â­â­â­
        function guessDanceFromText(text) {
            if (!text) return null;
            const lowerText = text.toLowerCase();
            
            // å¦‚æœé—œéµå­—æœ‰ã€Œå„è‡ªã€æˆ–ã€Œåˆ†åˆ¥ã€æˆ–ã€Œæ¯å€‹äººã€ï¼Œå…œåº•è¿”å›äºŒç¶­é™£åˆ—çš„éš¨æ©ŸæŒ‡ç¤º (çµ¦äºˆ3å€‹å‹•ä½œé•·åº¦é¿å…å¤ªå¿«çµæŸ)
            if (lowerText.includes("å„è‡ª") || lowerText.includes("åˆ†åˆ¥") || lowerText.includes("æ¯å€‹äºº")) {
                return [[-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]; 
            }

            // â­ çµ‚æ¥µä¿®å¾©ï¼šå„ªå…ˆåˆ¤å®šã€Œå®šæ ¼Bã€ï¼Œé¿å…è¢«ä¸‹æ–¹çš„ã€Œéœ¹é‚ã€é—œéµå­—æ””æˆªè®Šæˆ 0
            if (lowerText.includes("å®šæ ¼b") || lowerText.includes("éœ¹é‚èˆb")) {
                return [3];
            }

            const map = {
                "éœ¹é‚": 0, "è¡—èˆ": 0, "hiphop": 0, "breakdance": 0,
                "wave": 1, "æ®æ‰‹": 1, "æ¹¯ç‘ªæ–¯": 1, "flair": 1, "thomas": 1,
                "å˜»å“ˆ": 2, "å¾‹å‹•": 2, "hip hop": 2,
                "è·³èˆ": -1, "dance": -1, // Random
                "éš¨æ©Ÿè·³": -1, "éš¨ä¾¿è·³": -1
            };
            for (const key in map) {
                if (lowerText.includes(key)) {
                    return [map[key]]; // åŒæ­¥è·³åŒä¸€ç¨®
                }
            }
            return null;
        }

        // â­â­â­ æ–°å¢ï¼šé˜²å‘†éæ¿¾å™¨ï¼Œå¼·åˆ¶å°‡ AI éŒ¯èª¤çš„ 1D é½ŠèˆæŒ‡ä»¤ä¿®æ­£ç‚ºå–®äººè·³èˆ â­â­â­
        function fixDanceSequence(seq, referenceText) {
            // åªæœ‰ç•¶å‚³å…¥çš„æ˜¯æœ‰æ•ˆé™£åˆ—ä¸”ç‚º 1D é™£åˆ—æ™‚æ‰ä»‹å…¥è™•ç†
            if (!seq || !Array.isArray(seq) || seq.length === 0) return seq;
            if (Array.isArray(seq[0])) return seq; // å·²ç¶“æ˜¯ 2D é™£åˆ—ï¼Œä»£è¡¨ AI æœ‰ç…§åšï¼Œä¿¡ä»» AI

            const txt = referenceText.toLowerCase();
            
            // åµæ¸¬æ˜¯å¦æ˜ç¢ºæŒ‡å®šç‰¹å®šè§’è‰²
            const p1 = txt.includes("ç¬¬ä¸€") || txt.includes("å·¦é‚Š") || txt.includes("c");
            const p2 = txt.includes("ç¬¬äºŒ") || txt.includes("ä¸­é–“") || txt.includes("w");
            const p3 = txt.includes("ç¬¬ä¸‰") || txt.includes("å³é‚Š") || txt.includes("david") || txt.includes("å¤§ç¶­");
            
            // åµæ¸¬æ˜¯å¦æœ‰æ’ä»–æ€§å­—çœ¼
            const exclusive = txt.includes("å…¶ä»–äººä¸") || txt.includes("å…¶ä»–äººä¸è¦") || txt.includes("å–®ç¨") || txt.includes("åªæœ‰") || txt.includes("è‡ªå·±");

            // ç¢ºä¿æ²’æœ‰è¦æ±‚å¤§å®¶ä¸€èµ·è·³
            const together = txt.includes("ä¸€èµ·") || txt.includes("å¤§å®¶") || txt.includes("æ‰€æœ‰äºº");

            // è‹¥æœ‰è¦æ±‚å–®ç¨è·³çš„èªæ„ï¼Œå¼·åˆ¶æŠŠ 1D é™£åˆ—æ‹†æˆ 2D å–®äººè·³é™£åˆ—
            if ((p1 || p2 || p3 || exclusive) && !together) {
                let fixedSeq = [[], [], []];
                let shouldDance = [false, false, false];
                
                if (p1) shouldDance[0] = true;
                if (p2) shouldDance[1] = true;
                if (p3) shouldDance[2] = true;

                // é˜²å‘†ï¼šå¦‚æœåªèªªäº†ã€Œå–®ç¨è·³ã€ä½†å®Œå…¨æ²’æåˆ°æ˜¯èª°ï¼Œæˆ–æ˜¯è¾¨è­˜ä¸åˆ°ï¼Œé è¨­æŒ‡æ´¾çµ¦ç¬¬ä¸‰ä½æˆ–ä¸­é–“
                if (!shouldDance.includes(true)) {
                    shouldDance[2] = true; // ä¾æ“šæ‚¨çš„æ¸¬è©¦æƒ…å¢ƒï¼Œé è¨­æŒ‡çµ¦ç¬¬ä¸‰ä½
                }

                for (let i = 0; i < 3; i++) {
                    // è‹¥æ­¤äººè©²è·³ï¼Œå°±çµ¦åŸé™£åˆ—ï¼›å¦å‰‡å¡æ»¿å°æ‡‰é•·åº¦çš„ 99 (ä¸è·³)
                    fixedSeq[i] = shouldDance[i] ? [...seq] : Array(seq.length).fill(99);
                }
                
                logAction(`[ç³»çµ±é˜²å‘†] æ””æˆª AI éŒ¯èª¤çš„ 1D é½Šèˆé™£åˆ—ï¼Œå·²è‡ªå‹•ä¿®æ­£ç‚ºå–®ç¨è·³èˆ: ${JSON.stringify(fixedSeq)}`);
                return fixedSeq;
            }
            return seq; // è‹¥ç„¡ç‰¹æ®Šé—œéµå­—ï¼Œç¶­æŒåŸæœ¬é™£åˆ—
        }


        // â­â­â­ 3ï¸âƒ£ ä¿®æ­£ç‰ˆï¼šæ’­æ”¾èˆè¹ˆåºåˆ—ï¼ˆå¼·å¤§å‡ç´šç‰ˆï¼šæ”¯æ´æ¯å€‹è§’è‰²å„è‡ªä¸åŒçš„èˆæ­¥èˆ‡é•·åº¦ï¼‰ â­â­â­
        async function playDanceSequence(sequence) {
            // åœ¨ await ä¹‹å‰å…ˆå°‡ç‹€æ…‹è¨­ç‚º true
            isDancing = true;
            danceBtn.classList.add('active');

            // æ¸…ç†å¯èƒ½æ®˜ç•™çš„ç›£è½å™¨ï¼Œé˜²æ­¢æ¼ç¶²ä¹‹é­š
            clearAllMixerListeners();

            // è¼‰å…¥è³‡æº
            await loadDanceAssets(); 
            
            // å†æ¬¡ç¢ºèªç‹€æ…‹
            isDancing = true;
            updateCameraPosition();
            
            // BGM æ’­æ”¾
            try {
                if (!bgm.paused) bgm.pause();
                bgm.currentTime = 0;
                bgm.muted = isMuted;
                const playPromise = bgm.play();
                if (playPromise !== undefined) {
                    playPromise.catch(error => { console.warn("BGM Auto-play failed:", error); });
                }
            } catch(e) { console.error("BGM Fatal Error:", e); }

            // è½‰æ›å‚³å…¥çš„èˆæ­¥é™£åˆ— (æ”¯æ´ 1D æˆ– 2D é™£åˆ—)
            let seq = Array.isArray(sequence) ? sequence : [];
            let is2D = seq.length > 0 && Array.isArray(seq[0]);
            
            currentDanceQueue = [];
            
            if (is2D) {
                // å¦‚æœæ˜¯ 2D é™£åˆ—ï¼š[[äºº1èˆæ­¥...], [äºº2èˆæ­¥...], [äºº3èˆæ­¥...]]
                // æ‰¾å‡ºæœ€é•·çš„é‚£ä¸²èˆæ­¥æ­¥æ•¸
                let maxSteps = Math.max(...seq.map(arr => Array.isArray(arr) ? arr.length : 0));
                
                // å°‡æ¯å€‹ã€Œæ­¥é©Ÿã€æ‰“åŒ…æˆä¸€å€‹é™£åˆ—æ¨å…¥ Queue
                for (let step = 0; step < maxSteps; step++) {
                    let stepArray = [];
                    for (let c = 0; c < 3; c++) { 
                        let charSeq = seq[c] || [];
                        // â­ çµ‚æ¥µä¿®å¾©ï¼šå¦‚æœé€™å›åˆè©²è§’è‰²å·²ç¶“æ²’æœ‰å‹•ä½œäº†ï¼Œå¼·åˆ¶æŒ‡æ´¾ 99 (åŸåœ°ä¸å‹•)ï¼Œè€Œä¸æ˜¯äº‚çµ¦éš¨æ©Ÿèˆè¹ˆï¼
                        let danceId = charSeq[step] !== undefined ? charSeq[step] : 99;
                        if (danceId === -1) danceId = Math.floor(Math.random() * DANCE_URLS.length);
                        stepArray.push(danceId);
                    }
                    currentDanceQueue.push(stepArray); 
                }
            } else {
                // 1D é™£åˆ— (æ‰€æœ‰äººä¸€èµ·è·³ä¸€æ¨£çš„åŒæ­¥èˆ)
                currentDanceQueue = seq.map(id => {
                    if (id === -1) return Math.floor(Math.random() * DANCE_URLS.length); 
                    return id;
                });
            }

            console.log("AI èˆæ­¥åºåˆ—è§£ç¢¼å®Œæˆ (Queue):", currentDanceQueue);
            // â­ å°‡æœ€çµ‚ç³»çµ±è¦åŸ·è¡Œçš„æ’ç¨‹é™£åˆ—å°åˆ°ç›£æ§é¢æ¿
            logAction(`[ç³»çµ±] é–‹å§‹åŸ·è¡Œèˆè¹ˆæ’ç¨‹ Queue: ${JSON.stringify(currentDanceQueue)}`);
            playNextDanceInQueue();
        }

        // â­â­â­ AI èˆè¹ˆå¼•æ“ï¼šå…¨åŒæ­¥ç­‰å¾…æ©Ÿåˆ¶ â­â­â­
        function playNextDanceInQueue() {
            if (currentDanceQueue.length === 0) {
                // åºåˆ—çµæŸï¼Œè‡ªç„¶æ¢å¾©
                isDancing = false;
                bgm.pause();
                bgm.currentTime = 0;
                danceBtn.classList.remove('active');

                // ç¢ºä¿ç›£è½å™¨è¢«æ¸…é™¤
                clearAllMixerListeners();

                setTimeout(() => updateCameraPosition(), 500);
                
                // â­ æ ¸å¿ƒä¿®æ­£ï¼šåˆ©ç”¨ switchToAction å¼•æ“ï¼Œæ ¹æ“šç›®å‰èªªè©±ç‹€æ…‹æ¢å¾©å‹•ä½œï¼Œé¿å…æ‰€æœ‰å¡å¹€å•é¡Œ
                for (let i = 0; i < 3; i++) {
                    let targetAction = null;
                    if (isSpeaking) {
                        targetAction = (i === 0) ? talkingActionC : ((i === 1) ? talkingActionW : talkingActionD);
                    } else {
                        targetAction = (i === 0) ? idleActionC : ((i === 1) ? idleActionW : idleActionD);
                    }
                    switchToAction(i, targetAction, 0.5, false);
                }
                
                // ç•¶æ•´å€‹é€£çºŒèˆæ­¥å…¨éƒ¨è·³å®Œå¾Œï¼Œæ‰åŸ·è¡Œä¹‹å‰å› ç‚ºè·³èˆè€Œè¢«æ“±ç½®çš„éº¥å…‹é¢¨é‡å•Ÿä»»å‹™ï¼
                if (window.pendingMicResume) {
                    window.pendingMicResume = false;
                    setTimeout(() => {
                        if (!isRecording) startRecording();
                    }, 500);
                }
                return;
            }

            let nextData = currentDanceQueue.shift(); 
            logAction(`[ç³»çµ±] åŸ·è¡Œæ’ç¨‹æ­¥é©Ÿ: ${JSON.stringify(nextData)}`);
            
            // å®‰å…¨æ€§é©—è­‰èˆ‡è¶Šç•Œé˜²å‘†
            if (Array.isArray(nextData)) {
                nextData = nextData.map(val => {
                    let v = parseInt(val);
                    if (v === 99) return 99; // â­ æ”¯æ´ 99 (ç«™åœ¨åŸåœ°ä¸è·³èˆ)
                    return (isNaN(v) || v < 0 || v >= DANCE_URLS.length) ? Math.floor(Math.random() * DANCE_URLS.length) : v;
                });
            } else {
                let v = parseInt(nextData);
                if (v === 99) {
                    nextData = 99; // â­ æ”¯æ´ 99 (ç«™åœ¨åŸåœ°ä¸è·³èˆ)
                } else if (isNaN(v) || v < 0 || v >= DANCE_URLS.length) {
                    nextData = Math.floor(Math.random() * DANCE_URLS.length);
                } else {
                    nextData = v;
                }
            }
            
            currentPlayingDanceData = nextData; 

            // â­ æ ¸å¿ƒï¼šè¿½è¹¤ä¸‰ä½èˆè€…çš„é€²åº¦ï¼Œç¢ºä¿åŒæ­¥
            let dancersFinished = [true, true, true]; // â­ é è¨­å¤§å®¶éƒ½ä¸ç”¨è·³ (è§£æ±ºäººæ•¸ä¸è¶³æœƒå¡æ­»çš„å•é¡Œ)
            let anyoneDancing = false;
            let stepTriggered = false; // â­ åŠ å…¥å–®æ¬¡é–å®šï¼Œé˜²æ­¢åŒæ­¥è·³å®Œæ™‚ç™¼ç”Ÿé›™é‡è§¸ç™¼ Bug

            currentVrms.forEach((vrm, vrmIndex) => {
                if (!vrm || !vrm.userData.mixer) return;
                
                let nextIndex = Array.isArray(nextData) ? nextData[vrmIndex] : nextData;

                // â­ å–®ç¨è·³èˆé‚è¼¯ï¼šå¦‚æœé€™å€‹äººçš„å‹•ä½œæ˜¯ 99ï¼Œä»£è¡¨ä»–é€™å›åˆåŸåœ°ä¸å‹•ï¼Œæˆ‘å€‘å¹«ä»–æ’­æ”¾ Idle æˆ– Talking å‹•ä½œï¼
                if (nextIndex === 99) {
                    dancersFinished[vrmIndex] = true; // è¨­ç‚º true è®“ä»–ä¸æœƒé˜»ç¤™å…¶ä»–äºº
                    
                    let targetA = null;
                    if (isSpeaking) {
                        targetA = (vrmIndex === 0) ? talkingActionC : ((vrmIndex === 1) ? talkingActionW : talkingActionD);
                    } else {
                        targetA = (vrmIndex === 0) ? idleActionC : ((vrmIndex === 1) ? idleActionW : idleActionD);
                    }
                    switchToAction(vrmIndex, targetA, 0.5, false);
                    return; // 99 çš„äººä¸éœ€è¦ç¶å®š onFinished ç›£è½å™¨
                }
                
                const action = danceActionsMap[nextIndex]?.[vrmIndex];
                
                if (action) {
                    anyoneDancing = true;
                    dancersFinished[vrmIndex] = false; // â­ æœ‰å‹•ä½œçš„äººæ‰æ¨™è¨˜ç‚º false
                    
                    action.setLoop(THREE.LoopOnce);
                    action.clampWhenFinished = true; // â­ å®Œç¾åœæ ¼ï¼šä¿æŒå®šæ ¼ï¼Œç­‰å…¶ä»–äººè·³å®Œ
                    switchToAction(vrmIndex, action, 0.5, true); // forceReset = true

                    const onFinished = (e) => {
                        if (e.action === action) {
                            if (currentDanceListeners[vrmIndex]) {
                                vrm.userData.mixer.removeEventListener('finished', currentDanceListeners[vrmIndex]);
                                currentDanceListeners[vrmIndex] = null;
                            }

                            if (!isDancing) return;

                            dancersFinished[vrmIndex] = true; // æ­¤äººè·³å®Œ

                            // â­ ç•¶ä¸‰å€‹äººéƒ½å®Œæˆå‹•ä½œå¾Œï¼Œä¸”å°šæœªè§¸ç™¼éä¸‹ä¸€æ­¥æ™‚ï¼Œå†ä¸€èµ·é€²å…¥ä¸‹ä¸€å€‹å‹•ä½œï¼
                            if (dancersFinished.every(v => v) && !stepTriggered) {
                                stepTriggered = true; // é–å®š
                                playNextDanceInQueue(); // è§¸ç™¼ä¸‹ä¸€è¼ª
                            }
                        }
                    };
                    assignMixerListener(vrm, vrmIndex, onFinished);
                } else {
                    switchToAction(vrmIndex, null, 0.5);
                }
            });

            // å¦‚æœå®Œå…¨æ²’äººæœ‰å‹•ä½œï¼Œå»¶é²å¾Œç›´æ¥é€²è¡Œä¸‹ä¸€æ­¥
            if (!anyoneDancing && !stepTriggered) {
                stepTriggered = true;
                setTimeout(() => playNextDanceInQueue(), 50);
            }
        }

        danceBtn.addEventListener('click', toggleDance);
        danceBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            toggleDance();
        });

        // --- æƒ…ç·’æ§åˆ¶ ---
        const VALID_EMOTIONS = ['neutral', 'happy', 'angry', 'sad', 'relaxed', 'surprised'];
        function setEmotion(emotionName) {
            if (currentVrms.length === 0) return;
            if (emotionName === 'joy') emotionName = 'happy';
            if (emotionName === 'sorrow') emotionName = 'sad';
            if (emotionName === 'fun') emotionName = 'relaxed';
            if (!VALID_EMOTIONS.includes(emotionName)) emotionName = 'neutral';
            
            updateDebugDisplay(emotionName, null);
            
            // å¥—ç”¨åˆ°æ‰€æœ‰è§’è‰²
            currentVrms.forEach(vrm => {
                if(!vrm) return;
                VALID_EMOTIONS.forEach(emo => vrm.expressionManager.setValue(emo, 0));
                if (emotionName !== 'neutral') vrm.expressionManager.setValue(emotionName, 0.8);
            });
        }

        window.actionActive = false;
        function triggerAction(actionName, duration) {
            if (currentVrms.length === 0 || actionName === 'none') return;
            updateDebugDisplay(null, `${actionName}`);
            let shapeName = actionName === 'blink_left' ? 'blinkLeft' : (actionName === 'blink_right' ? 'blinkRight' : 'blink');
            window.actionActive = true;
            
            currentVrms.forEach(vrm => {
                if(vrm) vrm.expressionManager.setValue(shapeName, 1.0);
            });
            
            setTimeout(() => {
                currentVrms.forEach(vrm => {
                    if(vrm) vrm.expressionManager.setValue(shapeName, 0);
                });
                window.actionActive = false;
                updateDebugDisplay(null, 'Done');
            }, duration);
        }

        function updateDebugDisplay(emo, act) {
            const debugDiv = document.getElementById('emotion-debug');
            if(emo) debugDiv.innerHTML = debugDiv.innerHTML.replace(/æƒ…ç·’: .*/, `æƒ…ç·’: ${emo}`);
            if(act) debugDiv.innerHTML = debugDiv.innerHTML.replace(/å‹•ä½œ: .*/, `å‹•ä½œ: ${act}`);
        }

        function addMessage(text, type) {
            const chatDisplay = document.getElementById('chat-display');
            const div = document.createElement('div');
            div.className = `message message-${type}`;
            
            let safeText = text.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\n/g, "<br>");
            safeText = safeText.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank">$1</a>');
            
            div.innerHTML = safeText;
            chatDisplay.appendChild(div);
            chatDisplay.scrollTo({ top: chatDisplay.scrollHeight, behavior: 'smooth' });
            return div;
        }

        function removeMessage(el) { if(el && el.parentNode) el.parentNode.removeChild(el); }

        // --- API é€£ç·šæª¢æŸ¥ (å³ä¸Šè§’) ---
        const statusDot = document.getElementById('status-dot');
        const statusMsg = document.getElementById('status-msg');
        const userInput = document.getElementById('user-input');
        const sendBtn = document.getElementById('send-btn');
        const muteBtn = document.getElementById('mute-btn');
        const micBtn = document.getElementById('mic-btn'); // å–å¾—éº¥å…‹é¢¨æŒ‰éˆ•

        async function testApiConnection() {
            if (isPreviewEnv) {
                statusDot.classList.add('status-preview');
                statusMsg.innerText = "é è¦½æ¨¡å¼";
                userInput.disabled = false; sendBtn.disabled = false;
                return;
            }

            statusMsg.innerText = "é€£ç·šæ¸¬è©¦...";
            statusDot.className = 'status-dot'; 
            
            // **é—œéµä¿®æ”¹**ï¼šå¼·åˆ¶åœ¨ 1 ç§’å¾Œè§£é–è¼¸å…¥æ¡†ï¼Œä¸ç®¡é€£ç·šæ¸¬è©¦çµæœå¦‚ä½•
            // é¿å… Android æˆ–ç¶²è·¯æ…¢æ™‚ï¼Œä½¿ç”¨è€…è¢«å¡ä½ç„¡æ³•è¼¸å…¥
            setTimeout(() => {
                 if (userInput.disabled) {
                     userInput.disabled = false; 
                     sendBtn.disabled = false;
                 }
            }, 1000);

            // Add Timeout to prevent hanging
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout

            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: "Test" }] }] }),
                    signal: controller.signal
                });
                clearTimeout(timeoutId);

                if (response.ok) {
                    statusDot.classList.add('status-connected');
                    statusMsg.innerText = "ç³»çµ±é€£ç·šæ­£å¸¸";
                } else {
                    throw new Error("API Check Failed");
                }
            } catch (e) {
                statusDot.classList.add('status-error');
                statusMsg.innerText = "é€£ç·šå¤±æ•— (å¯é›¢ç·šè¼¸å…¥)"; // Inform user they can still type
                console.error("API Test Failed:", e);
                // Don't spam the chat with system message immediately, maybe just log or small note
                // addMessage(`é€£ç·šæ¸¬è©¦å¤±æ•—: ${e.message}`, 'system'); 
            } finally {
                // ALWAYS unlock inputs so user can try anyway
                userInput.disabled = false; 
                sendBtn.disabled = false;
            }
        }

        // --- è¨Šæ¯ç™¼é€èˆ‡è™•ç† ---
        muteBtn.addEventListener('click', () => {
            isMuted = !isMuted;
            muteBtn.classList.toggle('muted', isMuted);
            muteBtn.innerText = isMuted ? 'ğŸ”‡' : 'ğŸ”Š';
            if(isMuted) { window.speechSynthesis.cancel(); isSpeaking = false; }
            // é€£å‹•èƒŒæ™¯éŸ³æ¨‚éœéŸ³
            bgm.muted = isMuted;
        });

        // è§£é–èªéŸ³å‡½å¼ (Android å¿…é ˆ)
        async function unlockTTS() {
            logTTS("æ­£åœ¨è§£é–èªéŸ³...");
            return new Promise(resolve => {
                try {
                    const u = new SpeechSynthesisUtterance(" ");
                    // â­â­â­ ä¿®å¾©ï¼šé˜²æ­¢ GC å›æ”¶ â­â­â­
                    window.currentUtterance = u; 
                    u.volume = 0; // éœéŸ³
                    u.rate = 10; // è¶…å¿«
                    u.onend = () => {
                        logTTS("èªéŸ³è§£é–å®Œæˆ (onend)");
                        resolve();
                    };
                    //æœ‰äº›ç€è¦½å™¨ onend ä¸æœƒè§¸ç™¼å¦‚æœ volume æ˜¯ 0ï¼ŒåŠ å€‹ timeout ä¿éšª
                    setTimeout(() => {
                        logTTS("èªéŸ³è§£é–å®Œæˆ (timeout)");
                        resolve();
                    }, 200); 
                    speechSynthesis.speak(u);
                } catch(e) {
                    logTTS(`èªéŸ³è§£é–å¤±æ•—: ${e.message}`);
                    resolve();
                }
            });
        }

        // â­â­â­ 4ï¸âƒ£ æ¥æ”¶ AI å›æ‡‰ï¼ˆä¿®æ­£èª¤åˆ¤è·³èˆçš„æœ€çµ‚ç‰ˆï¼‰ â­â­â­
        function handleAIResponse(aiText) {
            let result = safeParseAIJson(aiText);
            
            // â­ å°‡ AI åŸå§‹æ–‡å­—èˆ‡è§£æçµæœå°åˆ°ç›£æ§é¢æ¿ï¼Œæ–¹ä¾¿éŒ„å½±æŠ“èŸ²
            logAction(`Raw AI Text:\n${aiText}`);
            
            let danceSeq = null;

            if (result) {
                logAction(`Parsed Result:\nAction: ${result.action}\nDance List: ${JSON.stringify(result.dance_list)}`);
                if (result.action === 'dance_sequence' || result.action === 'dance_random') {
                    if (Array.isArray(result.dance_list) && result.dance_list.length > 0) {
                        danceSeq = result.dance_list;
                    } else if (result.action === 'dance_random') {
                        danceSeq = [Math.floor(Math.random() * DANCE_URLS.length)];
                    } else {
                        danceSeq = guessDanceFromText(result.text);
                        if (!danceSeq) danceSeq = [Math.floor(Math.random() * DANCE_URLS.length)];
                    }
                }
            } else {
                logAction(`Parse Failed! ä½¿ç”¨é—œéµå­—å…œåº•çŒœæ¸¬`);
                danceSeq = guessDanceFromText(aiText);
            }

            // å¦‚æœåˆ¤å®šè¦è·³èˆï¼ŒåŸ·è¡Œè·³èˆ
            if (danceSeq) {
                // â­â­â­ æ”¶é›†èªå¢ƒï¼Œå¹«åŠ©é˜²å‘†å‡½æ•¸åˆ¤æ–·
                let contextText = aiText;
                // å–å‡ºä½¿ç”¨è€…æœ€è¿‘ä¸€æ¬¡èªªçš„è©± (å€’æ•¸ç¬¬äºŒç­†ç´€éŒ„)
                if (chatHistory.length >= 2 && chatHistory[chatHistory.length - 2].role === "user") {
                    contextText += " " + chatHistory[chatHistory.length - 2].parts[0].text;
                }

                // â­ çµ‚æ¥µé˜²å‘†ï¼šä¿®æ­£ AI å·æ‡¶çµ¦ 1D é™£åˆ—ï¼Œä½†æ–‡å­—æ˜æ˜è¦æ±‚å–®ç¨è·³çš„æƒ…æ³
                danceSeq = fixDanceSequence(danceSeq, contextText);
                
                playDanceSequence(danceSeq);
            } 
            
            // â­â­â­ é˜²å‘†èªªè©±æå–ï¼šçµ•å°ä¸è®“ä½¿ç”¨è€…è½åˆ°/çœ‹åˆ°åŸå§‹çš„ JSON ç¨‹å¼ç¢¼ â­â­â­
            let speakText = aiText;
            if (result && result.text) {
                speakText = result.text;
            } else {
                // å¦‚æœ JSON å¾¹åº•å£æ‰ï¼Œå˜—è©¦ç”¨æ­£å‰‡æŠ“å–è£¡é¢çš„ "text" å…§å®¹ (æ”¯æ´è·³è„«å¼•è™Ÿ)
                try {
                    const textMatch = aiText.match(/"text"\s*:\s*"((?:\\"|[^"])*)"/);
                    if (textMatch) {
                        speakText = textMatch[1].replace(/\\n/g, '\n').replace(/\\"/g, '"');
                    } else {
                        // æœ€å¾Œæ‰‹æ®µï¼šå‰é›¢ markdown
                        speakText = aiText.replace(/```json/gi, '').replace(/```/g, ''); 
                    }
                } catch (e) {
                    speakText = "æˆ‘å¥½åƒè·³é‡äº†ï¼Œä½†èˆæ­¥å·²ç¶“å®‰æ’å¥½å›‰ï¼";
                }
            }
            speak(speakText || "");
            
            // â­â­â­ æ¢å¾©æ–‡å­—ä¿®æ­£åŠŸèƒ½ï¼šå¦‚æœæœ‰æ ¡æ­£å¾Œçš„æ–‡å­—ï¼Œæ›´æ–°ä½¿ç”¨è€…çš„å°è©±æ°£æ³¡ â­â­â­
            if (result && result.corrected_text) {
                const userMsgs = document.querySelectorAll('.message-user');
                if (userMsgs.length > 0) {
                    userMsgs[userMsgs.length - 1].innerHTML = result.corrected_text;
                }
            }

            // è™•ç†è¡¨æƒ…
            if (result && result.emotion) {
                setEmotion(result.emotion);
            }
            
            // è™•ç†å…¶ä»–å‹•ä½œ (éèˆè¹ˆ)
            if (result && result.action && result.action !== 'none' && !result.action.startsWith('dance')) {
                triggerAction(result.action, 2000);
            }
        }

        // ç§»é™¤ç¨ç«‹çš„ correctSpeechText å‡½å¼ï¼Œæ”¹ç‚ºåˆä½µè™•ç†

        async function handleSendMessage() {
            // é˜²æ­¢é‡è¤‡é»æ“Š
            if (userInput.disabled || sendBtn.disabled) return;

            const text = userInput.value.trim();
            if (!text) return;
            
            // â­â­â­ ç™¼é€è¨Šæ¯æ™‚ï¼Œå¦‚æœæ­£åœ¨éŒ„éŸ³ï¼Œæš«æ™‚åœæ­¢ï¼Œä»¥å…ç³»çµ±æŠŠè‡ªå·±çš„è©±éŒ„é€²å» â­â­â­
            if (isRecording) {
                stopRecording(); 
                window.shouldResumeMic = true; // æ¨™è¨˜éœ€è¦è‡ªå‹•é‡å•Ÿ
            } else {
                window.shouldResumeMic = false;
            }

            // â­ è‹¥æ­£åœ¨è·³èˆï¼Œå…ˆåœæ­¢è·³èˆ
            if (isDancing) stopDance();

            // â­â­â­ æ–°å¢ï¼šç™¼é€è¨Šæ¯å‰ï¼Œç¢ºä¿å¾¹åº•åœæ­¢ä¸Šä¸€æ¬¡çš„èªéŸ³ â­â­â­
            if (window.speechSynthesis) {
                window.speechSynthesis.cancel();
            }

            // â­â­â­ æ¯æ¬¡ç™¼é€è¨Šæ¯å‰éƒ½é‡æ–°è§£é–èªéŸ³ï¼ˆAndroid å¿…é ˆï¼‰
            if (!isMuted && ttsSupported) {
                logTTS("é–‹å§‹è¨Šæ¯ç™¼é€æµç¨‹...");
                // ç”¨ race é¿å… unlock å¡æ­»
                await Promise.race([
                    unlockTTS(),
                    new Promise(r => setTimeout(r, 300))
                ]);
            }

            userInput.value = ''; userInput.disabled = true; sendBtn.disabled = true;
            addMessage(text, 'user');
            
            if (isPreviewEnv) {
                addMessage("ã€æç¤ºã€‘é è¦½æ¨¡å¼ç„¡æ³•é€£æ¥ AIï¼Œè«‹éƒ¨ç½²è‡³ Vercelã€‚", 'system');
                userInput.disabled = false; sendBtn.disabled = false; userInput.focus();
                return;
            }

            const loadingMsg = addMessage("Thinking...", 'system');
            
            chatHistory.push({ role: "user", parts: [{ text: text }] });

            let finalSystemInstruction = "";
            
            // â­â­â­ å…ˆåŠ å…¥å¤–éƒ¨ System Promptï¼Œä½†å¾Œé¢æœƒå†åŠ ä¸Šå¼·åˆ¶æŒ‡ä»¤ â­â­â­
            if (externalSystemPrompt) finalSystemInstruction += externalSystemPrompt;
            else finalSystemInstruction += `You are a virtual AI character. Reply in Traditional Chinese. Output JSON: { "text": "response", "emotion": "neutral", "action": "none" }`;

            if (externalKnowledge) {
                finalSystemInstruction += "\n\n====== KNOWLEDGE BASE ======\n" + externalKnowledge + "\n============================\n";
            }

            // â­ å¼·åŒ– AI å›å‚³å¤šå›åˆçš„æŒ‡ä»¤èªªæ˜
            finalSystemInstruction += `
ã€CRITICAL INSTRUCTIONSã€‘
1. **JSON FORMAT ONLY**: You MUST output a strictly valid JSON object. Do not wrap it in markdown block like \`\`\`json.
2. **PERSONA**: Keep responses natural, conversational, and concise. Do NOT refer to yourself as code or mention JSON format to the user.
3. **DANCE SYSTEM**:
   - Dance IDs available: 0(éœ¹é‚èˆA), 1(æ¹¯ç‘ªæ–¯), 2(å˜»å“ˆ), 3(éœ¹é‚èˆB), 99(ä¸è·³èˆ/åŸåœ°å¾…å‘½).
   - "action" must be "dance_sequence".
   - **å¤šå›åˆæ’ç¨‹ (CRITICAL)**ï¼šç•¶ä½¿ç”¨è€…è¦æ±‚ã€Œè·³å¤šæ¬¡ã€æˆ–ã€Œé€£çºŒè·³ä¸åŒèˆã€æ™‚ï¼Œä½ å¿…é ˆåœ¨ "dance_list" ä¸­ç”¢ç”Ÿå°æ‡‰æ•¸é‡çš„æ­¥é©Ÿã€‚
   - **é è¨­é½Šèˆ (1D Array)**: è‹¥ä½¿ç”¨è€…è¦æ±‚ã€Œå¤§å®¶ä¸€èµ·è·³å…©æ¬¡ã€ï¼Œè«‹å›å‚³ [1, 1]ã€‚
   - **å„è‡ªè·³èˆ (2D Array)**: è‹¥ä½¿ç”¨è€…è¦æ±‚ã€Œç¬¬ä¸€äººè·³å˜»å“ˆï¼Œå…¶ä»–äººä¸è·³ã€ï¼Œè«‹å›å‚³ [[2], [99], [99]]ã€‚è‹¥è¦æ±‚å„è‡ªè·³ä¸åŒä¸”è·³å…©æ¬¡ï¼Œè«‹å›å‚³ [[2,2], [0,0], [3,3]]ã€‚å­é™£åˆ—ä¹‹é–“å‹™å¿…åŠ ä¸Šé€—è™Ÿï¼
4. **SPEECH CORRECTION**: Correct any typos in the user's raw speech text and return it in "corrected_text".
`;

            // Add AbortController for timeout
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 30000); // 30s timeout

            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: chatHistory,
                        systemInstruction: { parts: [{ text: finalSystemInstruction }] }
                        // â­ åˆªé™¤ generationConfigï¼Œè§£æ±ºèˆ‡ Google Search Tool è¡çªé€ æˆçš„ 500 Server Error
                    }),
                    signal: controller.signal
                });
                clearTimeout(timeoutId);

                if (!response.ok) {
                    let errMsg = "Server Error";
                    try {
                         const errData = await response.json();
                         if (errData.error) errMsg = errData.error;
                    } catch(e) {}
                    throw new Error(errMsg);
                }

                const data = await response.json();
                removeMessage(loadingMsg);
                
                let rawText = data.candidates?.[0]?.content?.parts?.[0]?.text || "Error";
                
                // åŠ å…¥æ­·å²ç´€éŒ„
                chatHistory.push({ role: "model", parts: [{ text: rawText }] });
                
                // äº¤çµ¦è™•ç†å™¨åˆ†æèˆæ­¥èˆ‡èªªè©±
                handleAIResponse(rawText);
                
                // â­ é¡¯ç¤ºå°è©±æ¡†ï¼šåŠ ä¸Šçµ‚æ¥µé˜²å‘†æ©Ÿåˆ¶ï¼Œè‹¥ç™¼ç”Ÿå¥‡è¹Ÿèˆ¬çš„è§£æå¤±æ•—ï¼Œæˆ‘å€‘ç”¨æ­£å‰‡æ“·å–æ–‡å­—ï¼Œçµ•å°ä¸é¡¯ç¤º JSON ç¨‹å¼ç¢¼
                let tempResult = safeParseAIJson(rawText);
                let displayText = rawText;
                if (tempResult && tempResult.text) {
                    displayText = tempResult.text;
                } else {
                    try {
                        const textMatch = rawText.match(/"text"\s*:\s*"((?:\\"|[^"])*)"/);
                        if (textMatch) {
                            displayText = textMatch[1].replace(/\\n/g, '<br>').replace(/\\"/g, '"');
                        } else {
                            displayText = rawText.replace(/```json/gi, '').replace(/```/g, '').trim();
                        }
                    } catch(e) {
                        displayText = "å¥½å–”ï¼æˆ‘å€‘é€™å°±ç‚ºæ‚¨è·³èˆï¼";
                    }
                }
                addMessage(displayText, 'ai');

            } catch (error) {
                console.error(error);
                removeMessage(loadingMsg);
                if (error.name === 'AbortError') {
                    addMessage(`éŒ¯èª¤: é€£ç·šé€¾æ™‚ (Timeout)ï¼Œè«‹é‡è©¦ã€‚`, 'system');
                } else {
                    addMessage(`éŒ¯èª¤: ${error.message}`, 'system');
                }
            } finally {
                userInput.disabled = false; sendBtn.disabled = false; userInput.focus();
            }
        }

        async function speak(text) {
            if (isMuted) return;
            if (!ttsSupported || !window.speechSynthesis) {
                logTTS("âŒ èªªè©±å¤±æ•—: èªéŸ³åŠŸèƒ½ä¸æ”¯æ´");
                return;
            }

            // ç§»é™¤ç¶²å€èˆ‡ç¬¦è™Ÿï¼Œé¿å… Android TTS ç•¶æ‰
            const cleanText = text
                .replace(/\[.*?\]\(.*?\)/g, '')
                .replace(/[^\u4e00-\u9fa5a-zA-Z0-9,.\?ï¼ã€‚ï¼Œã€â€¦~]/g, '');

            if (!cleanText || cleanText.length === 0) {
                // å¦‚æœæ²’è©±èªªï¼Œä½†åŸæœ¬éœ€è¦é‡å•Ÿéº¥å…‹é¢¨ï¼Œå‰‡å»¶é²é‡å•Ÿ
                if (window.shouldResumeMic) {
                     setTimeout(() => { if(!isRecording) startRecording(); }, 500);
                }
                return;
            }

            logTTS(`æº–å‚™èªªè©±: ${cleanText.substring(0, 10)}...`);

            try {
                // â­â­â­ ç­‰å¾… voices è¼‰å…¥ï¼ˆAndroid è¶…é‡è¦ï¼‰
                if (speechSynthesis.getVoices().length === 0) {
                    logTTS("ç­‰å¾…èªéŸ³åˆ—è¡¨...");
                    await new Promise(r => setTimeout(r, 300));
                }

                // â­â­â­ æ¯æ¬¡èªªè©±å‰éƒ½å…ˆ cancelï¼ˆé¿å…å¡ä½ï¼‰
                speechSynthesis.cancel();
                
                // â­â­â­ æ–°å¢ï¼šç­‰å¾…å¾®å°å»¶é²ï¼Œé¿å…é€£çºŒèª¿ç”¨é€ æˆ interrupted éŒ¯èª¤ â­â­â­
                await new Promise(r => setTimeout(r, 50));

                const u = new SpeechSynthesisUtterance(cleanText);
                
                // â­â­â­ é—œéµä¿®å¾©ï¼šæ›è¼‰åˆ° global è®Šæ•¸ï¼Œé˜²æ­¢è¢« GC å›æ”¶ â­â­â­
                window.currentUtterance = u; 

                // ===== Android å°ˆç”¨å¼·åŒ– =====
                if (isAndroid) {

                    const voices = speechSynthesis.getVoices();

                    // ä¾å„ªå…ˆé †åºæ‰¾ä¸­æ–‡èªéŸ³
                    const voice =
                        voices.find(v => v.lang === 'zh-TW') ||
                        voices.find(v => v.lang.includes('zh-TW')) ||
                        voices.find(v => v.lang.includes('zh-HK')) ||
                        voices.find(v => v.lang.includes('zh-CN')) ||
                        voices.find(v => v.lang.includes('zh'));

                    if (voice) {
                        u.voice = voice;
                        u.lang  = voice.lang;
                        logTTS(`Android ä½¿ç”¨èªéŸ³: ${voice.name}`);
                    } else {
                        u.lang = 'zh-TW';
                        logTTS("Android ä½¿ç”¨é è¨­ zh-TW");
                    }

                } else {
                    // iPhone / PC ä¿æŒç°¡å–®å³å¯
                    u.lang = 'zh-TW';
                }

                u.volume = 1;

                u.onstart = () => {
                    isSpeaking = true;
                    logTTS("é–‹å§‹æ’­æ”¾ (onstart)");
                    // â­â­â­ æ–°å¢ï¼šåªæœ‰åœ¨æ²’æœ‰è·³èˆï¼Œä¸”æœ‰å°ˆå±¬å‹•ä½œæ™‚æ‰æ’­æ”¾ â­â­â­
                    if (!isDancing) {
                        switchToAction(0, talkingActionC, 0.2, false);
                        switchToAction(1, talkingActionW, 0.2, false);
                        switchToAction(2, talkingActionD, 0.2, false);
                    }
                };
                
                u.onend   = () => {
                    isSpeaking = false;
                    logTTS("æ’­æ”¾çµæŸ (onend)");
                    // çµæŸæ™‚è®“æ‰€æœ‰è§’è‰²é–‰å˜´
                    currentVrms.forEach(vrm => {
                        if(vrm) {
                            vrm.expressionManager.setValue('aa', 0);
                            // â­ å¦‚æœæ˜¯é–‹å ´ç™½çµæŸï¼Œæ¸…é™¤å…¶ä»–è§’è‰²çš„å¤§ç¬‘è¡¨æƒ…
                            if (isOpeningRemark) {
                                vrm.expressionManager.setValue('happy', 0);
                            }
                        }
                    });
                    
                    isOpeningRemark = false; // â­ é‡ç½®é–‹å ´ç™½æ¨™è¨˜
                    
                    // æ¢å¾©é–’ç½®
                    // â­â­â­ é—œéµï¼šå¿…é ˆå†æ¬¡æª¢æŸ¥ !isDancingï¼Œé˜²æ­¢èªéŸ³ cancel è§¸ç™¼ onend æ™‚å¼·åˆ¶æ‰“æ–·èˆè¹ˆ
                    if (!isDancing) {
                        switchToAction(0, idleActionC, 0.5, false);
                        switchToAction(1, idleActionW, 0.5, false);
                        switchToAction(2, idleActionD, 0.5, false);
                    }

                    // â­â­â­ Auto Resume Mic logic â­â­â­
                    if (window.shouldResumeMic) {
                        if (isDancing) {
                            // â­ ä¿®æ­£ï¼šå¦‚æœæ­¤æ™‚ä»–å€‘é‚„åœ¨è·³èˆï¼Œå°±å…ˆä¸è¦è‡ªå‹•é–‹éº¥å…‹é¢¨ï¼Œç­‰è·³å®Œå†é–‹ï¼Œç¢ºä¿éŸ³æ¨‚ä¸æœƒè¢«å¼·åˆ¶æš«åœï¼
                            window.pendingMicResume = true;
                        } else {
                            setTimeout(() => {
                                if (!isRecording) startRecording();
                            }, 500);
                        }
                    }
                };

                u.onerror = (e) => {
                    // â­â­â­ æ–°å¢ï¼šéæ¿¾æ­£å¸¸çš„æ’æ’­ä¸­æ–· â­â­â­
                    if (e.error === 'interrupted' || e.error === 'canceled') {
                        return; // é€™æ˜¯æ­£å¸¸çš„ï¼Œä¸é¡¯ç¤ºéŒ¯èª¤
                    }
                    console.error("TTS error detail:", e.error);
                    logTTS(`TTS éŒ¯èª¤: ${e.error}`);
                };

                speechSynthesis.speak(u);

            } catch (err) {
                console.error("Speech error:", err);
                logTTS(`Speech åŸ·è¡ŒéŒ¯èª¤: ${err.message}`);
            }
        }

        sendBtn.addEventListener('click', handleSendMessage);
        // æ–°å¢ touchend æ”¯æ´ï¼Œè§£æ±ºéƒ¨åˆ†æ‰‹æ©Ÿé»æ“Šç„¡åæ‡‰å•é¡Œ
        sendBtn.addEventListener('touchend', (e) => {
            e.preventDefault(); // é˜²æ­¢è§¸ç™¼ click é€ æˆé›™é‡ç™¼é€
            handleSendMessage();
        });

        userInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') handleSendMessage(); });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            // è¦–çª—æ”¹è®Šå¤§å°æ™‚ï¼Œé‡æ–°æª¢æŸ¥ç›¸æ©Ÿä½ç½®
            updateCameraPosition();
        });

        // â­â­â­â­â­ éº¥å…‹é¢¨èˆ‡èªéŸ³è¾¨è­˜åŠŸèƒ½æ•´åˆ (å®Œå…¨ä¿ç•™ç©©å®šç‰ˆé‚è¼¯) â­â­â­â­â­
        let recognition = null;
        let isRecording = false;
        let silenceTimer = null;
        let finalTranscript = '';
        const voiceOverlay = document.getElementById('voice-overlay'); // è—è‰²æ³¢å‹•æ¢

        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
            const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SR();
            
            // â­â­â­ iOS é—œéµå„ªåŒ–ï¼šå¼·åˆ¶é—œé–‰é€£çºŒæ¨¡å¼ä»¥è§£æ±ºè¾¨è­˜éŒ¯èª¤ â­â­â­
            if (isIOS || isAndroid) {
                recognition.continuous = false; // æ‰‹æ©Ÿç‰ˆï¼šè¬›ä¸€å¥è¾¨è­˜ä¸€å¥ï¼Œæº–ç¢ºåº¦æœ€é«˜
                recognition.maxAlternatives = 1; // æ¸›å°‘é‹ç®—è² æ“”
            } else {
                recognition.continuous = true; // é›»è…¦ç‰ˆï¼šä¿æŒé€£çºŒå°è©±èƒ½åŠ›
            }
            
            recognition.interimResults = true; 
            recognition.lang = 'zh-TW'; // é è¨­ä¸­æ–‡ï¼Œæ‚¨å¯ä»¥æ ¹æ“šéœ€è¦ä¿®æ”¹

            recognition.onstart = () => { 
                isRecording = true; 
                updateMicUI(true); 
                // åœæ­¢èƒŒæ™¯éŸ³æ¨‚æˆ– TTS è²éŸ³ï¼Œé¿å…å¹²æ“¾
                if (window.speechSynthesis) window.speechSynthesis.cancel();
                // â­â­â­ é—œéµä¿®å¾©ï¼šé–‹å§‹éŒ„éŸ³æ™‚å¼·åˆ¶æš«åœ BGMï¼Œé¿å…è¿´éŸ³å¹²æ“¾è¾¨è­˜ â­â­â­
                bgm.pause();
                
                isSpeaking = false; 
            };
            
            recognition.onend = () => { 
                // å¦‚æœæ˜¯é€£çºŒæ¨¡å¼ä¸”ä»ç„¶æ¨™è¨˜ç‚ºéŒ„éŸ³ä¸­ï¼ˆéæ‰‹å‹•åœæ­¢ï¼‰ï¼Œå‰‡å˜—è©¦é‡å•Ÿ
                if (isRecording) {
                    // â­â­â­ iOS/Android çš„æ‰‹å‹•é€£çºŒæ¨¡å¼æ¨¡æ“¬ â­â­â­
                    if (isIOS || isAndroid) {
                       // æ‰‹æ©Ÿç‰ˆï¼šçŸ­æš«å»¶é²å¾Œé‡å•Ÿï¼Œé¿å…éåº¦é »ç¹èª¿ç”¨ API
                       setTimeout(() => safeStartRecognition(), 100);
                    } else {
                       // â­â­â­ FIX: é›»è…¦ç‰ˆä¹ŸåŠ å…¥çŸ­æš«å»¶é²ï¼Œé¿å… aborted ç„¡é™è¿´åœˆå ±éŒ¯ â­â­â­
                       setTimeout(() => {
                           if (isRecording) safeStartRecognition(); 
                       }, 250);
                    }
                } else {
                    updateMicUI(false); 
                }
            };
            
            recognition.onerror = (e) => { 
                // â­â­â­ FIX: å¿½ç•¥ no-speech èˆ‡ aborted éŒ¯èª¤ï¼Œé¿å…æ´—ç‰ˆèˆ‡ç„¡é™è¿´åœˆ â­â­â­
                if (e.error === 'no-speech' || e.error === 'aborted') {
                    // é€™æ˜¯æ­£å¸¸çš„éœéŸ³è¶…æ™‚æˆ–æ˜¯è¢«ç³»çµ±ä¸­æ–·ï¼Œè®“ onend è² è²¬å»¶é²é‡å•Ÿå³å¯
                    return;
                }

                console.error("Speech Recognition Error:", e.error);
                // æŸäº›éŒ¯èª¤éœ€è¦å®Œå…¨åœæ­¢
                if (e.error === 'not-allowed' || e.error === 'service-not-allowed') {
                    isRecording = false;
                    updateMicUI(false);
                    // â­â­â­ æ–°å¢ï¼šå¦‚æœæ¬Šé™è¢«æ‹’ï¼Œæ˜ç¢ºæç¤ºä½¿ç”¨è€… â­â­â­
                    alert("éº¥å…‹é¢¨åŠŸèƒ½å·²è¢«å°é–æˆ–ä¸æ”¯æ´ã€‚\nè«‹æª¢æŸ¥ç€è¦½å™¨æ¬Šé™è¨­å®šï¼Œæˆ–å˜—è©¦åœ¨ Safari (iOS) / Chrome (Android) ä¸­é–‹å•Ÿã€‚");
                } else {
                    // å…¶ä»–éŒ¯èª¤å˜—è©¦é‡å•Ÿ
                    recognition.stop();
                }
            };

            recognition.onresult = (e) => {
                let interim = '';
                // é‡æ–°çµ„åˆæœ€çµ‚çµæœèˆ‡è‡¨æ™‚çµæœ
                // æ³¨æ„ï¼šé€™è£¡æ˜¯ç°¡æ˜“å¯¦ä½œï¼Œç›´æ¥è¦†è“‹ input
                // AITranslator é‚è¼¯ï¼š
                for (let i = e.resultIndex; i < e.results.length; ++i) {
                    if (e.results[i].isFinal) {
                        finalTranscript += e.results[i][0].transcript;
                    } else {
                        interim += e.results[i][0].transcript;
                    }
                }
                
                // å°‡çµæœå¡«å…¥è¼¸å…¥æ¡†
                // ç‚ºäº†è®“ä½¿ç”¨è€…é«”é©—æ›´å¥½ï¼Œæˆ‘å€‘ä¿ç•™ä½¿ç”¨è€…å¯èƒ½æ‰‹æ‰“çš„éƒ¨åˆ†å—ï¼Ÿ
                // é€™è£¡æ¡ç”¨ AITranslator çš„é‚è¼¯ï¼šç›´æ¥ç”±èªéŸ³ä¸»å°
                userInput.value = finalTranscript + interim;
                
                // é‡ç½®éœéŸ³è¨ˆæ™‚å™¨
                clearTimeout(silenceTimer);
                
                // å¦‚æœæœ‰å…§å®¹ï¼Œè¨­å®š 1.5 ç§’å¾Œè‡ªå‹•ç™¼é€
                if (userInput.value.trim()) {
                    silenceTimer = setTimeout(async () => { 
                        const rawText = userInput.value.trim();
                        if(rawText) {
                            // â­â­â­ ä¿®æ”¹ï¼šåˆä½µè™•ç†ï¼Œä¸å–®ç¨å‘¼å«æ ¡æ­£ APIï¼Œç›´æ¥ç™¼é€ â­â­â­
                            handleSendMessage();
                        }
                    }, 1500);
                }
            };
        } else {
            console.warn("ç€è¦½å™¨ä¸æ”¯æ´ Web Speech API");
            micBtn.style.display = 'none';
        }

        function toggleRecording() {
            if(!recognition) return;
            if(isRecording) stopRecording(); else startRecording();
        }

        // â­â­â­ [CRITICAL IOS FIX] å¿…é ˆåŒæ­¥å‘¼å«ï¼Œç§»é™¤ async/await â­â­â­
        function startRecording() {
            // â­ æ–°å¢ï¼šå¦‚æœæ‰‹å‹•é»æ“ŠéŒ„éŸ³æ™‚å¤§å®¶æ­£åœ¨è·³èˆï¼Œå¼·åˆ¶ä¸­æ–·è·³èˆä¸¦åœæ­¢éŸ³æ¨‚
            if (isDancing) {
                stopDance();
            }

            // 1. ç«‹å³åœæ­¢ TTS (åŒæ­¥åŸ·è¡Œ)
            if (window.speechSynthesis) {
                // åŠ å€‹ try-catch ç¢ºä¿è¬ç„¡ä¸€å¤±
                try {
                    window.speechSynthesis.cancel();
                } catch(e) {}
            }
            isSpeaking = false;

            // 2. æ¸…ç©º UI
            finalTranscript = ''; 
            userInput.value = ''; 
            isRecording = true; 
            
            // 3. ç«‹å³å•Ÿå‹•éŒ„éŸ³ (å¿…é ˆåœ¨ Event Loop åŒä¸€ tick å…§)
            safeStartRecognition();
        }

        function stopRecording() { 
            isRecording = false; 
            recognition.stop(); 
            clearTimeout(silenceTimer); 
            updateMicUI(false); 
        }

        function safeStartRecognition() { 
            try { 
                recognition.start(); 
            } catch(e) {
                // æœ‰æ™‚å€™å·²ç¶“ start äº†æœƒå ±éŒ¯ï¼Œå¿½ç•¥å³å¯
            } 
        }

        function updateMicUI(active) {
            if(active) { 
                micBtn.classList.add('recording-pulse'); // åŠ å…¥ç´…è‰²è„ˆè¡å‹•ç•«
                micBtn.innerHTML = '<i class="fa-solid fa-microphone-lines"></i>'; // æ”¹è®Šåœ–ç¤º
                voiceOverlay.style.display = 'block'; // é¡¯ç¤ºè—è‰²æ³¢å‹•æ¢
            } else { 
                micBtn.classList.remove('recording-pulse'); 
                micBtn.innerHTML = '<i class="fa-solid fa-microphone"></i>';
                voiceOverlay.style.display = 'none'; // éš±è—è—è‰²æ³¢å‹•æ¢
            }
        }

        // ç¶å®šéº¥å…‹é¢¨æŒ‰éˆ•äº‹ä»¶
        micBtn.addEventListener('click', (e) => {
            logTTS(`éº¥å…‹é¢¨æŒ‰éˆ•è§¸ç™¼: ${e.type}`); // Debug è¨Šæ¯
            
            // â­â­â­ æ–°å¢ï¼šLINE/Facebook å…§å»ºç€è¦½å™¨é˜»æ“‹æç¤º â­â­â­
            if (isIOS && (isLineApp || isFbApp)) {
                alert("âš ï¸ LINE/Facebook å…§å»ºç€è¦½å™¨ä¸æ”¯æ´éº¥å…‹é¢¨éŒ„éŸ³ã€‚\n\nè«‹é»æ“Šå³ä¸Šè§’/å³ä¸‹è§’é¸å–®ï¼Œé¸æ“‡ã€Œåœ¨ Safari é–‹å•Ÿã€æˆ–ã€Œé–‹å•Ÿé è¨­ç€è¦½å™¨ã€å³å¯ä½¿ç”¨å®Œæ•´åŠŸèƒ½ã€‚");
                return;
            }
            
            toggleRecording();
        });

        // â­â­â­ æ–°å¢ï¼šå¦‚æœæ˜¯æ‰‹æ©Ÿç‰ˆ (Android/iOS)ï¼Œéš±è—éº¥å…‹é¢¨æŒ‰éˆ•ï¼Œåƒ…ä¿ç•™PCç‰ˆåŠŸèƒ½ â­â­â­
        if (isAndroid || isIOS) {
            micBtn.style.display = 'none';
        }

    </script>
</body>
</html>
