<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="utf-8">
<title>AI VTuber - Idle Animations Removed</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<style>
    body {
        margin: 0;
        padding: 0;
        overflow: hidden; 
        /* Á∂≠ÊåÅ‰∫ÆÈáëËâ≤Êº∏Â±§ËÉåÊôØ */
        background: linear-gradient(135deg, #fff8e1 0%, #ffecb3 50%, #ffe0b2 100%);
        font-family: "Noto Sans TC", sans-serif;
        overscroll-behavior: none; 
        width: 100vw;
        height: 100vh;
        height: -webkit-fill-available;
    }
    
    #loading-screen {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(255, 255, 255, 0.95);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 999;
        transition: opacity 0.5s ease;
    }
    
    .loader {
        border: 4px solid #fff3e0;
        border-top: 4px solid #3498db; /* ÊîπÂõûËóçËâ≤ */
        border-radius: 50%;
        width: 40px; height: 40px;
        animation: spin 1s linear infinite;
        margin-bottom: 15px;
    }

    .loading-text { color: #555; font-size: 1rem; font-weight: bold; margin-bottom: 20px; }

    #start-btn {
        padding: 12px 30px;
        font-size: 1.1rem;
        background: #3498db; /* ÊîπÂõûËóçËâ≤ */
        color: white;
        border: none;
        border-radius: 50px;
        cursor: pointer;
        display: none;
        box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
        transition: transform 0.2s, background 0.2s;
        font-weight: bold;
    }
    #start-btn:active { transform: scale(0.95); background: #2980b9; }

    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    #api-status {
        position: absolute;
        top: 15px; right: 15px;
        padding: 6px 12px;
        background: rgba(255, 255, 255, 0.8);
        backdrop-filter: blur(4px);
        border-radius: 20px;
        font-size: 12px;
        font-weight: bold;
        color: #333; /* ÊîπÂõûÈªëËâ≤ */
        display: flex; align-items: center;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        z-index: 100;
        transition: all 0.3s;
        border: 1px solid #ddd;
    }
    .status-dot { width: 8px; height: 8px; border-radius: 50%; background-color: #ccc; margin-right: 6px; }
    .status-connected { background-color: #2ecc71; box-shadow: 0 0 5px #2ecc71; }
    .status-error { background-color: #e74c3c; box-shadow: 0 0 5px #e74c3c; }
    .status-preview { background-color: #f39c12; box-shadow: 0 0 5px #f39c12; }

    #file-status {
        position: absolute;
        top: 15px; left: 15px;
        padding: 10px;
        background: rgba(255, 255, 255, 0.8);
        backdrop-filter: blur(4px);
        border-radius: 12px;
        font-size: 12px;
        color: #5d4037;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        z-index: 100;
        max-width: 200px;
        transition: opacity 0.5s;
        pointer-events: none;
        border: 1px solid #ddd;
    }
    .file-status-item { 
        margin-bottom: 4px; 
        display: flex; 
        align-items: center; 
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    .file-status-item:last-child { margin-bottom: 0; }
    .icon-ok { color: #2e7d32; margin-right: 6px; font-weight: bold; }
    .icon-fail { color: #c62828; margin-right: 6px; font-weight: bold; }
    .icon-loading { color: #ef6c00; margin-right: 6px; animation: pulse 1s infinite; }
    
    #chat-container {
        position: absolute; 
        bottom: 20px; 
        left: 50%; 
        transform: translateX(-50%);
        width: 90%; 
        max-width: 600px;
        display: flex; 
        flex-direction: column; 
        gap: 8px;
        z-index: 100;
        transition: bottom 0.3s;
    }

    @media (max-width: 600px) {
        #chat-container { width: 95%; bottom: 30px; }
        #file-status, #api-status { top: 10px; transform: scale(0.9); transform-origin: top; }
        #file-status { left: 10px; }
        #api-status { right: 10px; }
    }

    #chat-display {
        background: rgba(255, 255, 255, 0.4); 
        padding: 12px; 
        border-radius: 16px;
        height: 140px; 
        overflow-y: auto;
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 215, 0, 0.6);
        display: flex;
        flex-direction: column;
        gap: 8px;
        scrollbar-width: none; 
        -ms-overflow-style: none;
    }
    #chat-display::-webkit-scrollbar { display: none; }

    .message {
        padding: 8px 12px;
        border-radius: 12px;
        max-width: 85%;
        word-wrap: break-word;
        font-size: 14px;
        line-height: 1.5;
        color: white;
        text-shadow: 0 1px 1px rgba(0,0,0,0.1);
    }

    .message-user { align-self: flex-end; background-color: rgba(52, 152, 219, 0.9); border-bottom-right-radius: 2px; color: #fff; } /* ËóçËâ≤ */
    .message-ai { align-self: flex-start; background-color: rgba(255, 255, 255, 0.9); border-bottom-left-radius: 2px; color: #333; text-shadow: none; border: 1px solid #ffd700; }
    .message-system { align-self: center; background: transparent; color: #e65100; font-size: 12px; font-style: italic; text-shadow: none; text-align: center;}
    .message a { color: #1e88e5; text-decoration: none; border-bottom: 1px dotted #1e88e5; }
    .message-user a { color: #ffe0b2; }

    #input-area { display: flex; gap: 8px; align-items: center; }
    #user-input { flex: 1; padding: 12px 16px; border-radius: 25px; border: 1px solid rgba(255, 215, 0, 0.6); outline: none; background: rgba(255, 255, 255, 0.95); font-size: 16px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); color: #5d4037; }
    #user-input::placeholder { color: #999; }
    
    #send-btn { 
        padding: 0 20px; 
        height: 44px; 
        border-radius: 22px; 
        border: none; 
        background: #3498db; /* ÊîπÂõûËóçËâ≤ */
        color: white; 
        font-weight: bold; 
        cursor: pointer; 
        transition: background 0.2s; 
        box-shadow: 0 4px 10px rgba(52, 152, 219, 0.3); 
        flex-shrink: 0; 
    }
    #send-btn:active { transform: scale(0.95); }
    #send-btn:disabled { background: #bdbdbd; box-shadow: none; cursor: not-allowed; color: #fff;}
    
    #mute-btn { width: 44px; height: 44px; border-radius: 50%; border: none; background: rgba(255, 255, 255, 0.95); font-size: 20px; cursor: pointer; display: flex; justify-content: center; align-items: center; box-shadow: 0 4px 10px rgba(0,0,0,0.1); flex-shrink: 0; border: 1px solid #ffd700; color: #3498db; }
    #mute-btn.muted { background: #e74c3c; color: white; border: none; }
    
    #emotion-debug {
        position: absolute; top: 60px; right: 15px;
        font-size: 10px; color: #5d4037;
        background: rgba(255,255,255,0.7);
        padding: 4px 8px; border-radius: 6px;
        pointer-events: none;
        backdrop-filter: blur(2px);
        text-align: right;
        line-height: 1.3;
        opacity: 0.6; 
    }
</style>

<script type="importmap">
{
    "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/",
        "@pixiv/three-vrm": "https://unpkg.com/@pixiv/three-vrm@3.0.0/lib/three-vrm.module.js"
    }
}
</script>
</head>

<body>

    <div id="loading-screen">
        <div class="loader" id="loader"></div>
        <div class="loading-text" id="status-text">ÂàùÂßãÂåñÊñ∞Âπ¥Á≥ªÁµ±...</div>
        <button id="start-btn">ÈñãÂßãÂ∞çË©±</button>
    </div>

    <div id="file-status">
        <div class="file-status-item"><span class="icon-loading">‚óè</span> Á≥ªÁµ±ÂïüÂãï...</div>
    </div>

    <div id="api-status">
        <div class="status-dot" id="status-dot"></div>
        <span id="status-msg">ÈÄ£Á∑ö‰∏≠...</span>
    </div>
    
    <div id="emotion-debug">
        ÊÉÖÁ∑í: Neutral<br>
        Âãï‰Ωú: None
    </div>

    <div id="chat-container">
        <div id="chat-display"></div>
        <div id="input-area">
            <button id="mute-btn" title="ÂàáÊèõËÅ≤Èü≥">üîä</button>
            <input type="text" id="user-input" placeholder="Ëº∏ÂÖ•Ë®äÊÅØ..." disabled>
            <button id="send-btn" disabled>ÁôºÈÄÅ</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';

        const API_URL = "/api/chat"; 
        const VRM_URL = 'https://davidkuodcam-crypto.github.io/VTuber/AvatarSample_C.vrm';
        
        let currentVrm = undefined;
        let chatHistory = [];
        let isSpeaking = false;
        let isMuted = false;
        let externalSystemPrompt = ""; 
        let externalKnowledge = "";
        let openingRemark = ""; 

        const isPreviewEnv = window.location.protocol === 'blob:' || window.location.protocol === 'file:';

        // --- Â†¥ÊôØÂàùÂßãÂåñ ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xfff8e1); 
        scene.fog = new THREE.Fog(0xfff8e1, 5, 15);
        scene.add(new THREE.GridHelper(20, 20, 0xd32f2f, 0xffcc80)); 

        const camera = new THREE.PerspectiveCamera(30.0, window.innerWidth / window.innerHeight, 0.1, 20.0);
        
        function updateCameraPosition() {
            const aspect = window.innerWidth / window.innerHeight;
            // Â∞çË©±ÁâπÂØ´Ë¶ñËßí
            if (aspect < 0.8) {
                camera.position.set(0.0, 1.35, 2.2); 
                if(currentVrm) controls.target.set(0.0, 1.35, 0.0);
            } else {
                camera.position.set(0.0, 1.4, 3.5);
                if(currentVrm) controls.target.set(0.0, 1.3, 0.0); 
            }
            camera.updateProjectionMatrix();
            controls.update();
        }

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
        document.body.appendChild(renderer.domElement);

        const directionalLight = new THREE.DirectionalLight(0xffedd5, 1.5); 
        directionalLight.position.set(-1.0, 2.0, 1.0).normalize();
        scene.add(directionalLight);
        scene.add(new THREE.DirectionalLight(0xffd700, 0.6));
        scene.add(new THREE.AmbientLight(0xffffff, 0.5));

        // --- Á≤íÂ≠êÁâπÊïà ---
        let particlesMesh;
        const particlesCount = 300; 
        function createFestiveParticles() {
            const geometry = new THREE.BufferGeometry();
            const posArray = new Float32Array(particlesCount * 3);
            const colorArray = new Float32Array(particlesCount * 3);
            for(let i = 0; i < particlesCount * 3; i+=3) {
                posArray[i] = (Math.random() - 0.5) * 15; 
                posArray[i+1] = Math.random() * 10;       
                posArray[i+2] = (Math.random() - 0.5) * 15; 
                if (Math.random() > 0.5) { colorArray[i] = 0.9; colorArray[i+1] = 0.1; colorArray[i+2] = 0.1; } 
                else { colorArray[i] = 0.8; colorArray[i+1] = 0.6; colorArray[i+2] = 0.0; }
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));
            const material = new THREE.PointsMaterial({ size: 0.15, vertexColors: true, transparent: true, opacity: 0.8 });
            particlesMesh = new THREE.Points(geometry, material);
            scene.add(particlesMesh);
        }
        createFestiveParticles();

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enablePan = true; controls.screenSpacePanning = true; 
        controls.enableDamping = true; controls.dampingFactor = 0.05;
        controls.minDistance = 1.0; controls.maxDistance = 8.0;
        controls.maxPolarAngle = Math.PI / 2 + 0.1; controls.minPolarAngle = Math.PI / 3;
        updateCameraPosition(); 

        // --- ËºâÂÖ•Â§ñÈÉ®Ê™îÊ°àËàáÊ®°Âûã ---
        async function loadData() {
            const statusText = document.getElementById('status-text');
            const fileStatusDiv = document.getElementById('file-status');
            
            let promptStatus = '<span class="icon-loading">‚óè</span> Prompt';
            let kbStatus = '<span class="icon-loading">‚óè</span> KB';

            const updateStatus = () => {
                fileStatusDiv.innerHTML = `
                    <div class="file-status-item">${promptStatus}</div>
                    <div class="file-status-item">${kbStatus}</div>
                `;
            };
            updateStatus();

            // 1. Prompt & KB
            statusText.innerText = "ËÆÄÂèñÁü•Ë≠òÂ∫´...";
            try {
                const res = await fetch(`./Prompt.txt?t=${Date.now()}`);
                if (res.ok) { externalSystemPrompt = await res.text(); promptStatus = '<span class="icon-ok">‚úì</span> Prompt OK'; }
                else promptStatus = '<span class="icon-fail">‚úó</span> Prompt Def';
            } catch(e) { promptStatus = '<span class="icon-fail">‚úó</span> Prompt Err'; }
            updateStatus();

            let fileIndex = 1;
            let loadedCount = 0;
            while(true) {
                try {
                    const fname = `KnowledgeBase${String(fileIndex).padStart(2,'0')}.txt`;
                    const res = await fetch(`./${fname}?t=${Date.now()}`); 
                    
                    if(res.ok) {
                        const txt = await res.text();
                        if(fileIndex===1) openingRemark = txt;
                        externalKnowledge += `\n[KB:${fname}]\n${txt}`;
                        loadedCount++; fileIndex++;
                    } else {
                        break; 
                    }
                } catch(e) { break; }
            }
            if(loadedCount>0) kbStatus = `<span class="icon-ok">‚úì</span> KB x${loadedCount}`;
            else kbStatus = `<span class="icon-fail">‚úó</span> No KB`;
            updateStatus();

            // 2. VRM
            statusText.innerText = "ËºâÂÖ•Ê®°Âûã...";
            try {
                // VRM Loader
                const loader = new GLTFLoader();
                loader.crossOrigin = 'anonymous';
                loader.register(parser => new VRMLoaderPlugin(parser));
                
                const vrmGltf = await new Promise((res, rej) => loader.load(VRM_URL, res, undefined, rej));
                const vrm = vrmGltf.userData.vrm;
                VRMUtils.rotateVRM0(vrm);
                scene.add(vrm.scene);
                currentVrm = vrm;

                // Arm Fix
                const lArm = vrm.humanoid.getNormalizedBoneNode('leftUpperArm');
                const rArm = vrm.humanoid.getNormalizedBoneNode('rightUpperArm');
                if(lArm) { lArm.rotation.z = -1.1; lArm.rotation.x = 0.15; }
                if(rArm) { rArm.rotation.z = 1.1; rArm.rotation.x = 0.15; }

                updateCameraPosition();
                startBlinking();

                // Ready
                document.getElementById('loader').style.display = 'none';
                statusText.innerText = "Ê∫ñÂÇôÂÆåÊàê";
                document.getElementById('start-btn').style.display = 'block';

            } catch(e) {
                statusText.innerText = "Ê®°ÂûãËºâÂÖ•Â§±Êïó";
                console.error(e);
            }
        }

        document.getElementById('start-btn').addEventListener('click', () => {
            if(!isMuted) {
                window.speechSynthesis.cancel();
                window.speechSynthesis.speak(new SpeechSynthesisUtterance(" "));
            }
            document.getElementById('loading-screen').style.display = 'none';
            
            const intro = openingRemark || "ÔºàÊú™ËÆÄÂèñÂà∞ KnowledgeBase01.txtÔºâ";
            addMessage(intro, 'ai');
            chatHistory.push({ role: "model", parts: [{ text: intro }] });
            speak(intro);
            testApiConnection();
        });

        // --- Animation Loop ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const elapsed = clock.elapsedTime;

            if (currentVrm) {
                currentVrm.update(delta);
                
                // ÂëºÂê∏ÂíåË™™Ë©±Âò¥Âûã
                const spine = currentVrm.humanoid.getNormalizedBoneNode('spine');
                if (spine) {
                    spine.rotation.x = Math.sin(elapsed * 1.5) * 0.02;
                    spine.rotation.y = Math.sin(elapsed * 0.8) * 0.02;
                }
                if (isSpeaking && !isMuted) {
                    const s = Math.sin(elapsed * 18); 
                    currentVrm.expressionManager.setValue('aa', (s + 1) / 2 * 0.6);
                } else {
                    const v = currentVrm.expressionManager.getValue('aa');
                    currentVrm.expressionManager.setValue('aa', THREE.MathUtils.lerp(v, 0, 0.2));
                }
            }

            if (particlesMesh) {
                particlesMesh.rotation.y += 0.001;
                const pos = particlesMesh.geometry.attributes.position.array;
                for(let i=1; i<particlesCount*3; i+=3) {
                    pos[i] -= 0.015;
                    if(pos[i] < 0) pos[i] = 10;
                }
                particlesMesh.geometry.attributes.position.needsUpdate = true;
            }

            controls.update();
            renderer.render(scene, camera);
        }
        
        loadData(); // Start Loading
        animate();

        // --- Utils (Chat, Blink, etc) ---
        function startBlinking() {
            if(!currentVrm) return;
            const blinkLoop = () => {
                if (!window.actionActive) {
                    setTimeout(() => {
                        currentVrm.expressionManager.setValue('blink', 1);
                        setTimeout(() => {
                            currentVrm.expressionManager.setValue('blink', 0);
                            blinkLoop();
                        }, 120);
                    }, Math.random() * 3000 + 2000);
                } else {
                    setTimeout(blinkLoop, 1000);
                }
            };
            blinkLoop();
        }

        function addMessage(text, type) {
            const div = document.createElement('div');
            div.className = `message message-${type}`;
            div.innerHTML = text.replace(/\n/g, "<br>");
            document.getElementById('chat-display').appendChild(div);
            document.getElementById('chat-display').scrollTo({ top: 99999, behavior: 'smooth' });
        }

        function removeMessage(el) { if(el?.parentNode) el.parentNode.removeChild(el); }

        async function testApiConnection() {
            if (isPreviewEnv) return;
            const dot = document.getElementById('status-dot');
            const msg = document.getElementById('status-msg');
            msg.innerText = "ÈÄ£Á∑öÊ∏¨Ë©¶...";
            try {
                const res = await fetch(API_URL, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ contents: [{ parts: [{ text: "Test" }] }] })
                });
                if(res.ok) { dot.classList.add('status-connected'); msg.innerText = "Á≥ªÁµ±Ê≠£Â∏∏"; 
                             document.getElementById('user-input').disabled = false; 
                             document.getElementById('send-btn').disabled = false; }
                else throw new Error("API Err");
            } catch(e) { dot.classList.add('status-error'); msg.innerText = "ÈÄ£Á∑öÂ§±Êïó"; }
        }

        document.getElementById('send-btn').addEventListener('click', handleSendMessage);
        
        async function handleSendMessage() {
            const input = document.getElementById('user-input');
            const text = input.value.trim();
            if(!text) return;
            
            if(!isMuted) { window.speechSynthesis.cancel(); window.speechSynthesis.speak(new SpeechSynthesisUtterance(" ")); }

            input.value = ''; 
            addMessage(text, 'user');
            
            if (isPreviewEnv) { addMessage("È†êË¶ΩÊ®°ÂºèÁÑ°Ê≥ïÈÄ£Á∑ö", 'system'); return; }

            const loadMsg = document.createElement('div');
            loadMsg.className = 'message message-system';
            loadMsg.innerText = 'Thinking...';
            document.getElementById('chat-display').appendChild(loadMsg);

            chatHistory.push({ role: "user", parts: [{ text }] });
            
            try {
                let sysPrompt = externalSystemPrompt || "You are a VTuber.";
                if(externalKnowledge) sysPrompt += "\nKB:\n" + externalKnowledge;
                
                const res = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: chatHistory, systemInstruction: { parts: [{ text: sysPrompt }] } })
                });
                
                if(!res.ok) throw new Error("Server Error");
                const data = await response.json(); 
                const jsonData = await res.json(); 
                
                removeMessage(loadMsg);
                const raw = jsonData.candidates?.[0]?.content?.parts?.[0]?.text || "Error";
                let result = { text: raw, emotion: 'neutral' };
                try { result = JSON.parse(raw.match(/\{[\s\S]*\}/)[0]); } catch(e){}
                if(!result.text) result.text = raw;

                chatHistory.push({ role: "model", parts: [{ text: result.text }] });
                addMessage(result.text, 'ai');
                setEmotion(result.emotion);
                if(result.action) triggerAction(result.action, 2000);
                speak(result.text);
            } catch(e) {
                removeMessage(loadMsg);
                addMessage("ÈÄ£Á∑öÈåØË™§", 'system');
            }
        }

        function triggerAction(act, dur) {
            if(!currentVrm || act==='none') return;
            window.actionActive = true;
            let name = act==='blink_left'?'blinkLeft':(act==='blink_right'?'blinkRight':'blink');
            currentVrm.expressionManager.setValue(name, 1);
            setTimeout(()=>{ currentVrm.expressionManager.setValue(name, 0); window.actionActive=false; }, dur);
        }
        
        function setEmotion(emo) {
            if(!currentVrm) return;
            ['neutral','happy','angry','sad','relaxed','surprised'].forEach(e=>currentVrm.expressionManager.setValue(e,0));
            if(emo!=='neutral') currentVrm.expressionManager.setValue(emo, 0.8);
        }

        function speak(text) {
            if(isMuted) return;
            const u = new SpeechSynthesisUtterance(text.replace(/[^\u4e00-\u9fa5a-zA-Z0-9,.\?]/g, ''));
            u.lang = 'zh-TW';
            u.onstart = () => isSpeaking = true;
            u.onend = () => { isSpeaking = false; if(currentVrm) currentVrm.expressionManager.setValue('aa', 0); };
            window.speechSynthesis.speak(u);
        }

        document.getElementById('mute-btn').addEventListener('click', (e) => {
            isMuted = !isMuted;
            e.target.classList.toggle('muted', isMuted);
            e.target.innerText = isMuted ? 'üîá' : 'üîä';
            if(isMuted) window.speechSynthesis.cancel();
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            updateCameraPosition();
        });
    </script>
</body>
</html>
